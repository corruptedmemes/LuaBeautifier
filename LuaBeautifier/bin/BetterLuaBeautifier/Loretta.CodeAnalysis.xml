<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Loretta.CodeAnalysis</name>
    </assembly>
    <members>
        <member name="T:Loretta.CodeAnalysis.CodeAnalysisResources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.A_language_name_cannot_be_specified_for_this_option">
            <summary>
              Looks up a localized string similar to A language name cannot be specified for this option..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.A_language_name_must_be_specified_for_this_option">
            <summary>
              Looks up a localized string similar to A language name must be specified for this option..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.AbsolutePathExpected">
            <summary>
              Looks up a localized string similar to Absolute path expected..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.AnalyzerDriverFailure">
            <summary>
              Looks up a localized string similar to Analyzer Driver Failure.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.AnalyzerDriverThrows">
            <summary>
              Looks up a localized string similar to Analyzer driver threw an exception of type &apos;{0}&apos; with message &apos;{1}&apos;..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.AnalyzerDriverThrowsDescription">
             <summary>
               Looks up a localized string similar to Analyzer driver threw the following exception:
            &apos;{0}&apos;..
             </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.AnalyzerExecutionTimeColumnHeader">
            <summary>
              Looks up a localized string similar to Time (s).
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.AnalyzerNameColumnHeader">
            <summary>
              Looks up a localized string similar to Analyzer.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.AnalyzerTotalExecutionTime">
            <summary>
              Looks up a localized string similar to Total analyzer execution time: {0} seconds..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.AnonymousTypeArgumentCountMismatch2">
            <summary>
              Looks up a localized string similar to {0} must either be &apos;default&apos; or have the same length as {1}..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.AnonymousTypeMemberAndNamesCountMismatch2">
            <summary>
              Looks up a localized string similar to {0} and {1} must have the same length..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.ArgumentCannotBeEmpty">
            <summary>
              Looks up a localized string similar to Argument cannot be empty..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.ArgumentElementCannotBeNull">
            <summary>
              Looks up a localized string similar to Argument cannot have a null element..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.Arrays_with_more_than_one_dimension_cannot_be_serialized">
            <summary>
              Looks up a localized string similar to Arrays with more than one dimension cannot be serialized..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.Assembly">
            <summary>
              Looks up a localized string similar to assembly.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.AssemblyFileNotFound">
            <summary>
              Looks up a localized string similar to Assembly file not found.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.AssemblyMustHaveAtLeastOneModule">
            <summary>
              Looks up a localized string similar to Assembly must have at least one module..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.AssemblyReferencesNetFramework">
            <summary>
              Looks up a localized string similar to The assembly containing type &apos;{0}&apos; references .NET Framework, which is not supported..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.AssemblySigningNotSupported">
            <summary>
              Looks up a localized string similar to Assembly signing not supported..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.AsyncAnalyzerActionCannotBeRegistered">
            <summary>
              Looks up a localized string similar to Analyzer attempted to register an &apos;async&apos; action, which is not supported..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.Cannot_deserialize_type_0">
            <summary>
              Looks up a localized string similar to Cannot deserialize type &apos;{0}&apos;..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.Cannot_serialize_type_0">
            <summary>
              Looks up a localized string similar to Cannot serialize type &apos;{0}&apos;..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.CannotAliasModule">
            <summary>
              Looks up a localized string similar to Can&apos;t alias a module..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.CannotCreateReferenceToModule">
            <summary>
              Looks up a localized string similar to Can&apos;t create a reference to a module..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.CannotCreateReferenceToSubmission">
            <summary>
              Looks up a localized string similar to Can&apos;t create a reference to a submission..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.CannotEmbedInteropTypesFromModule">
            <summary>
              Looks up a localized string similar to Can&apos;t embed interop types from module..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.CannotTargetNetModuleWhenEmittingRefAssembly">
            <summary>
              Looks up a localized string similar to Cannot target net module when emitting ref assembly..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.CantCreateModuleReferenceToAssembly">
            <summary>
              Looks up a localized string similar to Can&apos;t create a module reference to an assembly..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.CantCreateReferenceToAssemblyWithoutLocation">
            <summary>
              Looks up a localized string similar to Can&apos;t create a metadata reference to an assembly without location..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.CantCreateReferenceToDynamicAssembly">
            <summary>
              Looks up a localized string similar to Can&apos;t create a metadata reference to a dynamic assembly..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.ChangesMustBeWithinBoundsOfSourceText">
            <summary>
              Looks up a localized string similar to Changes must be within bounds of SourceText.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.ChangesMustNotOverlap">
            <summary>
              Looks up a localized string similar to The changes must not overlap..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.ChangingVersionOfAssemblyReferenceIsNotAllowedDuringDebugging">
            <summary>
              Looks up a localized string similar to Changing the version of an assembly reference is not allowed during debugging: &apos;{0}&apos; changed version to &apos;{1}&apos;..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.Class1">
            <summary>
              Looks up a localized string similar to class.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.CoffResourceInvalidRelocation">
            <summary>
              Looks up a localized string similar to Win32 resources, assumed to be in COFF object format, have one or more invalid relocation header values..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.CoffResourceInvalidSectionSize">
            <summary>
              Looks up a localized string similar to Win32 resources, assumed to be in COFF object format, have an invalid section size..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.CoffResourceInvalidSymbol">
            <summary>
              Looks up a localized string similar to Win32 resources, assumed to be in COFF object format, have one or more invalid symbol values..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.CoffResourceMissingSection">
            <summary>
              Looks up a localized string similar to Win32 resources, assumed to be in COFF object format, are missing one or both of sections &apos;.rsrc$01&apos; and &apos;.rsrc$02&apos;.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.CompilationOptionsMustNotHaveErrors">
            <summary>
              Looks up a localized string similar to Compilation options must not have errors..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.CompilationReferencesAssembliesWithDifferentAutoGeneratedVersion">
            <summary>
              Looks up a localized string similar to The compilation references multiple assemblies whose versions only differ in auto-generated build and/or revision numbers..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.CompilerAnalyzerFailure">
            <summary>
              Looks up a localized string similar to Analyzer Failure.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.CompilerAnalyzerThrows">
             <summary>
               Looks up a localized string similar to Analyzer &apos;{0}&apos; threw an exception of type &apos;{1}&apos; with message &apos;{2}&apos;.
            {3}.
             </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.CompilerAnalyzerThrowsDescription">
             <summary>
               Looks up a localized string similar to Analyzer &apos;{0}&apos; threw the following exception:
            &apos;{1}&apos;..
             </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.Constructor">
            <summary>
              Looks up a localized string similar to constructor.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.Delegate1">
            <summary>
              Looks up a localized string similar to delegate.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.Deserialization_reader_for_0_read_incorrect_number_of_values">
            <summary>
              Looks up a localized string similar to Deserialization reader for &apos;{0}&apos; read incorrect number of values..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.DiagnosticIdCantBeNullOrWhitespace">
            <summary>
              Looks up a localized string similar to A DiagnosticDescriptor must have an Id that is neither null nor an empty string nor a string that only contains white space..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.DisableAnalyzerDiagnosticsMessage">
            <summary>
              Looks up a localized string similar to Suppress the following diagnostics to disable this analyzer: {0}.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.DuplicateAnalyzerInstances">
            <summary>
              Looks up a localized string similar to Argument contains duplicate analyzer instances..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.ElementIsExpected">
            <summary>
              Looks up a localized string similar to element is expected.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.EmbeddedTextsRequirePdb">
            <summary>
              Looks up a localized string similar to Embedded texts are only supported when emitting a PDB..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.EmbeddingPdbUnexpectedWhenEmittingMetadata">
            <summary>
              Looks up a localized string similar to Embedding PDB is not allowed when emitting metadata..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.EmptyKeyInPathMap">
            <summary>
              Looks up a localized string similar to A key in the pathMap is empty..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.EmptyOrInvalidFileName">
            <summary>
              Looks up a localized string similar to Empty or invalid file name.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.EmptyOrInvalidResourceName">
            <summary>
              Looks up a localized string similar to Empty or invalid resource name.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.EndMustNotBeLessThanStart">
            <summary>
              Looks up a localized string similar to &apos;end&apos; must not be less than &apos;start&apos;.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.Enum1">
            <summary>
              Looks up a localized string similar to enum.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.Event1">
            <summary>
              Looks up a localized string similar to event.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.ExceptionContext">
             <summary>
               Looks up a localized string similar to Exception occurred with following context:
            {0}.
             </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.ExceptionEnablingMulticoreJit">
            <summary>
              Looks up a localized string similar to Warning: Could not enable multicore JIT due to exception: {0}..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.ExpectedNonEmptyPublicKey">
            <summary>
              Looks up a localized string similar to Expected non-empty public key.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.FailedToResolveRuleSetName">
            <summary>
              Looks up a localized string similar to Could not locate the rule set file &apos;{0}&apos;..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.Field">
            <summary>
              Looks up a localized string similar to field.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.FileNotFound">
            <summary>
              Looks up a localized string similar to File not found..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.FileSizeExceedsMaximumAllowed">
            <summary>
              Looks up a localized string similar to File size exceeds maximum allowed size of a valid metadata file..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.GetMetadataMustReturnInstance">
            <summary>
              Looks up a localized string similar to {0}.GetMetadata() must return an instance of {1}..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.HintNameInvalidChar">
            <summary>
              Looks up a localized string similar to The hintName contains an invalid character &apos;{0}&apos; at position {1}..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.HintNameUniquePerGenerator">
            <summary>
              Looks up a localized string similar to The hintName of the added source file must be unique within a generator..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.IconStreamUnexpectedFormat">
            <summary>
              Looks up a localized string similar to Icon stream is not in the expected format..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.IncludingPrivateMembersUnexpectedWhenEmittingToMetadataPeStream">
            <summary>
              Looks up a localized string similar to Including private members should not be used when emitting to the secondary assembly output..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.InconsistentLanguageVersions">
            <summary>
              Looks up a localized string similar to Inconsistent language versions.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.InconsistentSyntaxTreeFeature">
            <summary>
              Looks up a localized string similar to Inconsistent syntax tree features.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.InMemoryAssembly">
            <summary>
              Looks up a localized string similar to &lt;in-memory assembly&gt;.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.InMemoryModule">
            <summary>
              Looks up a localized string similar to &lt;in-memory module&gt;.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.Interface1">
            <summary>
              Looks up a localized string similar to interface.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.InvalidAdditionalFile">
            <summary>
              Looks up a localized string similar to Additional file doesn&apos;t belong to the underlying &apos;CompilationWithAnalyzers&apos;..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.InvalidAlias">
            <summary>
              Looks up a localized string similar to Invalid alias..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.InvalidAssemblyName">
            <summary>
              Looks up a localized string similar to Invalid assembly name: &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.InvalidCharactersInAssemblyCultureName">
            <summary>
              Looks up a localized string similar to Invalid characters in assembly culture name.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.InvalidCharactersInAssemblyName">
            <summary>
              Looks up a localized string similar to Invalid characters in assembly name.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.InvalidCompilationOptions">
            <summary>
              Looks up a localized string similar to Invalid compilation options -- submission can&apos;t be signed..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.InvalidContentType">
            <summary>
              Looks up a localized string similar to Invalid content type.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.InvalidCultureName">
            <summary>
              Looks up a localized string similar to Invalid culture name: &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.InvalidDataAtOffset">
            <summary>
              Looks up a localized string similar to Invalid data at offset {0}: {1}{2}*{3}{4}.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.InvalidDiagnosticIdReported">
            <summary>
              Looks up a localized string similar to Reported diagnostic has an ID &apos;{0}&apos;, which is not a valid identifier..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.InvalidDiagnosticLocationReported">
            <summary>
              Looks up a localized string similar to Reported diagnostic &apos;{0}&apos; has a source location in file &apos;{1}&apos;, which is not part of the compilation being analyzed..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.InvalidDiagnosticSpanReported">
            <summary>
              Looks up a localized string similar to Reported diagnostic &apos;{0}&apos; has a source location &apos;{1}&apos; in file &apos;{2}&apos;, which is outside of the given file..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.InvalidDiagnosticSuppressionReported">
            <summary>
              Looks up a localized string similar to Suppressed diagnostic ID &apos;{0}&apos; does not match suppressable ID &apos;{1}&apos; for the given suppression descriptor..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.InvalidHash">
            <summary>
              Looks up a localized string similar to Invalid hash..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.InvalidModuleName">
            <summary>
              Looks up a localized string similar to Invalid module name specified in metadata module &apos;{0}&apos;: &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.InvalidNodeToTrack">
            <summary>
              Looks up a localized string similar to Node to track is not a descendant of the root..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.InvalidOperationBlockForAnalysisContext">
            <summary>
              Looks up a localized string similar to Given operation block does not belong to the current analysis context..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.InvalidOutputKindForSubmission">
            <summary>
              Looks up a localized string similar to Invalid output kind for submission. DynamicallyLinkedLibrary expected..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.InvalidPublicKey">
            <summary>
              Looks up a localized string similar to Invalid public key..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.InvalidPublicKeyToken">
            <summary>
              Looks up a localized string similar to Invalid public key token..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.InvalidRuleSetInclude">
            <summary>
              Looks up a localized string similar to An error occurred while loading the included rule set file {0} - {1}.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.InvalidSizeOfPublicKeyToken">
            <summary>
              Looks up a localized string similar to Invalid size of public key token..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.InvalidTree">
            <summary>
              Looks up a localized string similar to Syntax tree doesn&apos;t belong to the underlying &apos;Compilation&apos;..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.IsSymbolAccessibleBadWithin">
            <summary>
              Looks up a localized string similar to Parameter &apos;{0}&apos; must be an &apos;INamedTypeSymbol&apos; or an &apos;IAssemblySymbol&apos;..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.IsSymbolAccessibleWrongAssembly">
            <summary>
              Looks up a localized string similar to Parameter &apos;{0}&apos; must be a symbol from this compilation or some referenced assembly..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.KeepAliveIsNotAnInteger">
            <summary>
              Looks up a localized string similar to Argument to &apos;/keepalive&apos; option is not a 32-bit integer..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.KeepAliveIsTooSmall">
            <summary>
              Looks up a localized string similar to Arguments to &apos;/keepalive&apos; option below -1 are invalid..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.KeepAliveWithoutShared">
            <summary>
              Looks up a localized string similar to &apos;/keepalive&apos; option is only valid with &apos;/shared&apos; option..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.MetadataPeStreamUnexpectedWhenEmittingMetadataOnly">
            <summary>
              Looks up a localized string similar to Metadata PE stream should not be given when emitting metadata only..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.MetadataRefNotFoundToRemove1">
            <summary>
              Looks up a localized string similar to MetadataReference &apos;{0}&apos; not found to remove..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.Method">
            <summary>
              Looks up a localized string similar to method.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.MismatchedVersion">
            <summary>
              Looks up a localized string similar to Roslyn compiler server reports different protocol version than build task..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.MissingKeepAlive">
            <summary>
              Looks up a localized string similar to Missing argument for &apos;/keepalive&apos; option..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.MissingListItem">
            <summary>
              Looks up a localized string similar to The item specified is not the element of a list..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.Module">
            <summary>
              Looks up a localized string similar to module.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.ModuleCopyCannotBeUsedToCreateAssemblyMetadata">
            <summary>
              Looks up a localized string similar to Module copy can&apos;t be used to create an assembly metadata..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.ModuleHasInvalidAttributes">
            <summary>
              Looks up a localized string similar to Module has invalid attributes..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.MultithreadedAnalyzerExecutionNote">
            <summary>
              Looks up a localized string similar to NOTE: Elapsed time may be less than analyzer execution time because analyzers can run concurrently..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.MustIncludePrivateMembersUnlessRefAssembly">
            <summary>
              Looks up a localized string similar to Must include private members unless emitting a ref assembly..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.NameCannotBeEmpty">
            <summary>
              Looks up a localized string similar to Name cannot be empty..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.NameCannotBeNull">
            <summary>
              Looks up a localized string similar to Name cannot be null..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.NameCannotStartWithWhitespace">
            <summary>
              Looks up a localized string similar to Name cannot start with whitespace..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.NameContainsInvalidCharacter">
            <summary>
              Looks up a localized string similar to Name contains invalid characters..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.NoAnalyzersFound">
            <summary>
              Looks up a localized string similar to No analyzers found.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.NodeOrTokenOutOfSequence">
            <summary>
              Looks up a localized string similar to A node or token is out of sequence..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.NonReportedDiagnosticCannotBeSuppressed">
            <summary>
              Looks up a localized string similar to Non-reported diagnostic with ID &apos;{0}&apos; cannot be suppressed..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.NotARootOperation">
            <summary>
              Looks up a localized string similar to Given operation has a non-null parent..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.NullValueInPathMap">
            <summary>
              Looks up a localized string similar to A value in the pathMap is null..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.OperationHasNullSemanticModel">
            <summary>
              Looks up a localized string similar to Given operation has a null semantic model..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.OperationMustNotBeControlFlowGraphPart">
            <summary>
              Looks up a localized string similar to The provided operation must not be part of a Control Flow Graph..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.OutputKindNotSupported">
            <summary>
              Looks up a localized string similar to Output kind not supported..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.Parameter">
            <summary>
              Looks up a localized string similar to parameter.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.PathReturnedByResolveMetadataFileMustBeAbsolute">
            <summary>
              Looks up a localized string similar to Path returned by {0}.ResolveMetadataFile must be absolute: &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.PathReturnedByResolveStrongNameKeyFileMustBeAbsolute">
            <summary>
              Looks up a localized string similar to Path returned by {0}.ResolveStrongNameKeyFile must be absolute: &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.PdbStreamUnexpectedWhenEmbedding">
            <summary>
              Looks up a localized string similar to PDB stream should not be given when embedding PDB into the PE stream..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.PdbStreamUnexpectedWhenEmittingMetadataOnly">
            <summary>
              Looks up a localized string similar to PDB stream should not be given when emitting metadata only..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.PEImageDoesntContainManagedMetadata">
            <summary>
              Looks up a localized string similar to PE image doesn&apos;t contain managed metadata..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.PEImageNotAvailable">
            <summary>
              Looks up a localized string similar to PE image not available..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.PreviousSubmissionHasErrors">
            <summary>
              Looks up a localized string similar to Previous submission has errors..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.Property">
            <summary>
              Looks up a localized string similar to property, indexer.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.ReferenceOfTypeIsInvalid1">
            <summary>
              Looks up a localized string similar to Reference of type &apos;{0}&apos; is not valid for this compilation..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.ReferenceResolverShouldReturnReadableNonNullStream">
            <summary>
              Looks up a localized string similar to Reference resolver should return readable non-null stream..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.ResourceDataProviderShouldReturnNonNullStream">
            <summary>
              Looks up a localized string similar to Resource data provider should return non-null stream.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.ResourceStreamEndedUnexpectedly">
            <summary>
              Looks up a localized string similar to Resource stream ended at {0} bytes, expected {1} bytes..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.ResourceStreamProviderShouldReturnNonNullStream">
            <summary>
              Looks up a localized string similar to Resource stream provider should return non-null stream..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.Return1">
            <summary>
              Looks up a localized string similar to return.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.ReturnTypeCannotBeValuePointerbyRefOrOpen">
            <summary>
              Looks up a localized string similar to Return type can&apos;t be a value type, pointer, by-ref or open generic type.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.ReturnTypeCannotBeVoidByRefOrOpen">
            <summary>
              Looks up a localized string similar to Return type can&apos;t be void, by-ref or open generic type.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.RuleSetBadAttributeValue">
            <summary>
              Looks up a localized string similar to The attribute {0} has an invalid value of {1}..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.RuleSetHasDuplicateRules">
            <summary>
              Looks up a localized string similar to The rule set file has duplicate rules for &apos;{0}&apos; with differing actions &apos;{1}&apos; and &apos;{2}&apos;..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.RuleSetMissingAttribute">
            <summary>
              Looks up a localized string similar to The element {0} is missing an attribute named {1}..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.SeparatorIsExpected">
            <summary>
              Looks up a localized string similar to separator is expected.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.SharedArgumentMissing">
            <summary>
              Looks up a localized string similar to Value for argument &apos;/shared:&apos; must not be empty.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.Single_type_per_generator_0">
            <summary>
              Looks up a localized string similar to Only a single {0} can be registered per generator..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.SizeHasToBePositive">
            <summary>
              Looks up a localized string similar to Size has to be positive..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.SourceTextCannotBeEmbedded">
            <summary>
              Looks up a localized string similar to SourceText cannot be embedded. Provide encoding or canBeEmbedded=true at construction..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.SourceTextRequiresEncoding">
            <summary>
              Looks up a localized string similar to The provided SourceText must have an explicit encoding set..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.SpanDoesNotIncludeEndOfLine">
            <summary>
              Looks up a localized string similar to The span does not include the end of a line..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.SpanDoesNotIncludeStartOfLine">
            <summary>
              Looks up a localized string similar to The span does not include the start of a line..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.StartMustNotBeNegative">
            <summary>
              Looks up a localized string similar to &apos;start&apos; must not be negative.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.Stream_contains_invalid_data">
            <summary>
              Looks up a localized string similar to Stream contains invalid data.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.StreamIsTooLong">
            <summary>
              Looks up a localized string similar to Stream is too long..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.StreamMustSupportRead">
            <summary>
              Looks up a localized string similar to Stream must be readable..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.StreamMustSupportReadAndSeek">
            <summary>
              Looks up a localized string similar to Stream must support read and seek operations..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.StreamMustSupportWrite">
            <summary>
              Looks up a localized string similar to Stream must be writable..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.Struct1">
            <summary>
              Looks up a localized string similar to struct.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.SupportedDiagnosticsHasNullDescriptor">
            <summary>
              Looks up a localized string similar to Analyzer &apos;{0}&apos; contains a null descriptor in its &apos;SupportedDiagnostics&apos;..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.SupportedSuppressionsHasNullDescriptor">
            <summary>
              Looks up a localized string similar to Analyzer &apos;{0}&apos; contains a null descriptor in its &apos;SupportedSuppressions&apos;..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.SuppressionDiagnosticDescriptorMessage">
            <summary>
              Looks up a localized string similar to Diagnostic &apos;{0}: {1}&apos; was programmatically suppressed by a DiagnosticSuppressor with suppression ID &apos;{2}&apos; and justification &apos;{3}&apos;.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.SuppressionDiagnosticDescriptorTitle">
            <summary>
              Looks up a localized string similar to Programmatic suppression of an analyzer diagnostic.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.SuppressionIdCantBeNullOrWhitespace">
            <summary>
              Looks up a localized string similar to A SuppressionDescriptor must have an Id that is neither null nor an empty string nor a string that only contains white space..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.SymWriterDoesNotSupportSourceLink">
            <summary>
              Looks up a localized string similar to Windows PDB writer doesn&apos;t support SourceLink feature: &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.SymWriterNotDeterministic">
            <summary>
              Looks up a localized string similar to Windows PDB writer doesn&apos;t support deterministic compilation: &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.SymWriterOlderVersionThanRequired">
            <summary>
              Looks up a localized string similar to The version of Windows PDB writer is older than required: &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.The_type_0_is_not_understood_by_the_serialization_binder">
            <summary>
              Looks up a localized string similar to The type &apos;{0}&apos; is not understood by the serialization binder..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.TheStreamCannotBeReadFrom">
            <summary>
              Looks up a localized string similar to The stream cannot be read from..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.TheStreamCannotBeWrittenTo">
            <summary>
              Looks up a localized string similar to The stream cannot be written to..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.TupleElementLocationCountMismatch">
            <summary>
              Looks up a localized string similar to If tuple element locations are specified, the number of locations must match the cardinality of the tuple..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.TupleElementNameCountMismatch">
            <summary>
              Looks up a localized string similar to If tuple element names are specified, the number of element names must match the cardinality of the tuple..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.TupleElementNameEmpty">
            <summary>
              Looks up a localized string similar to Tuple element name cannot be an empty string..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.TupleElementNullableAnnotationCountMismatch">
            <summary>
              Looks up a localized string similar to If tuple element nullable annotations are specified, the number of annotations must match the cardinality of the tuple..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.TuplesNeedAtLeastTwoElements">
            <summary>
              Looks up a localized string similar to Tuples must have at least two elements..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.TupleUnderlyingTypeMustBeTupleCompatible">
            <summary>
              Looks up a localized string similar to The underlying type for a tuple must be tuple-compatible..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.TypeMustBeASubclassOfSyntaxAnnotation">
            <summary>
              Looks up a localized string similar to type must be a subclass of SyntaxAnnotation..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.TypeMustBeSameAsHostObjectTypeOfPreviousSubmission">
            <summary>
              Looks up a localized string similar to Type must be same as host object type of previous submission..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.TypeParameter">
            <summary>
              Looks up a localized string similar to type parameter.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.UnableToDetermineSpecificCauseOfFailure">
            <summary>
              Looks up a localized string similar to Unable to determine specific cause of the failure..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.UnexpectedTypeOfNodeInList">
            <summary>
              Looks up a localized string similar to A node in the list is not of the expected type..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.UnrecognizedResourceFileFormat">
            <summary>
              Looks up a localized string similar to Unrecognized resource file format..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.Unresolved">
            <summary>
              Looks up a localized string similar to Unresolved: .
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.UnsupportedAnalyzerInstance">
            <summary>
              Looks up a localized string similar to Argument contains an analyzer instance that does not belong to the &apos;Analyzers&apos; for this CompilationWithAnalyzers instance..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.UnsupportedDiagnosticReported">
            <summary>
              Looks up a localized string similar to Reported diagnostic with ID &apos;{0}&apos; is not supported by the analyzer..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.UnsupportedHashAlgorithm">
            <summary>
              Looks up a localized string similar to Unsupported hash algorithm..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.UnsupportedSuppressionReported">
            <summary>
              Looks up a localized string similar to Reported suppression with ID &apos;{0}&apos; is not supported by the suppressor..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.Value_too_large_to_be_represented_as_a_30_bit_unsigned_integer">
            <summary>
              Looks up a localized string similar to Value too large to be represented as a 30 bit unsigned integer..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.WinRTIdentityCantBeRetargetable">
            <summary>
              Looks up a localized string similar to WindowsRuntime identity can&apos;t be retargetable.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.WRN_InvalidGlobalSectionName">
            <summary>
              Looks up a localized string similar to Global analyzer config section name &apos;{0}&apos; is invalid as it is not an absolute path. Section will be ignored. Section was declared in file: &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.WRN_InvalidGlobalSectionName_Title">
            <summary>
              Looks up a localized string similar to Global analyzer config section name is invalid as it is not an absolute path. Section will be ignored..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.WRN_InvalidSeverityInAnalyzerConfig">
            <summary>
              Looks up a localized string similar to The diagnostic &apos;{0}&apos; was given an invalid severity &apos;{1}&apos; in the analyzer config file at &apos;{2}&apos;..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.WRN_InvalidSeverityInAnalyzerConfig_Title">
            <summary>
              Looks up a localized string similar to Invalid severity in analyzer config file..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.WRN_MultipleGlobalAnalyzerKeys">
            <summary>
              Looks up a localized string similar to Multiple global analyzer config files set the same key &apos;{0}&apos; in section &apos;{1}&apos;. It has been unset. Key was set by the following files: &apos;{2}&apos;.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.WRN_MultipleGlobalAnalyzerKeys_Title">
            <summary>
              Looks up a localized string similar to Multiple global analyzer config files set the same key. It has been unset..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CodeAnalysisResources.XmlReferencesNotSupported">
            <summary>
              Looks up a localized string similar to References to XML documents are not supported..
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.ArrayBuilderExtensions.SelectAsArray``2(Loretta.CodeAnalysis.PooledObjects.ArrayBuilder{``0},System.Func{``0,``1})">
            <summary>
            Maps an array builder to immutable array.
            </summary>
            <typeparam name="TItem"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="items">The array to map</param>
            <param name="map">The mapping delegate</param>
            <returns>If the items's length is 0, this will return an empty immutable array</returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.ArrayBuilderExtensions.SelectAsArray``3(Loretta.CodeAnalysis.PooledObjects.ArrayBuilder{``0},System.Func{``0,``1,``2},``1)">
            <summary>
            Maps an array builder to immutable array.
            </summary>
            <typeparam name="TItem"></typeparam>
            <typeparam name="TArg"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="items">The sequence to map</param>
            <param name="map">The mapping delegate</param>
            <param name="arg">The extra input used by mapping delegate</param>
            <returns>If the items's length is 0, this will return an empty immutable array.</returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.BitVector.Create(System.Int32)">
            <summary>
            Create BitArray with at least the specified number of bits.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.BitVector.AllSet(System.Int32)">
            <summary>
            return a bit array with all bits set from index 0 through bitCount-1
            </summary>
            <param name="capacity"></param>
            <returns></returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.BitVector.Clone">
            <summary>
            Make a copy of a bit array.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.BitVector.Invert">
            <summary>
            Invert all the bits in the vector.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.BitVector.IsNull">
            <summary>
            Is the given bit array null?
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.BitVector.IntersectWith(Loretta.CodeAnalysis.BitVector@)">
            <summary>
            Modify this bit vector by bitwise AND-ing each element with the other bit vector.
            For the purposes of the intersection, any bits beyond the current length will be treated as zeroes.
            Return true if any changes were made to the bits of this bit vector.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.BitVector.UnionWith(Loretta.CodeAnalysis.BitVector@)">
            <summary>
            Modify this bit vector by '|'ing each element with the other bit vector.
            </summary>
            <returns>
            True if any bits were set as a result of the union.
            </returns>
        </member>
        <member name="T:Loretta.CodeAnalysis.DictionaryExtensions">
            <summary>
            The collection of extension methods for the <see cref="T:System.Collections.Generic.Dictionary`2"/> type
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.DictionaryExtensions.GetOrAdd``2(System.Collections.Generic.Dictionary{``0,``1},``0,``1)">
            <summary>
            If the given key is not found in the dictionary, add it with the given value and return the value.
            Otherwise return the existing value associated with that key.
            </summary>
        </member>
        <member name="T:Loretta.CodeAnalysis.IdentifierCollection">
            <summary>
            A dictionary that maps strings to all known spellings of that string. Can be used to
            efficiently store the set of known type names for a module for both VB and C# while also
            answering questions like "do you have a type called Goo" in either a case sensitive or
            insensitive manner.
            </summary>
        </member>
        <member name="T:Loretta.CodeAnalysis.ImmutableArrayExtensions">
            <summary>
            The collection of extension methods for the <see cref="T:System.Collections.Immutable.ImmutableArray`1"/> type
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.ImmutableArrayExtensions.AsImmutable``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Converts a sequence to an immutable array.
            </summary>
            <typeparam name="T">Elemental type of the sequence.</typeparam>
            <param name="items">The sequence to convert.</param>
            <returns>An immutable copy of the contents of the sequence.</returns>
            <exception cref="T:System.ArgumentNullException">If items is null (default)</exception>
            <remarks>If the sequence is null, this will throw <see cref="T:System.ArgumentNullException"/></remarks>
        </member>
        <member name="M:Loretta.CodeAnalysis.ImmutableArrayExtensions.AsImmutableOrEmpty``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Converts a sequence to an immutable array.
            </summary>
            <typeparam name="T">Elemental type of the sequence.</typeparam>
            <param name="items">The sequence to convert.</param>
            <returns>An immutable copy of the contents of the sequence.</returns>
            <remarks>If the sequence is null, this will return an empty array.</remarks>
        </member>
        <member name="M:Loretta.CodeAnalysis.ImmutableArrayExtensions.AsImmutableOrNull``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Converts a sequence to an immutable array.
            </summary>
            <typeparam name="T">Elemental type of the sequence.</typeparam>
            <param name="items">The sequence to convert.</param>
            <returns>An immutable copy of the contents of the sequence.</returns>
            <remarks>If the sequence is null, this will return the default (null) array.</remarks>
        </member>
        <member name="M:Loretta.CodeAnalysis.ImmutableArrayExtensions.AsImmutable``1(``0[])">
            <summary>
            Converts an array to an immutable array. The array must not be null.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="items">The sequence to convert</param>
            <returns></returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.ImmutableArrayExtensions.AsImmutableOrNull``1(``0[])">
            <summary>
            Converts a array to an immutable array.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="items">The sequence to convert</param>
            <returns></returns>
            <remarks>If the sequence is null, this will return the default (null) array.</remarks>
        </member>
        <member name="M:Loretta.CodeAnalysis.ImmutableArrayExtensions.AsImmutableOrEmpty``1(``0[])">
            <summary>
            Converts an array to an immutable array.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="items">The sequence to convert</param>
            <returns>If the array is null, this will return an empty immutable array.</returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.ImmutableArrayExtensions.ToImmutable(System.IO.MemoryStream)">
            <summary>
            Reads bytes from specified <see cref="T:System.IO.MemoryStream"/>.
            </summary>
            <param name="stream">The stream.</param>
            <returns>Read-only content of the stream.</returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.ImmutableArrayExtensions.SelectAsArray``2(System.Collections.Immutable.ImmutableArray{``0},System.Func{``0,``1})">
            <summary>
            Maps an immutable array to another immutable array.
            </summary>
            <typeparam name="TItem"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="items">The array to map</param>
            <param name="map">The mapping delegate</param>
            <returns>If the items's length is 0, this will return an empty immutable array</returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.ImmutableArrayExtensions.SelectAsArray``3(System.Collections.Immutable.ImmutableArray{``0},System.Func{``0,``1,``2},``1)">
            <summary>
            Maps an immutable array to another immutable array.
            </summary>
            <typeparam name="TItem"></typeparam>
            <typeparam name="TArg"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="items">The sequence to map</param>
            <param name="map">The mapping delegate</param>
            <param name="arg">The extra input used by mapping delegate</param>
            <returns>If the items's length is 0, this will return an empty immutable array.</returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.ImmutableArrayExtensions.SelectAsArray``3(System.Collections.Immutable.ImmutableArray{``0},System.Func{``0,System.Int32,``1,``2},``1)">
            <summary>
             Maps an immutable array to another immutable array.
            </summary>
            <typeparam name="TItem"></typeparam>
            <typeparam name="TArg"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="items">The sequence to map</param>
            <param name="map">The mapping delegate</param>
            <param name="arg">The extra input used by mapping delegate</param>
            <returns>If the items's length is 0, this will return an empty immutable array.</returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.ImmutableArrayExtensions.SelectAsArray``2(System.Collections.Immutable.ImmutableArray{``0},System.Func{``0,System.Boolean},System.Func{``0,``1})">
            <summary>
            Maps a subset of immutable array to another immutable array.
            </summary>
            <typeparam name="TItem">Type of the source array items</typeparam>
            <typeparam name="TResult">Type of the transformed array items</typeparam>
            <param name="array">The array to transform</param>
            <param name="predicate">The condition to use for filtering the array content.</param>
            <param name="selector">A transform function to apply to each element that is not filtered out by <paramref name="predicate"/>.</param>
            <returns>If the items's length is 0, this will return an empty immutable array.</returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.ImmutableArrayExtensions.SelectAsArrayAsync``2(System.Collections.Immutable.ImmutableArray{``0},System.Func{``0,System.Threading.CancellationToken,System.Threading.Tasks.ValueTask{``1}},System.Threading.CancellationToken)">
            <summary>
            Maps an immutable array through a function that returns ValueTasks, returning the new ImmutableArray.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.ImmutableArrayExtensions.ZipAsArray``3(System.Collections.Immutable.ImmutableArray{``0},System.Collections.Immutable.ImmutableArray{``1},System.Func{``0,``1,``2})">
            <summary>
            Zips two immutable arrays together through a mapping function, producing another immutable array.
            </summary>
            <returns>If the items's length is 0, this will return an empty immutable array.</returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.ImmutableArrayExtensions.WhereAsArray``1(System.Collections.Immutable.ImmutableArray{``0},System.Func{``0,System.Boolean})">
            <summary>
            Creates a new immutable array based on filtered elements by the predicate. The array must not be null.
            </summary>
            <param name="array">The array to process</param>
            <param name="predicate">The delegate that defines the conditions of the element to search for.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.ImmutableArrayExtensions.WhereAsArray``2(System.Collections.Immutable.ImmutableArray{``0},System.Func{``0,``1,System.Boolean},``1)">
            <summary>
            Creates a new immutable array based on filtered elements by the predicate. The array must not be null.
            </summary>
            <param name="array">
            The array to process
            </param>
            <param name="predicate">
            The delegate that defines the conditions of the element to search for.
            </param>
            <param name="arg">
            The extra argument that will be passed on to the filter delegate.
            </param>
        </member>
        <member name="M:Loretta.CodeAnalysis.ImmutableArrayExtensions.Cast``2(System.Collections.Immutable.ImmutableArray{``0})">
            <summary>
            Casts the immutable array of a Type to an immutable array of its base type.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.ImmutableArrayExtensions.SetEquals``1(System.Collections.Immutable.ImmutableArray{``0},System.Collections.Immutable.ImmutableArray{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Determines whether this instance and another immutable array are equal.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="array1"></param>
            <param name="array2"></param>
            <param name="comparer">The comparer to determine if the two arrays are equal.</param>
            <returns>True if the two arrays are equal</returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.ImmutableArrayExtensions.NullToEmpty``1(System.Collections.Immutable.ImmutableArray{``0})">
            <summary>
            Returns an empty array if the input array is null (default)
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.ImmutableArrayExtensions.Distinct``1(System.Collections.Immutable.ImmutableArray{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Returns an array of distinct elements, preserving the order in the original array.
            If the array has no duplicates, the original array is returned. The original array must not be null.
            </summary>
        </member>
        <member name="T:Loretta.CodeAnalysis.Collections.ImmutableSegmentedDictionary">
            <summary>
            Provides methods for creating a segmented dictionary that is immutable; meaning it cannot be changed once it is
            created.
            </summary>
        </member>
        <member name="T:Loretta.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2">
             <summary>
             Represents a segmented dictionary that is immutable; meaning it cannot be changed once it is created.
             </summary>
             <remarks>
             <para>There are different scenarios best for <see cref="T:Loretta.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2"/> and others
             best for <see cref="T:System.Collections.Immutable.ImmutableDictionary`2"/>.</para>
            
             <para>In general, <see cref="T:Loretta.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2"/> is applicable in scenarios most like
             the scenarios where <see cref="T:System.Collections.Immutable.ImmutableArray`1"/> is applicable, and
             <see cref="T:System.Collections.Immutable.ImmutableDictionary`2"/> is applicable in scenarios most like the scenarios where
             <see cref="T:System.Collections.Immutable.ImmutableList`1"/> is applicable.</para>
            
             <para>The following table summarizes the performance characteristics of
             <see cref="T:Loretta.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2"/>:</para>
             
             <list type="table">
               <item>
                 <description>Operation</description>
                 <description><see cref="T:Loretta.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2"/> Complexity</description>
                 <description><see cref="T:System.Collections.Immutable.ImmutableDictionary`2"/> Complexity</description>
                 <description>Comments</description>
               </item>
               <item>
                 <description>Item</description>
                 <description>O(1)</description>
                 <description>O(log n)</description>
                 <description>Directly index into the underlying segmented dictionary</description>
               </item>
               <item>
                 <description>Add()</description>
                 <description>O(n)</description>
                 <description>O(log n)</description>
                 <description>Requires creating a new segmented dictionary</description>
               </item>
             </list>
             
             <para>This type is backed by segmented arrays to avoid using the Large Object Heap without impacting algorithmic
             complexity.</para>
             </remarks>
             <typeparam name="TKey">The type of the keys in the dictionary.</typeparam>
             <typeparam name="TValue">The type of the values in the dictionary.</typeparam>
             <devremarks>
             <para>This type has a documented contract of being exactly one reference-type field in size. Our own
             <see cref="T:Loretta.CodeAnalysis.Collections.RoslynImmutableInterlocked"/> class depends on it, as well as others externally.</para>
            
             <para><strong>IMPORTANT NOTICE FOR MAINTAINERS AND REVIEWERS:</strong></para>
            
             <para>This type should be thread-safe. As a struct, it cannot protect its own fields from being changed from one
             thread while its members are executing on other threads because structs can change <em>in place</em> simply by
             reassigning the field containing this struct. Therefore it is extremely important that <strong> Every member
             should only dereference <c>this</c> ONCE </strong>. If a member needs to reference the
             <see cref="F:Loretta.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2._dictionary"/> field, that counts as a dereference of <c>this</c>. Calling other instance members
             (properties or methods) also counts as dereferencing <c>this</c>. Any member that needs to use <c>this</c> more
             than once must instead assign <c>this</c> to a local variable and use that for the rest of the code instead.
             This effectively copies the one field in the struct to a local variable so that it is insulated from other
             threads.</para>
             </devremarks>
        </member>
        <member name="F:Loretta.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2.Builder._dictionary">
            <summary>
            The immutable collection this builder is based on.
            </summary>
        </member>
        <member name="F:Loretta.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2.Builder._mutableDictionary">
            <summary>
            The current mutable collection this builder is operating on. This field is initialized to a copy of
            <see cref="F:Loretta.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2.Builder._dictionary"/> the first time a change is made.
            </summary>
        </member>
        <member name="F:Loretta.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2.Enumerator.ReturnType.KeyValuePair">
            <summary>
            The return value from the implementation of <see cref="M:System.Collections.IEnumerable.GetEnumerator"/> is
            <see cref="T:System.Collections.Generic.KeyValuePair`2"/>. This is the return value for most instances of this
            enumerator.
            </summary>
        </member>
        <member name="F:Loretta.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2.Enumerator.ReturnType.DictionaryEntry">
            <summary>
            The return value from the implementation of <see cref="M:System.Collections.IEnumerable.GetEnumerator"/> is
            <see cref="T:System.Collections.DictionaryEntry"/>. This is the return value for instances of this
            enumerator created by the <see cref="M:System.Collections.IDictionary.GetEnumerator"/> implementation in
            <see cref="T:Loretta.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2"/>.
            </summary>
        </member>
        <member name="T:Loretta.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2.PrivateInterlocked">
            <summary>
            Private helper class for use only by <see cref="T:Loretta.CodeAnalysis.Collections.RoslynImmutableInterlocked"/>.
            </summary>
        </member>
        <member name="T:Loretta.CodeAnalysis.Collections.Internal.SegmentedArraySortUtils">
            <summary>Helper methods for use in array/span sorting routines.</summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.Collections.Internal.SegmentedArraySortUtils.Log2SoftwareFallback(System.UInt32)">
            <summary>
            Returns the integer (floor) log of the specified value, base 2.
            Note that by convention, input value 0 returns 0 since Log(0) is undefined.
            Does not directly use any hardware intrinsics, nor does it incur branching.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.Collections.Internal.HashHelpers.GetFastModMultiplier(System.UInt32)">
            <summary>Returns approximate reciprocal of the divisor: ceil(2**64 / divisor).</summary>
            <remarks>This should only be used on 64-bit.</remarks>
        </member>
        <member name="M:Loretta.CodeAnalysis.Collections.Internal.HashHelpers.FastMod(System.UInt32,System.UInt32,System.UInt64)">
            <summary>Performs a mod operation using the multiplier pre-computed with <see cref="M:Loretta.CodeAnalysis.Collections.Internal.HashHelpers.GetFastModMultiplier(System.UInt32)"/>.</summary>
            <remarks>
            PERF: This improves performance in 64-bit scenarios at the expense of performance in 32-bit scenarios. Since
            we only build a single AnyCPU binary, we opt for improved performance in the 64-bit scenario.
            </remarks>
        </member>
        <member name="T:Loretta.CodeAnalysis.Collections.Internal.InsertionBehavior">
            <summary>
            Used internally to control behavior of insertion into a <see cref="T:System.Collections.Generic.Dictionary`2"/> or <see cref="T:System.Collections.Generic.HashSet`1"/>.
            </summary>
        </member>
        <member name="F:Loretta.CodeAnalysis.Collections.Internal.InsertionBehavior.None">
            <summary>
            The default insertion behavior.
            </summary>
        </member>
        <member name="F:Loretta.CodeAnalysis.Collections.Internal.InsertionBehavior.OverwriteExisting">
            <summary>
            Specifies that an existing entry with the same key should be overwritten if encountered.
            </summary>
        </member>
        <member name="F:Loretta.CodeAnalysis.Collections.Internal.InsertionBehavior.ThrowOnExisting">
            <summary>
            Specifies that if an existing entry with the same key is encountered, an exception should be thrown.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.Collections.Internal.RoslynUnsafe.NullRef``1">
            <summary>
            Returns a by-ref to type <typeparamref name="T"/> that is a null reference.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.Collections.Internal.RoslynUnsafe.IsNullRef``1(``0@)">
            <summary>
            Returns if a given by-ref to type <typeparamref name="T"/> is a null reference.
            </summary>
            <remarks>
            This check is conceptually similar to <c>(void*)(&amp;source) == nullptr</c>.
            </remarks>
        </member>
        <member name="M:Loretta.CodeAnalysis.Collections.Internal.SegmentedArrayHelper.CalculateSegmentSize(System.Int32)">
            <summary>
            Calculates the maximum number of elements of size <paramref name="elementSize"/> which can fit into an array
            which has the following characteristics:
            <list type="bullet">
            <item><description>The array can be allocated in the small object heap.</description></item>
            <item><description>The array length is a power of 2.</description></item>
            </list>
            </summary>
            <param name="elementSize">The size of the elements in the array.</param>
            <returns>The segment size to use for small object heap segmented arrays.</returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.Collections.Internal.SegmentedArrayHelper.CalculateSegmentShift(System.Int32)">
            <summary>
            Calculates a shift which can be applied to an absolute index to get the page index within a segmented array.
            </summary>
            <param name="segmentSize">The number of elements in each page of the segmented array. Must be a power of 2.</param>
            <returns>The shift to apply to the absolute index to get the page index within a segmented array.</returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.Collections.Internal.SegmentedArrayHelper.CalculateOffsetMask(System.Int32)">
            <summary>
            Calculates a mask, which can be applied to an absolute index to get the index within a page of a segmented
            array.
            </summary>
            <param name="segmentSize">The number of elements in each page of the segmented array. Must be a power of 2.</param>
            <returns>The bit mask to obtain the index within a page from an absolute index within a segmented array.</returns>
        </member>
        <member name="T:Loretta.CodeAnalysis.Collections.Internal.SR">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.Collections.Internal.SR.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.Collections.Internal.SR.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.Collections.Internal.SR.Arg_ArrayPlusOffTooSmall">
            <summary>
              Looks up a localized string similar to Destination array is not long enough to copy all the items in the collection. Check array index and length..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.Collections.Internal.SR.Arg_BogusIComparer">
            <summary>
              Looks up a localized string similar to Unable to sort because the IComparer.Compare() method returns inconsistent results. Either a value does not compare equal to itself, or one value repeatedly compared to another value yields different results. IComparer: &apos;{0}&apos;..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.Collections.Internal.SR.Arg_HTCapacityOverflow">
            <summary>
              Looks up a localized string similar to Hashtable&apos;s capacity overflowed and went negative. Check load factor, capacity and the current size of the table..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.Collections.Internal.SR.Arg_KeyNotFoundWithKey">
            <summary>
              Looks up a localized string similar to The given key &apos;{0}&apos; was not present in the dictionary..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.Collections.Internal.SR.Arg_LongerThanDestArray">
            <summary>
              Looks up a localized string similar to Destination array was not long enough. Check the destination index, length, and the array&apos;s lower bounds..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.Collections.Internal.SR.Arg_LongerThanSrcArray">
            <summary>
              Looks up a localized string similar to Source array was not long enough. Check the source index, length, and the array&apos;s lower bounds..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.Collections.Internal.SR.Arg_NonZeroLowerBound">
            <summary>
              Looks up a localized string similar to The lower bound of target array must be zero..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.Collections.Internal.SR.Arg_RankMultiDimNotSupported">
            <summary>
              Looks up a localized string similar to Only single dimensional arrays are supported for the requested action..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.Collections.Internal.SR.Arg_WrongType">
            <summary>
              Looks up a localized string similar to The value &quot;{0}&quot; is not of type &quot;{1}&quot; and cannot be used in this generic collection..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.Collections.Internal.SR.Argument_AddingDuplicateWithKey">
            <summary>
              Looks up a localized string similar to An item with the same key has already been added. Key: {0}.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.Collections.Internal.SR.Argument_InvalidArrayType">
            <summary>
              Looks up a localized string similar to Target array type is not compatible with the type of items in the collection..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.Collections.Internal.SR.Argument_InvalidOffLen">
            <summary>
              Looks up a localized string similar to Offset and length were out of bounds for the array or count is greater than the number of elements from index to the end of the source collection..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.Collections.Internal.SR.ArgumentException_OtherNotArrayOfCorrectLength">
            <summary>
              Looks up a localized string similar to Object is not a array with the same number of elements as the array to compare it to..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.Collections.Internal.SR.ArgumentOutOfRange_ArrayLB">
            <summary>
              Looks up a localized string similar to Number was less than the array&apos;s lower bound in the first dimension..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.Collections.Internal.SR.ArgumentOutOfRange_BiggerThanCollection">
            <summary>
              Looks up a localized string similar to Larger than collection size..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.Collections.Internal.SR.ArgumentOutOfRange_Count">
            <summary>
              Looks up a localized string similar to Count must be positive and count must refer to a location within the string/array/collection..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.Collections.Internal.SR.ArgumentOutOfRange_Index">
            <summary>
              Looks up a localized string similar to Index was out of range. Must be non-negative and less than the size of the collection..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.Collections.Internal.SR.ArgumentOutOfRange_ListInsert">
            <summary>
              Looks up a localized string similar to Index must be within the bounds of the List..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.Collections.Internal.SR.ArgumentOutOfRange_NeedNonNegNum">
            <summary>
              Looks up a localized string similar to Non-negative number required..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.Collections.Internal.SR.ArgumentOutOfRange_SmallCapacity">
            <summary>
              Looks up a localized string similar to capacity was less than the current size..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.Collections.Internal.SR.InvalidOperation_ConcurrentOperationsNotSupported">
            <summary>
              Looks up a localized string similar to Operations that change non-concurrent collections must have exclusive access. A concurrent update was performed on this collection and corrupted its state. The collection&apos;s state is no longer correct..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.Collections.Internal.SR.InvalidOperation_EnumFailedVersion">
            <summary>
              Looks up a localized string similar to Collection was modified; enumeration operation may not execute..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.Collections.Internal.SR.InvalidOperation_EnumOpCantHappen">
            <summary>
              Looks up a localized string similar to Enumeration has either not started or has already finished..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.Collections.Internal.SR.InvalidOperation_IComparerFailed">
            <summary>
              Looks up a localized string similar to Failed to compare two elements in the array..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.Collections.Internal.SR.NotSupported_FixedSizeCollection">
            <summary>
              Looks up a localized string similar to Collection was of a fixed size..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.Collections.Internal.SR.NotSupported_KeyCollectionSet">
            <summary>
              Looks up a localized string similar to Mutating a key collection derived from a dictionary is not allowed..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.Collections.Internal.SR.NotSupported_ValueCollectionSet">
            <summary>
              Looks up a localized string similar to Mutating a value collection derived from a dictionary is not allowed..
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.Collections.Internal.SR.Rank_MustMatch">
            <summary>
              Looks up a localized string similar to The specified arrays must have the same number of dimensions..
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.Collections.RoslynImmutableInterlocked.Update``2(Loretta.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1}@,System.Func{Loretta.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1},Loretta.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1}})">
            <summary>
            Mutates a value in-place with optimistic locking transaction semantics via a specified transformation
            function. The transformation is retried as many times as necessary to win the optimistic locking race.
            </summary>
            <typeparam name="TKey">The type of key stored by the dictionary.</typeparam>
            <typeparam name="TValue">The type of value stored by the dictionary.</typeparam>
            <param name="location">
            The variable or field to be changed, which may be accessed by multiple threads.
            </param>
            <param name="transformer">
            A function that mutates the value. This function should be side-effect free,
            as it may run multiple times when races occur with other threads.</param>
            <returns>
            <see langword="true"/> if the location's value is changed by applying the result of the
            <paramref name="transformer"/> function; otherwise, <see langword="false"/> if the location's value remained
            the same because the last invocation of <paramref name="transformer"/> returned the existing value.
            </returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.Collections.RoslynImmutableInterlocked.Update``3(Loretta.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1}@,System.Func{Loretta.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1},``2,Loretta.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1}},``2)">
            <summary>
            Mutates a value in-place with optimistic locking transaction semantics via a specified transformation
            function. The transformation is retried as many times as necessary to win the optimistic locking race.
            </summary>
            <typeparam name="TKey">The type of key stored by the dictionary.</typeparam>
            <typeparam name="TValue">The type of value stored by the dictionary.</typeparam>
            <typeparam name="TArg">The type of argument passed to the <paramref name="transformer"/>.</typeparam>
            <param name="location">
            The variable or field to be changed, which may be accessed by multiple threads.
            </param>
            <param name="transformer">
            A function that mutates the value. This function should be side-effect free, as it may run multiple times
            when races occur with other threads.</param>
            <param name="transformerArgument">The argument to pass to <paramref name="transformer"/>.</param>
            <returns>
            <see langword="true"/> if the location's value is changed by applying the result of the
            <paramref name="transformer"/> function; otherwise, <see langword="false"/> if the location's value remained
            the same because the last invocation of <paramref name="transformer"/> returned the existing value.
            </returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.Collections.RoslynImmutableInterlocked.InterlockedExchange``2(Loretta.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1}@,Loretta.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1})">
            <summary>
            Assigns a field or variable containing an immutable dictionary to the specified value and returns the
            previous value.
            </summary>
            <typeparam name="TKey">The type of key stored by the dictionary.</typeparam>
            <typeparam name="TValue">The type of value stored by the dictionary.</typeparam>
            <param name="location">The field or local variable to change.</param>
            <param name="value">The new value to assign.</param>
            <returns>The prior value at the specified <paramref name="location"/>.</returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.Collections.RoslynImmutableInterlocked.InterlockedCompareExchange``2(Loretta.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1}@,Loretta.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1},Loretta.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1})">
            <summary>
            Assigns a field or variable containing an immutable dictionary to the specified value if it is currently
            equal to another specified value. Returns the previous value.
            </summary>
            <typeparam name="TKey">The type of key stored by the dictionary.</typeparam>
            <typeparam name="TValue">The type of value stored by the dictionary.</typeparam>
            <param name="location">The field or local variable to change.</param>
            <param name="value">The new value to assign.</param>
            <param name="comparand">The value to check equality for before assigning.</param>
            <returns>The prior value at the specified <paramref name="location"/>.</returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.Collections.RoslynImmutableInterlocked.InterlockedInitialize``2(Loretta.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1}@,Loretta.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1})">
            <summary>
            Assigns a field or variable containing an immutable dictionary to the specified value if it is has not yet
            been initialized.
            </summary>
            <typeparam name="TKey">The type of key stored by the dictionary.</typeparam>
            <typeparam name="TValue">The type of value stored by the dictionary.</typeparam>
            <param name="location">The field or local variable to change.</param>
            <param name="value">The new value to assign.</param>
            <returns><see langword="true"/> if the field was assigned the specified value; otherwise,
            <see langword="false"/> if it was previously initialized.</returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.Collections.RoslynImmutableInterlocked.GetOrAdd``3(Loretta.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1}@,``0,System.Func{``0,``2,``1},``2)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableInterlocked.GetOrAdd``3(System.Collections.Immutable.ImmutableDictionary{``0,``1}@,``0,System.Func{``0,``2,``1},``2)"/>
        </member>
        <member name="M:Loretta.CodeAnalysis.Collections.RoslynImmutableInterlocked.GetOrAdd``2(Loretta.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1}@,``0,System.Func{``0,``1})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableInterlocked.GetOrAdd``2(System.Collections.Immutable.ImmutableDictionary{``0,``1}@,``0,System.Func{``0,``1})"/>
        </member>
        <member name="M:Loretta.CodeAnalysis.Collections.RoslynImmutableInterlocked.GetOrAdd``2(Loretta.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1}@,``0,``1)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableInterlocked.GetOrAdd``2(System.Collections.Immutable.ImmutableDictionary{``0,``1}@,``0,``1)"/>
        </member>
        <member name="M:Loretta.CodeAnalysis.Collections.RoslynImmutableInterlocked.AddOrUpdate``2(Loretta.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1}@,``0,System.Func{``0,``1},System.Func{``0,``1,``1})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableInterlocked.AddOrUpdate``2(System.Collections.Immutable.ImmutableDictionary{``0,``1}@,``0,System.Func{``0,``1},System.Func{``0,``1,``1})"/>
        </member>
        <member name="M:Loretta.CodeAnalysis.Collections.RoslynImmutableInterlocked.AddOrUpdate``2(Loretta.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1}@,``0,``1,System.Func{``0,``1,``1})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableInterlocked.AddOrUpdate``2(System.Collections.Immutable.ImmutableDictionary{``0,``1}@,``0,``1,System.Func{``0,``1,``1})"/>
        </member>
        <member name="M:Loretta.CodeAnalysis.Collections.RoslynImmutableInterlocked.TryAdd``2(Loretta.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1}@,``0,``1)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableInterlocked.TryAdd``2(System.Collections.Immutable.ImmutableDictionary{``0,``1}@,``0,``1)"/>
        </member>
        <member name="M:Loretta.CodeAnalysis.Collections.RoslynImmutableInterlocked.TryUpdate``2(Loretta.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1}@,``0,``1,``1)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableInterlocked.TryUpdate``2(System.Collections.Immutable.ImmutableDictionary{``0,``1}@,``0,``1,``1)"/>
        </member>
        <member name="M:Loretta.CodeAnalysis.Collections.RoslynImmutableInterlocked.TryRemove``2(Loretta.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1}@,``0,``1@)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableInterlocked.TryRemove``2(System.Collections.Immutable.ImmutableDictionary{``0,``1}@,``0,``1@)"/>
        </member>
        <member name="M:Loretta.CodeAnalysis.Collections.SegmentedArray.Clear``1(Loretta.CodeAnalysis.Collections.SegmentedArray{``0},System.Int32,System.Int32)">
            <seealso cref="M:System.Array.Clear(System.Array,System.Int32,System.Int32)"/>
        </member>
        <member name="M:Loretta.CodeAnalysis.Collections.SegmentedArray.Copy``1(Loretta.CodeAnalysis.Collections.SegmentedArray{``0},Loretta.CodeAnalysis.Collections.SegmentedArray{``0},System.Int32)">
            <seealso cref="M:System.Array.Copy(System.Array,System.Array,System.Int32)"/>
        </member>
        <member name="T:Loretta.CodeAnalysis.Collections.SegmentedArray`1">
            <summary>
            Defines a fixed-size collection with the same API surface and behavior as an "SZArray", which is a
            single-dimensional zero-based array commonly represented in C# as <c>T[]</c>. The implementation of this
            collection uses segmented arrays to avoid placing objects on the Large Object Heap.
            </summary>
            <typeparam name="T">The type of elements stored in the array.</typeparam>
        </member>
        <member name="F:Loretta.CodeAnalysis.Collections.SegmentedArray`1.s_segmentSize">
             <summary>
             The number of elements in each page of the segmented array of type <typeparamref name="T"/>.
             </summary>
             <remarks>
             <para>The segment size is calculated according to <see cref="M:System.Runtime.CompilerServices.Unsafe.SizeOf``1"/>, performs the IL operation
             defined by <see cref="F:System.Reflection.Emit.OpCodes.Sizeof"/>. ECMA-335 defines this operation with the following note:</para>
            
             <para><c>sizeof</c> returns the total size that would be occupied by each element in an array of this type 
             including any padding the implementation chooses to add. Specifically, array elements lie <c>sizeof</c>
             bytes apart.</para>
             </remarks>
        </member>
        <member name="F:Loretta.CodeAnalysis.Collections.SegmentedArray`1.s_segmentShift">
            <summary>
            The bit shift to apply to an array index to get the page index within <see cref="F:Loretta.CodeAnalysis.Collections.SegmentedArray`1._items"/>.
            </summary>
        </member>
        <member name="F:Loretta.CodeAnalysis.Collections.SegmentedArray`1.s_offsetMask">
            <summary>
            The bit mask to apply to an array index to get the index within a page of <see cref="F:Loretta.CodeAnalysis.Collections.SegmentedArray`1._items"/>.
            </summary>
        </member>
        <member name="T:Loretta.CodeAnalysis.Collections.SegmentedDictionary`2">
            <summary>
            Represents a collection of keys and values.
            </summary>
            <remarks>
            <para>This collection has the same performance characteristics as <see cref="T:System.Collections.Generic.Dictionary`2"/>, but
            uses segmented arrays to avoid allocations in the Large Object Heap.</para>
            </remarks>
            <typeparam name="TKey">The type of the keys in the dictionary.</typeparam>
            <typeparam name="TValue">The type of the values in the dictionary.</typeparam>
        </member>
        <member name="M:Loretta.CodeAnalysis.Collections.SegmentedDictionary`2.EnsureCapacity(System.Int32)">
            <summary>
            Ensures that the dictionary can hold up to 'capacity' entries without any further expansion of its backing storage
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.Collections.SegmentedDictionary`2.TrimExcess">
             <summary>
             Sets the capacity of this dictionary to what it would be if it had been originally initialized with all its entries
             </summary>
             <remarks>
             This method can be used to minimize the memory overhead
             once it is known that no new elements will be added.
            
             To allocate minimum size storage array, execute the following statements:
            
             dictionary.Clear();
             dictionary.TrimExcess();
             </remarks>
        </member>
        <member name="M:Loretta.CodeAnalysis.Collections.SegmentedDictionary`2.TrimExcess(System.Int32)">
            <summary>
            Sets the capacity of this dictionary to hold up 'capacity' entries without any further expansion of its backing storage
            </summary>
            <remarks>
            This method can be used to minimize the memory overhead
            once it is known that no new elements will be added.
            </remarks>
        </member>
        <member name="F:Loretta.CodeAnalysis.Collections.SegmentedDictionary`2.Entry._next">
            <summary>
            0-based index of next entry in chain: -1 means end of chain
            also encodes whether this entry _itself_ is part of the free list by changing sign and subtracting 3,
            so -2 means end of free list, -3 means index 0 but on free list, -4 means index 1 but on free list, etc.
            </summary>
        </member>
        <member name="T:Loretta.CodeAnalysis.Collections.SegmentedList`1">
            <summary>
            Represents a strongly typed list of objects that can be accessed by index. Provides methods to search, sort, and
            manipulate lists.
            </summary>
            <remarks>
            <para>This collection has the same performance characteristics as <see cref="T:System.Collections.Generic.List`1"/>, but uses segmented
            arrays to avoid allocations in the Large Object Heap.</para>
            </remarks>
            <typeparam name="T">The type of elements in the list.</typeparam>
        </member>
        <member name="T:Loretta.CodeAnalysis.Rope">
            <summary>
            A representation of a string of characters that requires O(1) extra space to concatenate two ropes.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.Rope.ForString(System.String)">
            <summary>
            A rope can wrap a simple string.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.Rope.Concat(Loretta.CodeAnalysis.Rope,Loretta.CodeAnalysis.Rope)">
            <summary>
            A rope can be formed from the concatenation of two ropes.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.Rope.Equals(System.Object)">
            <summary>
            Two ropes are "the same" if they represent the same sequence of characters.
            </summary>
        </member>
        <member name="T:Loretta.CodeAnalysis.Rope.StringRope">
            <summary>
            A rope that wraps a simple string.
            </summary>
        </member>
        <member name="T:Loretta.CodeAnalysis.Rope.ConcatRope">
            <summary>
            A rope that represents the concatenation of two ropes.
            </summary>
        </member>
        <member name="T:Loretta.CodeAnalysis.ParseOptions">
            <summary>
            Represents parse options common to C# and VB.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.ParseOptions.DocumentationMode">
            <summary>
            Gets a value indicating whether the documentation comments are parsed.
            </summary>
            <value><c>true</c> if documentation comments are parsed, <c>false</c> otherwise.</value>
        </member>
        <member name="P:Loretta.CodeAnalysis.ParseOptions.Language">
            <summary>
            Gets the source language ("Lua").
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.ParseOptions.Errors">
            <summary>
            Errors collection related to an incompatible set of parse options
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.ParseOptions.ValidateOptions(Loretta.CodeAnalysis.PooledObjects.ArrayBuilder{Loretta.CodeAnalysis.Diagnostic})">
            <summary>
            Performs validation of options compatibilities and generates diagnostics if needed
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.ParseOptions.WithDocumentationMode(Loretta.CodeAnalysis.DocumentationMode)">
            <summary>
            Creates a new options instance with the specified documentation mode.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.ParseOptions.CommonWithDocumentationMode(Loretta.CodeAnalysis.DocumentationMode)">
            <inheritdoc cref="M:Loretta.CodeAnalysis.ParseOptions.WithDocumentationMode(Loretta.CodeAnalysis.DocumentationMode)"/>
        </member>
        <member name="M:Loretta.CodeAnalysis.ParseOptions.WithFeatures(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}})">
            <summary>
            Enable some experimental language features for testing.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.ParseOptions.CommonWithFeatures(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}})">
            <inheritdoc cref="M:Loretta.CodeAnalysis.ParseOptions.WithFeatures(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}})"/>
        </member>
        <member name="P:Loretta.CodeAnalysis.ParseOptions.Features">
            <summary>
            Returns the experimental features.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.ParseOptions.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Loretta.CodeAnalysis.ParseOptions.EqualsHelper(Loretta.CodeAnalysis.ParseOptions)">
            <summary>
            The helper method for equality comparison of the base class' fields.
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.ParseOptions.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Loretta.CodeAnalysis.ParseOptions.GetHashCodeHelper">
            <summary>
            The helper method for hash code calculation of the base class' fields.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.ParseOptions.op_Equality(Loretta.CodeAnalysis.ParseOptions,Loretta.CodeAnalysis.ParseOptions)">
            <summary>
            Checks whether two parse options are equal.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.ParseOptions.op_Inequality(Loretta.CodeAnalysis.ParseOptions,Loretta.CodeAnalysis.ParseOptions)">
            <summary>
            Checks whether two parse options are not equal.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="F:Loretta.CodeAnalysis.ConstantValue.s_IEEE_canonical_NaN">
            <summary>
            The IEEE floating-point spec doesn't specify which bit pattern an implementation
            is required to use when producing NaN values.  Indeed, the spec does recommend
            "diagnostic" information "left to the implementers discretion" be placed in the
            undefined bits. It is therefore likely that NaNs produced on different platforms
            will differ even for the same arithmetic such as 0.0 / 0.0.  To ensure that the
            compiler behaves in a deterministic way, we force NaN values to use the
            IEEE "canonical" form with the diagnostic bits set to zero and the sign bit set
            to one.  Conversion of this value to float produces the corresponding
            canonical NaN of the float type (IEEE Std 754-2008 section 6.2.3).
            </summary>
        </member>
        <member name="F:Loretta.CodeAnalysis.ConstantValue.ConstantValueString._constantValueReference">
            <summary>
            Some string constant values can have large costs to realize. To compensate, we realize
            constant values lazily, and hold onto a weak reference. If the next time we're asked for the constant
            value the previous one still exists, we can avoid rerealizing it. But we don't want to root the constant
            value if it's not being used.
            </summary>
        </member>
        <member name="T:Loretta.CodeAnalysis.Debugging.SourceHashAlgorithms">
            <summary>
            Hash algorithms supported by the debugger used for source file checksums stored in the PDB.
            </summary>
        </member>
        <member name="T:Loretta.CodeAnalysis.CommonMessageProvider">
            <summary>
            Abstracts the ability to classify and load messages for error codes. Allows the error
            infrastructure to be reused between C# and VB.
            </summary>
        </member>
        <member name="F:Loretta.CodeAnalysis.CommonMessageProvider.s_errorIdCache">
            <summary>
            Caches the return values for <see cref="M:Loretta.CodeAnalysis.CommonMessageProvider.GetIdForErrorCode(System.Int32)"/>.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.CommonMessageProvider.GetSeverity(System.Int32)">
            <summary>
            Given an error code, get the severity (warning or error) of the code.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.CommonMessageProvider.LoadMessage(System.Int32,System.Globalization.CultureInfo)">
            <summary>
            Load the message for the given error code. If the message contains
            "fill-in" placeholders, those should be expressed in standard string.Format notation
            and be in the string.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.CommonMessageProvider.GetTitle(System.Int32)">
            <summary>
            Get an optional localizable title for the given diagnostic code.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.CommonMessageProvider.GetDescription(System.Int32)">
            <summary>
            Get an optional localizable description for the given diagnostic code.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.CommonMessageProvider.GetMessageFormat(System.Int32)">
            <summary>
            Get a localizable message format string for the given diagnostic code.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.CommonMessageProvider.GetHelpLink(System.Int32)">
            <summary>
            Get an optional help link for the given diagnostic code.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.CommonMessageProvider.GetCategory(System.Int32)">
            <summary>
            Get the diagnostic category for the given diagnostic code.
            Default category is <see cref="F:Loretta.CodeAnalysis.Diagnostic.CompilerDiagnosticCategory"/>.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CommonMessageProvider.CodePrefix">
            <summary>
            Get the text prefix (e.g., "CS" for C#) used on error messages.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.CommonMessageProvider.GetWarningLevel(System.Int32)">
            <summary>
            Get the warning level for warnings (e.g., 1 or greater for C#). VB does not have warning
            levels and always uses 1. Errors should return 0.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.CommonMessageProvider.ErrorCodeType">
            <summary>
            Type that defines error codes. For testing purposes only.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.CommonMessageProvider.CreateDiagnostic(System.Int32,Loretta.CodeAnalysis.Location)">
            <summary>
            Create a simple language specific diagnostic for given error code.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.CommonMessageProvider.CreateDiagnostic(Loretta.CodeAnalysis.DiagnosticInfo)">
            <summary>
            Create a simple language specific diagnostic with no location for given info.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.CommonMessageProvider.CreateDiagnostic(System.Int32,Loretta.CodeAnalysis.Location,System.Object[])">
            <summary>
            Create a simple language specific diagnostic for given error code.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.CommonMessageProvider.GetMessagePrefix(System.String,Loretta.CodeAnalysis.DiagnosticSeverity,System.Boolean,System.Globalization.CultureInfo)">
            <summary>
            Given a message identifier (e.g., CS0219), severity, warning as error and a culture, 
            get the entire prefix (e.g., "error CS0219: Warning as Error:" for C# or "error BC42024:" for VB) used on error messages.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.CommonMessageProvider.GetIdForErrorCode(System.Int32)">
            <summary>
            Given an error code (like 1234) return the identifier (CS1234 or BC1234).
            </summary>
        </member>
        <member name="T:Loretta.CodeAnalysis.Diagnostic">
            <summary>
            Represents a diagnostic, such as a compiler error or a warning, along with the location where it occurred.
            </summary>
            <summary>
            A diagnostic (such as a compiler error or a warning), along with the location where it occurred.
            </summary>
        </member>
        <member name="F:Loretta.CodeAnalysis.Diagnostic.DefaultWarningLevel">
            <summary>
            The default warning level, which is also used for non-error diagnostics.
            </summary>
        </member>
        <member name="F:Loretta.CodeAnalysis.Diagnostic.InfoAndHiddenWarningLevel">
            <summary>
            The warning level used for hidden and info diagnostics. Because these diagnostics interact with other editor features, we want them to always be produced unless /warn:0 is set.
            </summary>
        </member>
        <member name="F:Loretta.CodeAnalysis.Diagnostic.MaxWarningLevel">
            <summary>
            The maximum warning level represented by a large value of 9999.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.Diagnostic.Create(Loretta.CodeAnalysis.DiagnosticDescriptor,Loretta.CodeAnalysis.Location,System.Object[])">
            <summary>
            Creates a <see cref="T:Loretta.CodeAnalysis.Diagnostic"/> instance.
            </summary>
            <param name="descriptor">A <see cref="T:Loretta.CodeAnalysis.DiagnosticDescriptor"/> describing the diagnostic</param>
            <param name="location">An optional primary location of the diagnostic. If null, <see cref="P:Loretta.CodeAnalysis.Diagnostic.Location"/> will return <see cref="P:Loretta.CodeAnalysis.Location.None"/>.</param>
            <param name="messageArgs">Arguments to the message of the diagnostic</param>
            <returns>The <see cref="T:Loretta.CodeAnalysis.Diagnostic"/> instance.</returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.Diagnostic.Create(Loretta.CodeAnalysis.DiagnosticDescriptor,Loretta.CodeAnalysis.Location,System.Collections.Immutable.ImmutableDictionary{System.String,System.String},System.Object[])">
            <summary>
            Creates a <see cref="T:Loretta.CodeAnalysis.Diagnostic"/> instance.
            </summary>
            <param name="descriptor">A <see cref="T:Loretta.CodeAnalysis.DiagnosticDescriptor"/> describing the diagnostic.</param>
            <param name="location">An optional primary location of the diagnostic. If null, <see cref="P:Loretta.CodeAnalysis.Diagnostic.Location"/> will return <see cref="P:Loretta.CodeAnalysis.Location.None"/>.</param>
            <param name="properties">
            An optional set of name-value pairs by means of which the analyzer that creates the diagnostic
            can convey more detailed information to the fixer. If null, <see cref="P:Loretta.CodeAnalysis.Diagnostic.Properties"/> will return
            <see cref="F:System.Collections.Immutable.ImmutableDictionary`2.Empty"/>.
            </param>
            <param name="messageArgs">Arguments to the message of the diagnostic.</param>
            <returns>The <see cref="T:Loretta.CodeAnalysis.Diagnostic"/> instance.</returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.Diagnostic.Create(Loretta.CodeAnalysis.DiagnosticDescriptor,Loretta.CodeAnalysis.Location,System.Collections.Generic.IEnumerable{Loretta.CodeAnalysis.Location},System.Object[])">
            <summary>
            Creates a <see cref="T:Loretta.CodeAnalysis.Diagnostic"/> instance.
            </summary>
            <param name="descriptor">A <see cref="T:Loretta.CodeAnalysis.DiagnosticDescriptor"/> describing the diagnostic.</param>
            <param name="location">An optional primary location of the diagnostic. If null, <see cref="P:Loretta.CodeAnalysis.Diagnostic.Location"/> will return <see cref="P:Loretta.CodeAnalysis.Location.None"/>.</param>
            <param name="additionalLocations">
            An optional set of additional locations related to the diagnostic.
            Typically, these are locations of other items referenced in the message.
            If null, <see cref="P:Loretta.CodeAnalysis.Diagnostic.AdditionalLocations"/> will return an empty list.
            </param>
            <param name="messageArgs">Arguments to the message of the diagnostic.</param>
            <returns>The <see cref="T:Loretta.CodeAnalysis.Diagnostic"/> instance.</returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.Diagnostic.Create(Loretta.CodeAnalysis.DiagnosticDescriptor,Loretta.CodeAnalysis.Location,System.Collections.Generic.IEnumerable{Loretta.CodeAnalysis.Location},System.Collections.Immutable.ImmutableDictionary{System.String,System.String},System.Object[])">
            <summary>
            Creates a <see cref="T:Loretta.CodeAnalysis.Diagnostic"/> instance.
            </summary>
            <param name="descriptor">A <see cref="T:Loretta.CodeAnalysis.DiagnosticDescriptor"/> describing the diagnostic.</param>
            <param name="location">An optional primary location of the diagnostic. If null, <see cref="P:Loretta.CodeAnalysis.Diagnostic.Location"/> will return <see cref="P:Loretta.CodeAnalysis.Location.None"/>.</param>
            <param name="additionalLocations">
            An optional set of additional locations related to the diagnostic.
            Typically, these are locations of other items referenced in the message.
            If null, <see cref="P:Loretta.CodeAnalysis.Diagnostic.AdditionalLocations"/> will return an empty list.
            </param>
            <param name="properties">
            An optional set of name-value pairs by means of which the analyzer that creates the diagnostic
            can convey more detailed information to the fixer. If null, <see cref="P:Loretta.CodeAnalysis.Diagnostic.Properties"/> will return
            <see cref="F:System.Collections.Immutable.ImmutableDictionary`2.Empty"/>.
            </param>
            <param name="messageArgs">Arguments to the message of the diagnostic.</param>
            <returns>The <see cref="T:Loretta.CodeAnalysis.Diagnostic"/> instance.</returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.Diagnostic.Create(Loretta.CodeAnalysis.DiagnosticDescriptor,Loretta.CodeAnalysis.Location,Loretta.CodeAnalysis.DiagnosticSeverity,System.Collections.Generic.IEnumerable{Loretta.CodeAnalysis.Location},System.Collections.Immutable.ImmutableDictionary{System.String,System.String},System.Object[])">
            <summary>
            Creates a <see cref="T:Loretta.CodeAnalysis.Diagnostic"/> instance.
            </summary>
            <param name="descriptor">A <see cref="T:Loretta.CodeAnalysis.DiagnosticDescriptor"/> describing the diagnostic.</param>
            <param name="location">An optional primary location of the diagnostic. If null, <see cref="P:Loretta.CodeAnalysis.Diagnostic.Location"/> will return <see cref="P:Loretta.CodeAnalysis.Location.None"/>.</param>
            <param name="effectiveSeverity">Effective severity of the diagnostic.</param>
            <param name="additionalLocations">
            An optional set of additional locations related to the diagnostic.
            Typically, these are locations of other items referenced in the message.
            If null, <see cref="P:Loretta.CodeAnalysis.Diagnostic.AdditionalLocations"/> will return an empty list.
            </param>
            <param name="properties">
            An optional set of name-value pairs by means of which the analyzer that creates the diagnostic
            can convey more detailed information to the fixer. If null, <see cref="P:Loretta.CodeAnalysis.Diagnostic.Properties"/> will return
            <see cref="F:System.Collections.Immutable.ImmutableDictionary`2.Empty"/>.
            </param>
            <param name="messageArgs">Arguments to the message of the diagnostic.</param>
            <returns>The <see cref="T:Loretta.CodeAnalysis.Diagnostic"/> instance.</returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.Diagnostic.Create(System.String,System.String,Loretta.CodeAnalysis.LocalizableString,Loretta.CodeAnalysis.DiagnosticSeverity,Loretta.CodeAnalysis.DiagnosticSeverity,System.Boolean,System.Int32,Loretta.CodeAnalysis.LocalizableString,Loretta.CodeAnalysis.LocalizableString,System.String,Loretta.CodeAnalysis.Location,System.Collections.Generic.IEnumerable{Loretta.CodeAnalysis.Location},System.Collections.Generic.IEnumerable{System.String},System.Collections.Immutable.ImmutableDictionary{System.String,System.String})">
            <summary>
            Creates a <see cref="T:Loretta.CodeAnalysis.Diagnostic"/> instance which is localizable.
            </summary>
            <param name="id">An identifier for the diagnostic. For diagnostics generated by the compiler, this will be a numeric code with a prefix such as "CS1001".</param>
            <param name="category">The category of the diagnostic. For diagnostics generated by the compiler, the category will be "Compiler".</param>
            <param name="message">The diagnostic message text.</param>
            <param name="severity">The diagnostic's effective severity.</param>
            <param name="defaultSeverity">The diagnostic's default severity.</param>
            <param name="isEnabledByDefault">True if the diagnostic is enabled by default</param>
            <param name="warningLevel">The warning level, between 1 and 4 if severity is <see cref="F:Loretta.CodeAnalysis.DiagnosticSeverity.Warning"/>; otherwise 0.</param>
            <param name="title">An optional short localizable title describing the diagnostic.</param>
            <param name="description">An optional longer localizable description for the diagnostic.</param>
            <param name="helpLink">An optional hyperlink that provides more detailed information regarding the diagnostic.</param>
            <param name="location">An optional primary location of the diagnostic. If null, <see cref="P:Loretta.CodeAnalysis.Diagnostic.Location"/> will return <see cref="P:Loretta.CodeAnalysis.Location.None"/>.</param>
            <param name="additionalLocations">
            An optional set of additional locations related to the diagnostic.
            Typically, these are locations of other items referenced in the message.
            If null, <see cref="P:Loretta.CodeAnalysis.Diagnostic.AdditionalLocations"/> will return an empty list.
            </param>
            <param name="customTags">
            An optional set of custom tags for the diagnostic. See <see cref="T:Loretta.CodeAnalysis.WellKnownDiagnosticTags"/> for some well known tags.
            If null, <see cref="P:Loretta.CodeAnalysis.Diagnostic.CustomTags"/> will return an empty list.
            </param>
            <param name="properties">
            An optional set of name-value pairs by means of which the analyzer that creates the diagnostic
            can convey more detailed information to the fixer. If null, <see cref="P:Loretta.CodeAnalysis.Diagnostic.Properties"/> will return
            <see cref="F:System.Collections.Immutable.ImmutableDictionary`2.Empty"/>.
            </param>
            <returns>The <see cref="T:Loretta.CodeAnalysis.Diagnostic"/> instance.</returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.Diagnostic.Create(System.String,System.String,Loretta.CodeAnalysis.LocalizableString,Loretta.CodeAnalysis.DiagnosticSeverity,Loretta.CodeAnalysis.DiagnosticSeverity,System.Boolean,System.Int32,System.Boolean,Loretta.CodeAnalysis.LocalizableString,Loretta.CodeAnalysis.LocalizableString,System.String,Loretta.CodeAnalysis.Location,System.Collections.Generic.IEnumerable{Loretta.CodeAnalysis.Location},System.Collections.Generic.IEnumerable{System.String},System.Collections.Immutable.ImmutableDictionary{System.String,System.String})">
            <summary>
            Creates a <see cref="T:Loretta.CodeAnalysis.Diagnostic"/> instance which is localizable.
            </summary>
            <param name="id">An identifier for the diagnostic. For diagnostics generated by the compiler, this will be a numeric code with a prefix such as "CS1001".</param>
            <param name="category">The category of the diagnostic. For diagnostics generated by the compiler, the category will be "Compiler".</param>
            <param name="message">The diagnostic message text.</param>
            <param name="severity">The diagnostic's effective severity.</param>
            <param name="defaultSeverity">The diagnostic's default severity.</param>
            <param name="isEnabledByDefault">True if the diagnostic is enabled by default</param>
            <param name="warningLevel">The warning level, between 1 and 4 if severity is <see cref="F:Loretta.CodeAnalysis.DiagnosticSeverity.Warning"/>; otherwise 0.</param>
            <param name="isSuppressed">Flag indicating whether the diagnostic is suppressed by a source suppression.</param>
            <param name="title">An optional short localizable title describing the diagnostic.</param>
            <param name="description">An optional longer localizable description for the diagnostic.</param>
            <param name="helpLink">An optional hyperlink that provides more detailed information regarding the diagnostic.</param>
            <param name="location">An optional primary location of the diagnostic. If null, <see cref="P:Loretta.CodeAnalysis.Diagnostic.Location"/> will return <see cref="P:Loretta.CodeAnalysis.Location.None"/>.</param>
            <param name="additionalLocations">
            An optional set of additional locations related to the diagnostic.
            Typically, these are locations of other items referenced in the message.
            If null, <see cref="P:Loretta.CodeAnalysis.Diagnostic.AdditionalLocations"/> will return an empty list.
            </param>
            <param name="customTags">
            An optional set of custom tags for the diagnostic. See <see cref="T:Loretta.CodeAnalysis.WellKnownDiagnosticTags"/> for some well known tags.
            If null, <see cref="P:Loretta.CodeAnalysis.Diagnostic.CustomTags"/> will return an empty list.
            </param>
            <param name="properties">
            An optional set of name-value pairs by means of which the analyzer that creates the diagnostic
            can convey more detailed information to the fixer. If null, <see cref="P:Loretta.CodeAnalysis.Diagnostic.Properties"/> will return
            <see cref="F:System.Collections.Immutable.ImmutableDictionary`2.Empty"/>.
            </param>
            <returns>The <see cref="T:Loretta.CodeAnalysis.Diagnostic"/> instance.</returns>
        </member>
        <member name="P:Loretta.CodeAnalysis.Diagnostic.Descriptor">
            <summary>
            Gets the diagnostic descriptor, which provides a description about a <see cref="T:Loretta.CodeAnalysis.Diagnostic"/>.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.Diagnostic.Id">
            <summary>
            Gets the diagnostic identifier. For diagnostics generated by the compiler, this will be a numeric code with a prefix such as "CS1001".
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.Diagnostic.Category">
            <summary>
            Gets the category of diagnostic. For diagnostics generated by the compiler, the category will be "Compiler".
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.Diagnostic.GetMessage(System.IFormatProvider)">
            <summary>
            Get the culture specific text of the message.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.Diagnostic.DefaultSeverity">
            <summary>
            Gets the default <see cref="T:Loretta.CodeAnalysis.DiagnosticSeverity"/> of the diagnostic's <see cref="T:Loretta.CodeAnalysis.DiagnosticDescriptor"/>.
            </summary>
            <remarks>
            To get the effective severity of the diagnostic, use <see cref="P:Loretta.CodeAnalysis.Diagnostic.Severity"/>.
            </remarks>
        </member>
        <member name="P:Loretta.CodeAnalysis.Diagnostic.Severity">
            <summary>
            Gets the effective <see cref="T:Loretta.CodeAnalysis.DiagnosticSeverity"/> of the diagnostic.
            </summary>
            <remarks>
            To get the default severity of diagnostic's <see cref="T:Loretta.CodeAnalysis.DiagnosticDescriptor"/>, use <see cref="P:Loretta.CodeAnalysis.Diagnostic.DefaultSeverity"/>.
            To determine if this is a warning treated as an error, use <see cref="P:Loretta.CodeAnalysis.Diagnostic.IsWarningAsError"/>.
            </remarks>
        </member>
        <member name="P:Loretta.CodeAnalysis.Diagnostic.WarningLevel">
            <summary>
            Gets the warning level. This is 0 for diagnostics with severity <see cref="F:Loretta.CodeAnalysis.DiagnosticSeverity.Error"/>,
            otherwise an integer greater than zero.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.Diagnostic.IsSuppressed">
            <summary>
            Returns true if the diagnostic has a source suppression, i.e. an attribute or a pragma suppression.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.Diagnostic.IsEnabledByDefault">
            <summary>
            Returns true if this diagnostic is enabled by default by the author of the diagnostic.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.Diagnostic.IsWarningAsError">
            <summary>
            Returns true if this is a warning treated as an error; otherwise false.
            </summary>
            <remarks>
            True implies <see cref="P:Loretta.CodeAnalysis.Diagnostic.DefaultSeverity"/> = <see cref="F:Loretta.CodeAnalysis.DiagnosticSeverity.Warning"/>
            and <see cref="P:Loretta.CodeAnalysis.Diagnostic.Severity"/> = <see cref="F:Loretta.CodeAnalysis.DiagnosticSeverity.Error"/>.
            </remarks>
        </member>
        <member name="P:Loretta.CodeAnalysis.Diagnostic.Location">
            <summary>
            Gets the primary location of the diagnostic, or <see cref="P:Loretta.CodeAnalysis.Location.None"/> if no primary location.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.Diagnostic.AdditionalLocations">
            <summary>
            Gets an array of additional locations related to the diagnostic.
            Typically these are the locations of other items referenced in the message.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.Diagnostic.CustomTags">
            <summary>
            Gets custom tags for the diagnostic.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.Diagnostic.Properties">
            <summary>
            Gets property bag for the diagnostic. it will return <see cref="F:System.Collections.Immutable.ImmutableDictionary`2.Empty"/> 
            if there is no entry. This can be used to put diagnostic specific information you want 
            to pass around. for example, to corresponding fixer.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.Diagnostic.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Loretta.CodeAnalysis.Diagnostic.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Loretta.CodeAnalysis.Diagnostic.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Loretta.CodeAnalysis.Diagnostic.Equals(Loretta.CodeAnalysis.Diagnostic)">
            <inheritdoc/>
        </member>
        <member name="M:Loretta.CodeAnalysis.Diagnostic.WithLocation(Loretta.CodeAnalysis.Location)">
            <summary>
            Create a new instance of this diagnostic with the Location property changed.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.Diagnostic.WithSeverity(Loretta.CodeAnalysis.DiagnosticSeverity)">
            <summary>
            Create a new instance of this diagnostic with the Severity property changed.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.Diagnostic.WithIsSuppressed(System.Boolean)">
            <summary>
            Create a new instance of this diagnostic with the suppression info changed.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.Diagnostic.HasIntersectingLocation(Loretta.CodeAnalysis.SyntaxTree,System.Nullable{Loretta.CodeAnalysis.Text.TextSpan})">
            <summary>
            Returns true if the diagnostic location (or any additional location) is within the given tree and intersects with the filterSpanWithinTree, if non-null.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.Diagnostic.GetDefaultWarningLevel(Loretta.CodeAnalysis.DiagnosticSeverity)">
            <summary>
            Gets the default warning level for a diagnostic severity. Warning levels are used with the <c>/warn:N</c>
            command line option to suppress diagnostics over a severity of interest. When N is 0, only error severity
            messages are produced by the compiler. Values greater than 0 indicated that warnings up to and including
            level N should also be included.
            </summary>
            <remarks>
            <see cref="F:Loretta.CodeAnalysis.DiagnosticSeverity.Info"/> and <see cref="F:Loretta.CodeAnalysis.DiagnosticSeverity.Hidden"/> are treated as warning
            level 1. In other words, these diagnostics which typically interact with editor features are enabled unless
            the special <c>/warn:0</c> option is set.
            </remarks>
            <param name="severity">A <see cref="T:Loretta.CodeAnalysis.DiagnosticSeverity"/> value.</param>
            <returns>The default compiler warning level for <paramref name="severity"/>.</returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.Diagnostic.IsNotConfigurable">
            <summary>
            Returns true if a diagnostic is not configurable, i.e. cannot be suppressed or filtered or have its severity changed.
            For example, compiler errors are always non-configurable.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.Diagnostic.IsUnsuppressableError">
            <summary>
            Returns true if this is an error diagnostic which cannot be suppressed and is guaranteed to break the build.
            Only diagnostics which have default severity error and are tagged as NotConfigurable fall in this bucket.
            This includes all compiler error diagnostics and specific analyzer error diagnostics that are marked as not configurable by the analyzer author.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.Diagnostic.IsUnsuppressedError">
            <summary>
            Returns true if this is a unsuppressed diagnostic with an effective error severity.
            </summary>
        </member>
        <member name="T:Loretta.CodeAnalysis.DiagnosticDescriptor">
            <summary>
            Provides a description about a <see cref="T:Loretta.CodeAnalysis.Diagnostic"/>
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.DiagnosticDescriptor.Id">
            <summary>
            An unique identifier for the diagnostic.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.DiagnosticDescriptor.Title">
            <summary>
            A short localizable title describing the diagnostic.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.DiagnosticDescriptor.Description">
            <summary>
            An optional longer localizable description for the diagnostic.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.DiagnosticDescriptor.HelpLinkUri">
            <summary>
            An optional hyperlink that provides more detailed information regarding the diagnostic.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.DiagnosticDescriptor.MessageFormat">
            <summary>
            A localizable format message string, which can be passed as the first argument to <see cref="M:System.String.Format(System.String,System.Object[])"/> when creating the diagnostic message with this descriptor.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Loretta.CodeAnalysis.DiagnosticDescriptor.Category">
            <summary>
            The category of the diagnostic (like Design, Naming etc.)
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.DiagnosticDescriptor.DefaultSeverity">
            <summary>
            The default severity of the diagnostic.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.DiagnosticDescriptor.IsEnabledByDefault">
            <summary>
            Returns true if the diagnostic is enabled by default.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.DiagnosticDescriptor.CustomTags">
            <summary>
            Custom tags for the diagnostic.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.DiagnosticDescriptor.#ctor(System.String,System.String,System.String,System.String,Loretta.CodeAnalysis.DiagnosticSeverity,System.Boolean,System.String,System.String,System.String[])">
            <summary>
            Create a DiagnosticDescriptor, which provides description about a <see cref="T:Loretta.CodeAnalysis.Diagnostic"/>.
            NOTE: For localizable <paramref name="title"/>, <paramref name="description"/> and/or <paramref name="messageFormat"/>,
            use constructor overload <see cref="M:Loretta.CodeAnalysis.DiagnosticDescriptor.#ctor(System.String,Loretta.CodeAnalysis.LocalizableString,Loretta.CodeAnalysis.LocalizableString,System.String,Loretta.CodeAnalysis.DiagnosticSeverity,System.Boolean,Loretta.CodeAnalysis.LocalizableString,System.String,System.String[])"/>.
            </summary>
            <param name="id">A unique identifier for the diagnostic. For example, code analysis diagnostic ID "CA1001".</param>
            <param name="title">A short title describing the diagnostic. For example, for CA1001: "Types that own disposable fields should be disposable".</param>
            <param name="messageFormat">A format message string, which can be passed as the first argument to <see cref="M:System.String.Format(System.String,System.Object[])"/> when creating the diagnostic message with this descriptor.
            For example, for CA1001: "Implement IDisposable on '{0}' because it creates members of the following IDisposable types: '{1}'."</param>
            <param name="category">The category of the diagnostic (like Design, Naming etc.). For example, for CA1001: "Microsoft.Design".</param>
            <param name="defaultSeverity">Default severity of the diagnostic.</param>
            <param name="isEnabledByDefault">True if the diagnostic is enabled by default.</param>
            <param name="description">An optional longer description of the diagnostic.</param>
            <param name="helpLinkUri">An optional hyperlink that provides a more detailed description regarding the diagnostic.</param>
            <param name="customTags">Optional custom tags for the diagnostic. See <see cref="T:Loretta.CodeAnalysis.WellKnownDiagnosticTags"/> for some well known tags.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.DiagnosticDescriptor.#ctor(System.String,Loretta.CodeAnalysis.LocalizableString,Loretta.CodeAnalysis.LocalizableString,System.String,Loretta.CodeAnalysis.DiagnosticSeverity,System.Boolean,Loretta.CodeAnalysis.LocalizableString,System.String,System.String[])">
            <summary>
            Create a DiagnosticDescriptor, which provides description about a <see cref="T:Loretta.CodeAnalysis.Diagnostic"/>.
            </summary>
            <param name="id">A unique identifier for the diagnostic. For example, code analysis diagnostic ID "CA1001".</param>
            <param name="title">A short localizable title describing the diagnostic. For example, for CA1001: "Types that own disposable fields should be disposable".</param>
            <param name="messageFormat">A localizable format message string, which can be passed as the first argument to <see cref="M:System.String.Format(System.String,System.Object[])"/> when creating the diagnostic message with this descriptor.
            For example, for CA1001: "Implement IDisposable on '{0}' because it creates members of the following IDisposable types: '{1}'."</param>
            <param name="category">The category of the diagnostic (like Design, Naming etc.). For example, for CA1001: "Microsoft.Design".</param>
            <param name="defaultSeverity">Default severity of the diagnostic.</param>
            <param name="isEnabledByDefault">True if the diagnostic is enabled by default.</param>
            <param name="description">An optional longer localizable description of the diagnostic.</param>
            <param name="helpLinkUri">An optional hyperlink that provides a more detailed description regarding the diagnostic.</param>
            <param name="customTags">Optional custom tags for the diagnostic. See <see cref="T:Loretta.CodeAnalysis.WellKnownDiagnosticTags"/> for some well known tags.</param>
            <remarks>Example descriptor for rule CA1001:
                internal static DiagnosticDescriptor Rule = new DiagnosticDescriptor(RuleId,
                    new LocalizableResourceString(nameof(FxCopRulesResources.TypesThatOwnDisposableFieldsShouldBeDisposable), FxCopRulesResources.ResourceManager, typeof(FxCopRulesResources)),
                    new LocalizableResourceString(nameof(FxCopRulesResources.TypeOwnsDisposableFieldButIsNotDisposable), FxCopRulesResources.ResourceManager, typeof(FxCopRulesResources)),
                    FxCopDiagnosticCategory.Design,
                    DiagnosticSeverity.Warning,
                    isEnabledByDefault: true,
                    helpLinkUri: "http://msdn.microsoft.com/library/ms182172.aspx",
                    customTags: DiagnosticCustomTags.Microsoft);
            </remarks>
        </member>
        <member name="M:Loretta.CodeAnalysis.DiagnosticDescriptor.Equals(Loretta.CodeAnalysis.DiagnosticDescriptor)">
            <inheritdoc/>
        </member>
        <member name="M:Loretta.CodeAnalysis.DiagnosticDescriptor.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Loretta.CodeAnalysis.DiagnosticDescriptor.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="T:Loretta.CodeAnalysis.DiagnosticFormatter">
            <summary>
            Formats <see cref="T:Loretta.CodeAnalysis.Diagnostic"/> messages.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.DiagnosticFormatter.Format(Loretta.CodeAnalysis.Diagnostic,System.IFormatProvider)">
            <summary>
            Formats the <see cref="T:Loretta.CodeAnalysis.Diagnostic"/> message using the optional <see cref="T:System.IFormatProvider"/>.
            </summary>
            <param name="diagnostic">The diagnostic.</param>
            <param name="formatter">The formatter; or null to use the default formatter.</param>
            <returns>The formatted message.</returns>
        </member>
        <member name="T:Loretta.CodeAnalysis.DiagnosticInfo">
            <summary>
            A DiagnosticInfo object has information about a diagnostic, but without any attached location information.
            </summary>
            <remarks>
            More specialized diagnostics with additional information (e.g., ambiguity errors) can derive from this class to
            provide access to additional information about the error, such as what symbols were involved in the ambiguity.
            </remarks>
        </member>
        <member name="P:Loretta.CodeAnalysis.DiagnosticInfo.Code">
            <summary>
            The error code, as an integer.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.DiagnosticInfo.Severity">
            <summary>
            Returns the effective severity of the diagnostic: whether this diagnostic is informational, warning, or error.
            If IsWarningsAsError is true, then this returns <see cref="F:Loretta.CodeAnalysis.DiagnosticSeverity.Error"/>, while <see cref="P:Loretta.CodeAnalysis.DiagnosticInfo.DefaultSeverity"/> returns <see cref="F:Loretta.CodeAnalysis.DiagnosticSeverity.Warning"/>.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.DiagnosticInfo.DefaultSeverity">
            <summary>
            Returns whether this diagnostic is informational, warning, or error by default, based on the error code.
            To get diagnostic's effective severity, use <see cref="P:Loretta.CodeAnalysis.DiagnosticInfo.Severity"/>.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.DiagnosticInfo.WarningLevel">
            <summary>
            Gets the warning level. This is 0 for diagnostics with severity <see cref="F:Loretta.CodeAnalysis.DiagnosticSeverity.Error"/>,
            otherwise an integer greater than zero.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.DiagnosticInfo.IsWarningAsError">
            <summary>
            Returns true if this is a warning treated as an error.
            </summary>
            <remarks>
            True implies <see cref="P:Loretta.CodeAnalysis.DiagnosticInfo.Severity"/> = <see cref="F:Loretta.CodeAnalysis.DiagnosticSeverity.Error"/> and
            <see cref="P:Loretta.CodeAnalysis.DiagnosticInfo.DefaultSeverity"/> = <see cref="F:Loretta.CodeAnalysis.DiagnosticSeverity.Warning"/>.
            </remarks>
        </member>
        <member name="P:Loretta.CodeAnalysis.DiagnosticInfo.Category">
            <summary>
            Get the diagnostic category for the given diagnostic code.
            Default category is <see cref="F:Loretta.CodeAnalysis.Diagnostic.CompilerDiagnosticCategory"/>.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.DiagnosticInfo.AdditionalLocations">
            <summary>
            If a derived class has additional information about other referenced symbols, it can
            expose the locations of those symbols in a general way, so they can be reported along
            with the error.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.DiagnosticInfo.MessageIdentifier">
            <summary>
            Get the message id (for example "CS1001") for the message. This includes both the error number
            and a prefix identifying the source.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.DiagnosticInfo.GetMessage(System.IFormatProvider)">
            <summary>
            Get the text of the message in the given language.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.DiagnosticInfo.GetResolvedInfo">
            <summary>
            For a DiagnosticInfo that is lazily evaluated, this method evaluates it
            and returns a non-lazy DiagnosticInfo.
            </summary>
        </member>
        <member name="T:Loretta.CodeAnalysis.DiagnosticSeverity">
            <summary>
            Describes how severe a diagnostic is.
            </summary>
        </member>
        <member name="F:Loretta.CodeAnalysis.DiagnosticSeverity.Hidden">
            <summary>
            Something that is an issue, as determined by some authority,
            but is not surfaced through normal means.
            There may be different mechanisms that act on these issues.
            </summary>
        </member>
        <member name="F:Loretta.CodeAnalysis.DiagnosticSeverity.Info">
            <summary>
            Information that does not indicate a problem (i.e. not prescriptive).
            </summary>
        </member>
        <member name="F:Loretta.CodeAnalysis.DiagnosticSeverity.Warning">
            <summary>
            Something suspicious but allowed.
            </summary>
        </member>
        <member name="F:Loretta.CodeAnalysis.DiagnosticSeverity.Error">
            <summary>
            Something not allowed by the rules of the language or other authority.
            </summary>
        </member>
        <member name="T:Loretta.CodeAnalysis.InternalDiagnosticSeverity">
            <summary>
            Values for severity that are used internally by the compiler but are not exposed.
            </summary>
        </member>
        <member name="F:Loretta.CodeAnalysis.InternalDiagnosticSeverity.Unknown">
            <summary>
            An unknown severity diagnostic is something whose severity has not yet been determined.
            </summary>
        </member>
        <member name="F:Loretta.CodeAnalysis.InternalDiagnosticSeverity.Void">
            <summary>
            If an unknown diagnostic is resolved and found to be unnecessary then it is 
            treated as a "Void" diagnostic
            </summary>
        </member>
        <member name="T:Loretta.CodeAnalysis.InternalErrorCode">
            <summary>
            Values for ErrorCode/ERRID that are used internally by the compiler but are not exposed.
            </summary>
        </member>
        <member name="F:Loretta.CodeAnalysis.InternalErrorCode.Unknown">
            <summary>
            The code has yet to be determined.
            </summary>
        </member>
        <member name="F:Loretta.CodeAnalysis.InternalErrorCode.Void">
            <summary>
            The code was lazily determined and does not need to be reported.
            </summary>
        </member>
        <member name="T:Loretta.CodeAnalysis.DiagnosticWithInfo">
            <summary>
            A diagnostic (such as a compiler error or a warning), along with the location where it occurred.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.DiagnosticWithInfo.Info">
            <summary>
            Get the information about the diagnostic: the code, severity, message, etc.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.DiagnosticWithInfo.HasLazyInfo">
            <summary>
            True if the DiagnosticInfo for this diagnostic requires (or required - this property
            is immutable) resolution.
            </summary>
        </member>
        <member name="T:Loretta.CodeAnalysis.ExternalFileLocation">
            <summary>
            A program location in source code.
            </summary>
        </member>
        <member name="T:Loretta.CodeAnalysis.FileLinePositionSpan">
            <summary>
            Represents a span of text in a source code file in terms of file name, line number, and offset within line.
            However, the file is actually whatever was passed in when asked to parse; there may not really be a file.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.FileLinePositionSpan.Path">
            <summary>
            Path, or null if the span represents an invalid value.
            </summary>
            <remarks>
            Path may be <see cref="F:System.String.Empty"/> if not available.
            </remarks>
        </member>
        <member name="P:Loretta.CodeAnalysis.FileLinePositionSpan.HasMappedPath">
            <summary>
            True if the <see cref="P:Loretta.CodeAnalysis.FileLinePositionSpan.Path"/> is a mapped path.
            </summary>
            <remarks>
            A mapped path is a path specified in source via <c>#line</c> (C#) or <c>#ExternalSource</c> (VB) directives.
            </remarks>
        </member>
        <member name="P:Loretta.CodeAnalysis.FileLinePositionSpan.StartLinePosition">
            <summary>
            Gets the <see cref="T:Loretta.CodeAnalysis.Text.LinePosition"/> of the start of the span.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Loretta.CodeAnalysis.FileLinePositionSpan.EndLinePosition">
            <summary>
            Gets the <see cref="T:Loretta.CodeAnalysis.Text.LinePosition"/> of the end of the span.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Loretta.CodeAnalysis.FileLinePositionSpan.Span">
            <summary>
            Gets the span.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.FileLinePositionSpan.#ctor(System.String,Loretta.CodeAnalysis.Text.LinePosition,Loretta.CodeAnalysis.Text.LinePosition)">
            <summary>
            Initializes the <see cref="T:Loretta.CodeAnalysis.FileLinePositionSpan"/> instance.
            </summary>
            <param name="path">The file identifier - typically a relative or absolute path.</param>
            <param name="start">The start line position.</param>
            <param name="end">The end line position.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="path"/> is null.</exception>
        </member>
        <member name="M:Loretta.CodeAnalysis.FileLinePositionSpan.#ctor(System.String,Loretta.CodeAnalysis.Text.LinePositionSpan)">
            <summary>
            Initializes the <see cref="T:Loretta.CodeAnalysis.FileLinePositionSpan"/> instance.
            </summary>
            <param name="path">The file identifier - typically a relative or absolute path.</param>
            <param name="span">The span.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="path"/> is null.</exception>
        </member>
        <member name="P:Loretta.CodeAnalysis.FileLinePositionSpan.IsValid">
            <summary>
            Returns true if the span represents a valid location.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.FileLinePositionSpan.Equals(Loretta.CodeAnalysis.FileLinePositionSpan)">
            <summary>
            Determines if two FileLinePositionSpan objects are equal.
            </summary>
            <remarks>
            The path is treated as an opaque string, i.e. a case-sensitive comparison is used.
            </remarks>
        </member>
        <member name="M:Loretta.CodeAnalysis.FileLinePositionSpan.Equals(System.Object)">
            <summary>
            Determines if two FileLinePositionSpan objects are equal.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.FileLinePositionSpan.GetHashCode">
            <summary>
            Serves as a hash function for FileLinePositionSpan.
            </summary>
            <returns>The hash code.</returns>
            <remarks>
            The path is treated as an opaque string, i.e. a case-sensitive hash is calculated.
            </remarks>
        </member>
        <member name="M:Loretta.CodeAnalysis.FileLinePositionSpan.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents FileLinePositionSpan.
            </summary>
            <returns>The string representation of FileLinePositionSpan.</returns>
            <example>Path: (0,0)-(5,6)</example>
        </member>
        <member name="M:Loretta.CodeAnalysis.FileLinePositionSpan.op_Equality(Loretta.CodeAnalysis.FileLinePositionSpan,Loretta.CodeAnalysis.FileLinePositionSpan)">
            <summary>
            Checks whether two spans are equal.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.FileLinePositionSpan.op_Inequality(Loretta.CodeAnalysis.FileLinePositionSpan,Loretta.CodeAnalysis.FileLinePositionSpan)">
            <summary>
            Checks whether two spans are not equal.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="T:Loretta.CodeAnalysis.LocalizableResourceString">
            <summary>
            A localizable resource string that may possibly be formatted differently depending on culture.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.LocalizableResourceString.#ctor(System.String,System.Resources.ResourceManager,System.Type)">
            <summary>
            Creates a localizable resource string with no formatting arguments.
            </summary>
            <param name="nameOfLocalizableResource">nameof the resource that needs to be localized.</param>
            <param name="resourceManager"><see cref="T:System.Resources.ResourceManager"/> for the calling assembly.</param>
            <param name="resourceSource">Type handling assembly's resource management. Typically, this is the static class generated for the resources file from which resources are accessed.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.LocalizableResourceString.#ctor(System.String,System.Resources.ResourceManager,System.Type,System.String[])">
            <summary>
            Creates a localizable resource string that may possibly be formatted differently depending on culture.
            </summary>
            <param name="nameOfLocalizableResource">nameof the resource that needs to be localized.</param>
            <param name="resourceManager"><see cref="T:System.Resources.ResourceManager"/> for the calling assembly.</param>
            <param name="resourceSource">Type handling assembly's resource management. Typically, this is the static class generated for the resources file from which resources are accessed.</param>
            <param name="formatArguments">Optional arguments for formatting the localizable resource string.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.LocalizableResourceString.GetText(System.IFormatProvider)">
            <summary>
            Gets the text for the localizable string with the provided format provider.
            </summary>
            <param name="formatProvider"></param>
            <returns></returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.LocalizableResourceString.AreEqual(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Loretta.CodeAnalysis.LocalizableResourceString.GetHash">
            <inheritdoc/>
        </member>
        <member name="T:Loretta.CodeAnalysis.LocalizableString">
            <summary>
            A string that may possibly be formatted differently depending on culture.
            NOTE: Types implementing <see cref="T:Loretta.CodeAnalysis.LocalizableString"/> must be serializable.
            </summary>
        </member>
        <member name="F:Loretta.CodeAnalysis.LocalizableString.FixedLocalizableString.s_empty">
            <summary>
            FixedLocalizableString representing an empty string.
            </summary>
        </member>
        <member name="E:Loretta.CodeAnalysis.LocalizableString.OnException">
            <summary>
            Fired when an exception is raised by any of the public methods of <see cref="T:Loretta.CodeAnalysis.LocalizableString"/>.
            If the exception handler itself throws an exception, that exception is ignored.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.LocalizableString.ToString(System.IFormatProvider)">
            <summary>
            Formats the value of the current instance using the optionally specified format. 
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.LocalizableString.op_Explicit(Loretta.CodeAnalysis.LocalizableString)~System.String">
            <summary>
            Converts a <see cref="T:Loretta.CodeAnalysis.LocalizableString"/> to a <see cref="T:System.String"/> with the default UI culture.
            </summary>
            <param name="localizableResource"></param>
        </member>
        <member name="M:Loretta.CodeAnalysis.LocalizableString.op_Implicit(System.String)~Loretta.CodeAnalysis.LocalizableString">
            <summary>
            Converts a <see cref="T:System.String"/> to a <see cref="T:Loretta.CodeAnalysis.LocalizableString"/>.
            </summary>
            <param name="fixedResource"></param>
        </member>
        <member name="M:Loretta.CodeAnalysis.LocalizableString.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Loretta.CodeAnalysis.LocalizableString.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Loretta.CodeAnalysis.LocalizableString.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Loretta.CodeAnalysis.LocalizableString.Equals(Loretta.CodeAnalysis.LocalizableString)">
            <inheritdoc/>
        </member>
        <member name="M:Loretta.CodeAnalysis.LocalizableString.GetText(System.IFormatProvider)">
            <summary>
            Formats the value of the current instance using the optionally specified format.
            Provides the implementation of ToString. ToString will provide a default value
            if this method throws an exception.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.LocalizableString.GetHash">
            <summary>
            Provides the implementation of GetHashCode. GetHashCode will provide a default value
            if this method throws an exception.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.LocalizableString.AreEqual(System.Object)">
            <summary>
            Provides the implementation of Equals. Equals will provide a default value
            if this method throws an exception.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Loretta.CodeAnalysis.LocalizableString.CanThrowExceptions">
            <summary>
            Flag indicating if any methods on this type can throw exceptions from public entrypoints.
            </summary>
        </member>
        <member name="T:Loretta.CodeAnalysis.Location">
            <summary>
            A program location in source code.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.Location.Kind">
            <summary>
            Location kind (None/SourceFile/MetadataFile).
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.Location.IsInSource">
            <summary>
            Returns true if the location represents a specific location in a source code file.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.Location.SourceTree">
            <summary>
            The syntax tree this location is located in or <c>null</c> if not in a syntax tree.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.Location.SourceSpan">
            <summary>
            The location within the syntax tree that this location is associated with.
            </summary>
            <remarks>
            If <see cref="P:Loretta.CodeAnalysis.Location.IsInSource"/> returns False this method returns an empty <see cref="T:Loretta.CodeAnalysis.Text.TextSpan"/> which starts at position 0.
            </remarks>
        </member>
        <member name="M:Loretta.CodeAnalysis.Location.GetLineSpan">
            <summary>
            Gets the location in terms of path, line and column.
            </summary>
            <returns>
            <see cref="T:Loretta.CodeAnalysis.FileLinePositionSpan"/> that contains path, line and column information.
            
            Returns an invalid span (see <see cref="P:Loretta.CodeAnalysis.FileLinePositionSpan.IsValid"/>) if the information is not available.
            
            The values are not affected by line mapping directives (#line in C# or #ExternalSource in VB).
            </returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.Location.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Loretta.CodeAnalysis.Location.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Loretta.CodeAnalysis.Location.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Loretta.CodeAnalysis.Location.op_Equality(Loretta.CodeAnalysis.Location,Loretta.CodeAnalysis.Location)">
            <summary>
            Checks whether two locations are equal.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.Location.op_Inequality(Loretta.CodeAnalysis.Location,Loretta.CodeAnalysis.Location)">
            <summary>
            Checks whether two locations are not equal.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.Location.GetDebuggerDisplay">
            <summary>
            Returns the display string for the debugger.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Loretta.CodeAnalysis.Location.None">
            <summary>
            A location of kind LocationKind.None. 
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.Location.Create(Loretta.CodeAnalysis.SyntaxTree,Loretta.CodeAnalysis.Text.TextSpan)">
            <summary>
            Creates an instance of a <see cref="T:Loretta.CodeAnalysis.Location"/> for a span in a <see cref="T:Loretta.CodeAnalysis.SyntaxTree"/>.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.Location.Create(System.String,Loretta.CodeAnalysis.Text.TextSpan,Loretta.CodeAnalysis.Text.LinePositionSpan)">
            <summary>
            Creates an instance of a <see cref="T:Loretta.CodeAnalysis.Location"/> for a span in a file.
            </summary>
        </member>
        <member name="T:Loretta.CodeAnalysis.LocationKind">
            <summary>
            Specifies the kind of location (source vs. metadata).
            </summary>
        </member>
        <member name="F:Loretta.CodeAnalysis.LocationKind.None">
            <summary>
            Unspecified location.
            </summary>
        </member>
        <member name="F:Loretta.CodeAnalysis.LocationKind.SourceFile">
            <summary>
            The location represents a position in a source file.
            </summary>
        </member>
        <member name="F:Loretta.CodeAnalysis.LocationKind.MetadataFile">
            <summary>
            The location represents a metadata file.
            </summary>
        </member>
        <member name="F:Loretta.CodeAnalysis.LocationKind.ExternalFile">
            <summary>
            The location in some external file.
            </summary>
        </member>
        <member name="T:Loretta.CodeAnalysis.NoLocation">
            <summary>
            A class that represents no location at all. Useful for errors in command line options, for example.
            </summary>
            <remarks></remarks>
        </member>
        <member name="T:Loretta.CodeAnalysis.SourceLocation">
            <summary>
            A program location in source code.
            </summary>
        </member>
        <member name="T:Loretta.CodeAnalysis.WellKnownDiagnosticTags">
            <summary>
            A class with common diagnostic tags.
            </summary>
        </member>
        <member name="F:Loretta.CodeAnalysis.WellKnownDiagnosticTags.Unnecessary">
            <summary>
            Indicates that the diagnostic is related to some unnecessary source code.
            </summary>
        </member>
        <member name="F:Loretta.CodeAnalysis.WellKnownDiagnosticTags.Build">
            <summary>
            Indicates that the diagnostic is related to build.
            </summary>
        </member>
        <member name="F:Loretta.CodeAnalysis.WellKnownDiagnosticTags.Compiler">
            <summary>
            Indicates that the diagnostic is reported by the compiler.
            </summary>
        </member>
        <member name="F:Loretta.CodeAnalysis.WellKnownDiagnosticTags.NotConfigurable">
            <summary>
            Indicates that the diagnostic is not configurable, i.e. it cannot be suppressed or filtered or have its severity changed.
            </summary>
        </member>
        <member name="T:Loretta.CodeAnalysis.DocumentationMode">
            <summary>
            Specifies the different documentation comment processing modes.
            </summary>
            <remarks>
            Order matters: least processing to most processing.
            </remarks>
        </member>
        <member name="F:Loretta.CodeAnalysis.DocumentationMode.None">
            <summary>
            Treats documentation comments as regular comments.
            </summary>
        </member>
        <member name="F:Loretta.CodeAnalysis.DocumentationMode.Parse">
            <summary>
            Parses documentation comments as structured trivia, but do not report any diagnostics.
            </summary>
        </member>
        <member name="F:Loretta.CodeAnalysis.DocumentationMode.Diagnose">
            <summary>
            Parses documentation comments as structured trivia and report diagnostics.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.StackGuard.EnsureSufficientExecutionStack(System.Int32)">
            <summary>
                Ensures that the remaining stack space is large enough to execute
                the average function.
            </summary>
            <param name="recursionDepth">how many times the calling function has recursed</param>
            <exception cref="T:System.InsufficientExecutionStackException">
                The available stack space is insufficient to execute
                the average function.
            </exception>
        </member>
        <member name="M:Loretta.CodeAnalysis.PooledObjects.ArrayBuilder`1.ToImmutable">
            <summary>
            Realizes the array.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.PooledObjects.ArrayBuilder`1.ToImmutableAndClear">
            <summary>
            Realizes the array and clears the collection.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.PooledObjects.ArrayBuilder`1.SetItem(System.Int32,`0)">
            <summary>
            Write <paramref name="value"/> to slot <paramref name="index"/>. 
            Fills in unallocated slots preceding the <paramref name="index"/>, if any.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.PooledObjects.ArrayBuilder`1.ToImmutableOrNull">
            <summary>
            Realizes the array.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.PooledObjects.ArrayBuilder`1.ToDowncastedImmutable``1">
            <summary>
            Realizes the array, downcasting each element to a derived type.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.PooledObjects.ArrayBuilder`1.ToImmutableAndFree">
            <summary>
            Realizes the array and disposes the builder in one operation.
            </summary>
        </member>
        <member name="T:Loretta.CodeAnalysis.PooledObjects.ArrayBuilder`1.Enumerator">
            <summary>
            struct enumerator used in foreach.
            </summary>
        </member>
        <member name="T:Loretta.CodeAnalysis.PooledObjects.ObjectPool`1">
            <summary>
            Generic implementation of object pooling pattern with predefined pool size limit. The main
            purpose is that limited number of frequently used objects can be kept in the pool for
            further recycling.
            
            Notes: 
            1) it is not the goal to keep all returned objects. Pool is not meant for storage. If there
               is no space in the pool, extra returned objects will be dropped.
            
            2) it is implied that if object was obtained from a pool, the caller will return it back in
               a relatively short time. Keeping checked out objects for long durations is ok, but 
               reduces usefulness of pooling. Just new up your own.
            
            Not returning objects to the pool in not detrimental to the pool's work, but is a bad practice. 
            Rationale: 
               If there is no intent for reusing the object, do not use pool - just use "new". 
            </summary>
        </member>
        <member name="T:Loretta.CodeAnalysis.PooledObjects.ObjectPool`1.Factory">
            <remarks>
            Not using System.Func{T} because this file is linked into the (debugger) Formatter,
            which does not have that type (since it compiles against .NET 2.0).
            </remarks>
        </member>
        <member name="M:Loretta.CodeAnalysis.PooledObjects.ObjectPool`1.Allocate">
            <summary>
            Produces an instance.
            </summary>
            <remarks>
            Search strategy is a simple linear probing which is chosen for it cache-friendliness.
            Note that Free will try to store recycled objects close to the start thus statistically 
            reducing how far we will typically search.
            </remarks>
        </member>
        <member name="M:Loretta.CodeAnalysis.PooledObjects.ObjectPool`1.Free(`0)">
            <summary>
            Returns objects to the pool.
            </summary>
            <remarks>
            Search strategy is a simple linear probing which is chosen for it cache-friendliness.
            Note that Free will try to store recycled objects close to the start thus statistically 
            reducing how far we will typically search in Allocate.
            </remarks>
        </member>
        <member name="M:Loretta.CodeAnalysis.PooledObjects.ObjectPool`1.ForgetTrackedObject(`0,`0)">
            <summary>
            Removes an object from leak tracking.  
            
            This is called when an object is returned to the pool.  It may also be explicitly 
            called if an object allocated from the pool is intentionally not being returned
            to the pool.  This can be of use with pooled arrays if the consumer wants to 
            return a larger array to the pool than was originally allocated.
            </summary>
        </member>
        <member name="T:Loretta.CodeAnalysis.PooledObjects.PooledDelegates">
            <summary>
            Provides pooled delegate instances to help avoid closure allocations for delegates that require a state argument
            with APIs that do not provide appropriate overloads with state arguments.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.PooledObjects.PooledDelegates.GetPooledAction``1(System.Action{``0},``0,System.Action@)">
             <summary>
             Gets an <see cref="T:System.Action"/> delegate, which calls <paramref name="unboundAction"/> with the specified
             <paramref name="argument"/>. The resulting <paramref name="boundAction"/> may be called any number of times
             until the returned <see cref="T:Loretta.CodeAnalysis.PooledObjects.PooledDelegates.Releaser"/> is disposed.
             </summary>
             <example>
             <para>The following example shows the use of a capturing delegate for a callback action that requires an
             argument:</para>
            
             <code>
             int x = 3;
             RunWithActionCallback(() => this.DoSomething(x));
             </code>
            
             <para>The following example shows the use of a pooled delegate to avoid capturing allocations for the same
             callback action:</para>
            
             <code>
             int x = 3;
             using var _ = GetPooledAction(arg => arg.self.DoSomething(arg.x), (self: this, x), out Action action);
             RunWithActionCallback(action);
             </code>
             </example>
             <typeparam name="TArg">The type of argument to pass to <paramref name="unboundAction"/>.</typeparam>
             <param name="unboundAction">The unbound action delegate.</param>
             <param name="argument">The argument to pass to the unbound action delegate.</param>
             <param name="boundAction">A delegate which calls <paramref name="unboundAction"/> with the specified
             <paramref name="argument"/>.</param>
             <returns>A disposable <see cref="T:Loretta.CodeAnalysis.PooledObjects.PooledDelegates.Releaser"/> which returns the object to the delegate pool.</returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.PooledObjects.PooledDelegates.GetPooledAction``2(System.Action{``0,``1},``1,System.Action{``0}@)">
             <summary>
             Gets an <see cref="T:System.Action`1"/> delegate, which calls <paramref name="unboundAction"/> with the specified
             <paramref name="argument"/>. The resulting <paramref name="boundAction"/> may be called any number of times
             until the returned <see cref="T:Loretta.CodeAnalysis.PooledObjects.PooledDelegates.Releaser"/> is disposed.
             </summary>
             <example>
             <para>The following example shows the use of a capturing delegate for a callback action that requires an
             argument:</para>
            
             <code>
             int x = 3;
             RunWithActionCallback(a => this.DoSomething(a, x));
             </code>
            
             <para>The following example shows the use of a pooled delegate to avoid capturing allocations for the same
             callback action:</para>
            
             <code>
             int x = 3;
             using var _ = GetPooledAction((a, arg) => arg.self.DoSomething(a, arg.x), (self: this, x), out Action&lt;int&gt; action);
             RunWithActionCallback(action);
             </code>
             </example>
             <typeparam name="T1">The type of the first parameter of the bound action.</typeparam>
             <typeparam name="TArg">The type of argument to pass to <paramref name="unboundAction"/>.</typeparam>
             <param name="unboundAction">The unbound action delegate.</param>
             <param name="argument">The argument to pass to the unbound action delegate.</param>
             <param name="boundAction">A delegate which calls <paramref name="unboundAction"/> with the specified
             <paramref name="argument"/>.</param>
             <returns>A disposable <see cref="T:Loretta.CodeAnalysis.PooledObjects.PooledDelegates.Releaser"/> which returns the object to the delegate pool.</returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.PooledObjects.PooledDelegates.GetPooledAction``3(System.Action{``0,``1,``2},``2,System.Action{``0,``1}@)">
             <summary>
             Gets an <see cref="T:System.Action`2"/> delegate, which calls <paramref name="unboundAction"/> with the specified
             <paramref name="argument"/>. The resulting <paramref name="boundAction"/> may be called any number of times
             until the returned <see cref="T:Loretta.CodeAnalysis.PooledObjects.PooledDelegates.Releaser"/> is disposed.
             </summary>
             <example>
             <para>The following example shows the use of a capturing delegate for a callback action that requires an
             argument:</para>
            
             <code>
             int x = 3;
             RunWithActionCallback((a, b) => this.DoSomething(a, b, x));
             </code>
            
             <para>The following example shows the use of a pooled delegate to avoid capturing allocations for the same
             callback action:</para>
            
             <code>
             int x = 3;
             using var _ = GetPooledAction((a, b, arg) => arg.self.DoSomething(a, b, arg.x), (self: this, x), out Action&lt;int, int&gt; action);
             RunWithActionCallback(action);
             </code>
             </example>
             <typeparam name="T1">The type of the first parameter of the bound action.</typeparam>
             <typeparam name="T2">The type of the second parameter of the bound action.</typeparam>
             <typeparam name="TArg">The type of argument to pass to <paramref name="unboundAction"/>.</typeparam>
             <param name="unboundAction">The unbound action delegate.</param>
             <param name="argument">The argument to pass to the unbound action delegate.</param>
             <param name="boundAction">A delegate which calls <paramref name="unboundAction"/> with the specified
             <paramref name="argument"/>.</param>
             <returns>A disposable <see cref="T:Loretta.CodeAnalysis.PooledObjects.PooledDelegates.Releaser"/> which returns the object to the delegate pool.</returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.PooledObjects.PooledDelegates.GetPooledAction``4(System.Action{``0,``1,``2,``3},``3,System.Action{``0,``1,``2}@)">
             <summary>
             Gets an <see cref="T:System.Action`3"/> delegate, which calls <paramref name="unboundAction"/> with the specified
             <paramref name="argument"/>. The resulting <paramref name="boundAction"/> may be called any number of times
             until the returned <see cref="T:Loretta.CodeAnalysis.PooledObjects.PooledDelegates.Releaser"/> is disposed.
             </summary>
             <example>
             <para>The following example shows the use of a capturing delegate for a callback action that requires an
             argument:</para>
            
             <code>
             int x = 3;
             RunWithActionCallback((a, b, c) => this.DoSomething(a, b, c, x));
             </code>
            
             <para>The following example shows the use of a pooled delegate to avoid capturing allocations for the same
             callback action:</para>
            
             <code>
             int x = 3;
             using var _ = GetPooledAction((a, b, c, arg) => arg.self.DoSomething(a, b, c, arg.x), (self: this, x), out Action&lt;int, int, int&gt; action);
             RunWithActionCallback(action);
             </code>
             </example>
             <typeparam name="T1">The type of the first parameter of the bound action.</typeparam>
             <typeparam name="T2">The type of the second parameter of the bound action.</typeparam>
             <typeparam name="T3">The type of the third parameter of the bound action.</typeparam>
             <typeparam name="TArg">The type of argument to pass to <paramref name="unboundAction"/>.</typeparam>
             <param name="unboundAction">The unbound action delegate.</param>
             <param name="argument">The argument to pass to the unbound action delegate.</param>
             <param name="boundAction">A delegate which calls <paramref name="unboundAction"/> with the specified
             <paramref name="argument"/>.</param>
             <returns>A disposable <see cref="T:Loretta.CodeAnalysis.PooledObjects.PooledDelegates.Releaser"/> which returns the object to the delegate pool.</returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.PooledObjects.PooledDelegates.GetPooledFunction``2(System.Func{``0,``1},``0,System.Func{``1}@)">
             <summary>
             Gets a <see cref="T:System.Func`1"/> delegate, which calls <paramref name="unboundFunction"/> with the
             specified <paramref name="argument"/>. The resulting <paramref name="boundFunction"/> may be called any
             number of times until the returned <see cref="T:Loretta.CodeAnalysis.PooledObjects.PooledDelegates.Releaser"/> is disposed.
             </summary>
             <example>
             <para>The following example shows the use of a capturing delegate for a predicate that requires an
             argument:</para>
            
             <code>
             int x = 3;
             RunWithPredicate(() => this.IsSomething(x));
             </code>
            
             <para>The following example shows the use of a pooled delegate to avoid capturing allocations for the same
             predicate:</para>
            
             <code>
             int x = 3;
             using var _ = GetPooledFunction(arg => arg.self.IsSomething(arg.x), (self: this, x), out Func&lt;bool&gt; predicate);
             RunWithPredicate(predicate);
             </code>
             </example>
             <typeparam name="TArg">The type of argument to pass to <paramref name="unboundFunction"/>.</typeparam>
             <typeparam name="TResult">The type of the return value of the function.</typeparam>
             <param name="unboundFunction">The unbound function delegate.</param>
             <param name="argument">The argument to pass to the unbound function delegate.</param>
             <param name="boundFunction">A delegate which calls <paramref name="unboundFunction"/> with the specified
             <paramref name="argument"/>.</param>
             <returns>A disposable <see cref="T:Loretta.CodeAnalysis.PooledObjects.PooledDelegates.Releaser"/> which returns the object to the delegate pool.</returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.PooledObjects.PooledDelegates.GetPooledFunction``3(System.Func{``0,``1,``2},``1,System.Func{``0,``2}@)">
             <summary>
             Gets a <see cref="T:System.Func`2"/> delegate, which calls <paramref name="unboundFunction"/> with the
             specified <paramref name="argument"/>. The resulting <paramref name="boundFunction"/> may be called any
             number of times until the returned <see cref="T:Loretta.CodeAnalysis.PooledObjects.PooledDelegates.Releaser"/> is disposed.
             </summary>
             <example>
             <para>The following example shows the use of a capturing delegate for a predicate that requires an
             argument:</para>
            
             <code>
             int x = 3;
             RunWithPredicate(a => this.IsSomething(a, x));
             </code>
            
             <para>The following example shows the use of a pooled delegate to avoid capturing allocations for the same
             predicate:</para>
            
             <code>
             int x = 3;
             using var _ = GetPooledFunction((a, arg) => arg.self.IsSomething(a, arg.x), (self: this, x), out Func&lt;int, bool&gt; predicate);
             RunWithPredicate(predicate);
             </code>
             </example>
             <typeparam name="T1">The type of the first parameter of the bound function.</typeparam>
             <typeparam name="TArg">The type of argument to pass to <paramref name="unboundFunction"/>.</typeparam>
             <typeparam name="TResult">The type of the return value of the function.</typeparam>
             <param name="unboundFunction">The unbound function delegate.</param>
             <param name="argument">The argument to pass to the unbound function delegate.</param>
             <param name="boundFunction">A delegate which calls <paramref name="unboundFunction"/> with the specified
             <paramref name="argument"/>.</param>
             <returns>A disposable <see cref="T:Loretta.CodeAnalysis.PooledObjects.PooledDelegates.Releaser"/> which returns the object to the delegate pool.</returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.PooledObjects.PooledDelegates.GetPooledFunction``4(System.Func{``0,``1,``2,``3},``2,System.Func{``0,``1,``3}@)">
             <summary>
             Gets a <see cref="T:System.Func`3"/> delegate, which calls <paramref name="unboundFunction"/> with the
             specified <paramref name="argument"/>. The resulting <paramref name="boundFunction"/> may be called any
             number of times until the returned <see cref="T:Loretta.CodeAnalysis.PooledObjects.PooledDelegates.Releaser"/> is disposed.
             </summary>
             <example>
             <para>The following example shows the use of a capturing delegate for a predicate that requires an
             argument:</para>
            
             <code>
             int x = 3;
             RunWithPredicate((a, b) => this.IsSomething(a, b, x));
             </code>
            
             <para>The following example shows the use of a pooled delegate to avoid capturing allocations for the same
             predicate:</para>
            
             <code>
             int x = 3;
             using var _ = GetPooledFunction((a, b, arg) => arg.self.IsSomething(a, b, arg.x), (self: this, x), out Func&lt;int, int, bool&gt; predicate);
             RunWithPredicate(predicate);
             </code>
             </example>
             <typeparam name="T1">The type of the first parameter of the bound function.</typeparam>
             <typeparam name="T2">The type of the second parameter of the bound function.</typeparam>
             <typeparam name="TArg">The type of argument to pass to <paramref name="unboundFunction"/>.</typeparam>
             <typeparam name="TResult">The type of the return value of the function.</typeparam>
             <param name="unboundFunction">The unbound function delegate.</param>
             <param name="argument">The argument to pass to the unbound function delegate.</param>
             <param name="boundFunction">A delegate which calls <paramref name="unboundFunction"/> with the specified
             <paramref name="argument"/>.</param>
             <returns>A disposable <see cref="T:Loretta.CodeAnalysis.PooledObjects.PooledDelegates.Releaser"/> which returns the object to the delegate pool.</returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.PooledObjects.PooledDelegates.GetPooledFunction``5(System.Func{``0,``1,``2,``3,``4},``3,System.Func{``0,``1,``2,``4}@)">
             <summary>
             Gets a <see cref="T:System.Func`4"/> delegate, which calls <paramref name="unboundFunction"/> with the
             specified <paramref name="argument"/>. The resulting <paramref name="boundFunction"/> may be called any
             number of times until the returned <see cref="T:Loretta.CodeAnalysis.PooledObjects.PooledDelegates.Releaser"/> is disposed.
             </summary>
             <example>
             <para>The following example shows the use of a capturing delegate for a predicate that requires an
             argument:</para>
            
             <code>
             int x = 3;
             RunWithPredicate((a, b, c) => this.IsSomething(a, b, c, x));
             </code>
            
             <para>The following example shows the use of a pooled delegate to avoid capturing allocations for the same
             predicate:</para>
            
             <code>
             int x = 3;
             using var _ = GetPooledFunction((a, b, c, arg) => arg.self.IsSomething(a, b, c, arg.x), (self: this, x), out Func&lt;int, int, int, bool&gt; predicate);
             RunWithPredicate(predicate);
             </code>
             </example>
             <typeparam name="T1">The type of the first parameter of the bound function.</typeparam>
             <typeparam name="T2">The type of the second parameter of the bound function.</typeparam>
             <typeparam name="T3">The type of the third parameter of the bound function.</typeparam>
             <typeparam name="TArg">The type of argument to pass to <paramref name="unboundFunction"/>.</typeparam>
             <typeparam name="TResult">The type of the return value of the function.</typeparam>
             <param name="unboundFunction">The unbound function delegate.</param>
             <param name="argument">The argument to pass to the unbound function delegate.</param>
             <param name="boundFunction">A delegate which calls <paramref name="unboundFunction"/> with the specified
             <paramref name="argument"/>.</param>
             <returns>A disposable <see cref="T:Loretta.CodeAnalysis.PooledObjects.PooledDelegates.Releaser"/> which returns the object to the delegate pool.</returns>
        </member>
        <member name="T:Loretta.CodeAnalysis.PooledObjects.PooledDelegates.Releaser">
             <summary>
             A releaser for a pooled delegate.
             </summary>
             <remarks>
             <para>This type is intended for use as the resource of a <c>using</c> statement. When used in this manner,
             <see cref="M:Loretta.CodeAnalysis.PooledObjects.PooledDelegates.Releaser.Dispose"/> should not be called explicitly.</para>
            
             <para>If used without a <c>using</c> statement, calling <see cref="M:Loretta.CodeAnalysis.PooledObjects.PooledDelegates.Releaser.Dispose"/> is optional. If the call is
             omitted, the object will not be returned to the pool. The behavior of this type if <see cref="M:Loretta.CodeAnalysis.PooledObjects.PooledDelegates.Releaser.Dispose"/> is
             called multiple times is undefined.</para>
             </remarks>
        </member>
        <member name="T:Loretta.CodeAnalysis.PooledObjects.PooledStringBuilder">
            <summary>
            The usage is:
                   var inst = PooledStringBuilder.GetInstance();
                   var sb = inst.builder;
                   ... Do Stuff...
                   ... sb.ToString() ...
                   inst.Free();
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.PooledObjects.PooledStringBuilder.CreatePool(System.Int32)">
            <summary>
            If someone need to create a private pool
            </summary>
            <param name="size">The size of the pool.</param>
            <returns></returns>
        </member>
        <member name="T:Loretta.CodeAnalysis.RealParser">
            <summary>
            A set of utilities for converting from a decimal floating-point literal string to its IEEE float
            or double representation, which considers all digits significant and correctly rounds according to
            the IEEE round-to-nearest-ties-to-even mode. This code does not support a leading sign character,
            as that is not part of the C# or VB floating-point literal lexical syntax.
            
            If you change this code, please run the set of long-running random tests in the solution
            RandomRealParserTests.sln. That solution is not included in Roslyn.sln as it is Windows-specific.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.RealParser.TryParseDouble(System.String,System.Double@)">
            <summary>
            Try parsing a correctly-formatted double floating-point literal into the nearest representable double
            using IEEE round-to-nearest-ties-to-even rounding mode. Behavior is not defined for inputs that are
            not valid C# floating-point literals.
            </summary>
            <param name="s">The decimal floating-point constant's string</param>
            <param name="d">The nearest double value, if conversion succeeds</param>
            <returns>True if the input was converted; false if there was an overflow</returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.RealParser.TryParseFloat(System.String,System.Single@)">
            <summary>
            Try parsing a correctly-formatted float floating-point literal into the nearest representable float
            using IEEE round-to-nearest-ties-to-even rounding mode. Behavior is not defined for inputs that are
            not valid C# floating-point literals.
            </summary>
            <param name="s">The float floating-point constant's string</param>
            <param name="f">The nearest float value, if conversion succeeds</param>
            <returns>True if the input was converted; false if there was an overflow</returns>
        </member>
        <member name="T:Loretta.CodeAnalysis.RealParser.FloatingPointType">
            <summary>
            Properties of an IEEE floating-point representation.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.RealParser.FloatingPointType.AssembleFloatingPointValue(System.UInt64,System.Int32,System.Boolean,System.UInt64@)">
            <summary>
            Converts the floating point value 0.mantissa * 2^exponent into the  
            correct form for the FloatingPointType and stores the bits of the resulting value  
            into the result object.  
            The caller must ensure that the mantissa and exponent are correctly computed  
            such that either [1] the most significant bit of the mantissa is in the  
            correct position for the FloatingType, or [2] the exponent has been correctly  
            adjusted to account for the shift of the mantissa that will be required.  
             
            This function correctly handles range errors and stores a zero or infinity in  
            the result object on underflow and overflow errors, respectively.  This  
            function correctly forms denormal numbers when required.  
             
            If the provided mantissa has more bits of precision than can be stored in the  
            result object, the mantissa is rounded to the available precision.  Thus, if  
            possible, the caller should provide a mantissa with at least one more bit of  
            precision than is required, to ensure that the mantissa is correctly rounded.  
            (The caller should not round the mantissa before calling this function.)  
            </summary>
            <param name="initialMantissa">The bits of the mantissa</param>
            <param name="initialExponent">The exponent</param>
            <param name="hasZeroTail">Whether there are any nonzero bits past the supplied mantissa</param>
            <param name="result">Where the bits of the floating-point number are stored</param>
            <returns>A status indicating whether the conversion succeeded and why</returns>
        </member>
        <member name="T:Loretta.CodeAnalysis.RealParser.FloatFloatingPointType">
            <summary>
            Properties of a C# float.
            </summary>
        </member>
        <member name="T:Loretta.CodeAnalysis.RealParser.DoubleFloatingPointType">
            <summary>
            Properties of a C# double.
            </summary>
        </member>
        <member name="T:Loretta.CodeAnalysis.RealParser.DecimalFloatingPointString">
            <summary>
            This type is used to hold a partially-parsed string representation of a  
            floating point number.  The number is stored in the following form:  
             <pre>
                0.Mantissa * 10^Exponent
             </pre>
            The Mantissa buffer stores the mantissa digits as characters in a string.  
            The MantissaCount gives the number of digits present in the Mantissa buffer.
            There shall be neither leading nor trailing zero digits in the Mantissa.
            Note that this represents only nonnegative floating-point literals; the
            negative sign in C# and VB is actually a separate unary negation operator.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.RealParser.DecimalFloatingPointString.FromSource(System.String)">
            <summary>
            Create a DecimalFloatingPointString from a string representing a floating-point literal.
            </summary>
            <param name="source">The text of the floating-point literal</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.RealParser.ConvertDecimalToFloatingPointBits(Loretta.CodeAnalysis.RealParser.DecimalFloatingPointString,Loretta.CodeAnalysis.RealParser.FloatingPointType,System.UInt64@)">
            <summary>
            Convert a DecimalFloatingPointString to the bits of the given floating-point type.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.RealParser.ConvertBigIntegerToFloatingPointBits(System.Byte[],System.UInt32,System.Boolean,Loretta.CodeAnalysis.RealParser.FloatingPointType,System.UInt64@)">
            <summary>
            This function is part of the fast track for integer floating point strings.  
            It takes an integer stored as an array of bytes (lsb first) and converts the value into its FloatingType  
            representation, storing the bits into "result".  If the value is not  
            representable, +/-infinity is stored and overflow is reported (since this  
            function only deals with integers, underflow is impossible).  
            </summary>
            <param name="integerValueAsBytes">the bits of the integer, least significant bits first</param>
            <param name="integerBitsOfPrecision">the number of bits of precision in integerValueAsBytes</param>
            <param name="hasNonzeroFractionalPart">whether there are nonzero digits after the decimal</param>
            <param name="type">the kind of real number to build</param>
            <param name="result">the result</param>
            <returns>An indicator of the kind of result</returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.RealParser.AccumulateDecimalDigitsIntoBigInteger(Loretta.CodeAnalysis.RealParser.DecimalFloatingPointString,System.UInt32,System.UInt32)">
            <summary>
            Parse a sequence of digits into a BigInteger.
            </summary>
            <param name="data">The DecimalFloatingPointString containing the digits in its Mantissa</param>
            <param name="integer_first_index">The index of the first digit to convert</param>
            <param name="integer_last_index">The index just past the last digit to convert</param>
            <returns>The BigInteger result</returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.RealParser.CountSignificantBits(System.UInt64)">
            <summary>
            Return the number of significant bits set. 
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.RealParser.CountSignificantBits(System.Byte)">
            <summary>
            Return the number of significant bits set. 
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.RealParser.CountSignificantBits(System.Numerics.BigInteger,System.Byte[]@)">
            <summary>
            Return the number of significant bits set. 
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.RealParser.CountSignificantBits(System.Numerics.BigInteger)">
            <summary>
            Return the number of significant bits set. 
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.RealParser.RightShiftWithRounding(System.UInt64,System.Int32,System.Boolean)">
            <summary>
            Computes value / 2^shift, then rounds the result according to the current  
            rounding mode.  By the time we call this function, we will already have  
            discarded most digits.  The caller must pass true for has_zero_tail if  
            all discarded bits were zeroes.  
            </summary>
            <param name="value">The value to shift</param>
            <param name="shift">The amount of shift</param>
            <param name="hasZeroTail">Whether there are any less significant nonzero bits in the value</param>
            <returns></returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.RealParser.ShouldRoundUp(System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Determines whether a mantissa should be rounded up in the  
            round-to-nearest-ties-to-even mode given [1] the value of the least  
            significant bit of the mantissa, [2] the value of the next bit after  
            the least significant bit (the "round" bit) and [3] whether any  
            trailing bits after the round bit are set.  
             
            The mantissa is treated as an unsigned integer magnitude.  
             
            For this function, "round up" is defined as "increase the magnitude" of the  
            mantissa.
            </summary>
            <param name="lsbBit">the least-significant bit of the representable value</param>
            <param name="roundBit">the bit following the least-significant bit</param>
            <param name="hasTailBits">true if there are any (less significant) bits set following roundBit</param>
            <returns></returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.RealParser.ShiftLeft(System.Numerics.BigInteger@,System.UInt32)">
            <summary>
            Multiply a BigInteger by the given power of two.
            </summary>
            <param name="number">The BigInteger to multiply by a power of two and replace with the product</param>
            <param name="shift">The power of two to multiply it by</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.RealParser.MultiplyByPowerOfTen(System.Numerics.BigInteger@,System.UInt32)">
            <summary>
            Multiply a BigInteger by the given power of ten.
            </summary>
            <param name="number">The BigInteger to multiply by a power of ten and replace with the product</param>
            <param name="power">The power of ten to multiply it by</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.RealParser.FloatToInt32Bits(System.Single)">
            <summary>
            Convert a float value to the bits of its representation
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.RealParser.Int32BitsToFloat(System.UInt32)">
            <summary>
            Convert the bits of its representation to a float
            </summary>
        </member>
        <member name="T:Loretta.CodeAnalysis.RealParser.FloatUnion">
            <summary>
            A union used to convert between a float and the bits of its representation
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.ObjectDisplayExtensions.IncludesOption(Loretta.CodeAnalysis.ObjectDisplayOptions,Loretta.CodeAnalysis.ObjectDisplayOptions)">
            <summary>
            Determines if a flag is set on the <see cref="T:Loretta.CodeAnalysis.ObjectDisplayOptions"/> enum.
            </summary>
            <param name="options">The value to check.</param>
            <param name="flag">An enum field that specifies the flag.</param>
            <returns>Whether the <paramref name="flag"/> is set on the <paramref name="options"/>.</returns>
        </member>
        <member name="T:Loretta.CodeAnalysis.ObjectDisplayOptions">
            <summary>
            Specifies the options for how generics are displayed in the description of a symbol.
            </summary>
        </member>
        <member name="F:Loretta.CodeAnalysis.ObjectDisplayOptions.None">
            <summary>
            Format object using default options.
            </summary>
        </member>
        <member name="F:Loretta.CodeAnalysis.ObjectDisplayOptions.UseHexadecimalNumbers">
            <summary>
            Whether or not to display integral literals in hexadecimal.
            </summary>
        </member>
        <member name="F:Loretta.CodeAnalysis.ObjectDisplayOptions.UseQuotes">
            <summary>
            Whether or not to quote string literals.
            </summary>
        </member>
        <member name="F:Loretta.CodeAnalysis.ObjectDisplayOptions.EscapeNonPrintableCharacters">
            <summary>
            Replace non-printable (e.g. control) characters with dedicated (e.g. \t) or unicode (\u0001) escape sequences.
            </summary>
        </member>
        <member name="F:Loretta.CodeAnalysis.ObjectDisplayOptions.EscapeWithUtf8">
            <summary>
            Escapes characters using their UTF8 encoding instead of unicode escapes.
            </summary>
        </member>
        <member name="T:Loretta.CodeAnalysis.LanguageNames">
            <summary>
            A class that provides constants for common language names.
            </summary>
        </member>
        <member name="F:Loretta.CodeAnalysis.LanguageNames.CSharp">
            <summary>
            The common name used for the C# language.
            </summary>
        </member>
        <member name="F:Loretta.CodeAnalysis.LanguageNames.VisualBasic">
            <summary>
            The common name used for the Visual Basic language.
            </summary>
        </member>
        <member name="F:Loretta.CodeAnalysis.LanguageNames.FSharp">
            <summary>
            The common name used for the F# language.
            </summary>
            <remarks>
            F# is not a supported compile target for the Roslyn compiler.
            </remarks>
        </member>
        <member name="F:Loretta.CodeAnalysis.LanguageNames.Lua">
            <summary>
            The common name used for the Lua language.
            </summary>
        </member>
        <member name="T:Loretta.CodeAnalysis.AnnotationExtensions">
            <summary>
            Extension methods for dealing with annotations.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.AnnotationExtensions.WithAdditionalAnnotations``1(``0,Loretta.CodeAnalysis.SyntaxAnnotation[])">
            <summary>
            Creates a new node identical to this node with the specified annotations attached.
            </summary>
            <param name="node">Original node.</param>
            <param name="annotations">Annotations to be added to the new node.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.AnnotationExtensions.WithAdditionalAnnotations``1(``0,System.Collections.Generic.IEnumerable{Loretta.CodeAnalysis.SyntaxAnnotation})">
            <summary>
            Creates a new node identical to this node with the specified annotations attached.
            </summary>
            <param name="node">Original node.</param>
            <param name="annotations">Annotations to be added to the new node.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.AnnotationExtensions.WithoutAnnotations``1(``0,Loretta.CodeAnalysis.SyntaxAnnotation[])">
            <summary>
            Creates a new node identical to this node with the specified annotations removed.
            </summary>
            <param name="node">Original node.</param>
            <param name="annotations">Annotations to be removed from the new node.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.AnnotationExtensions.WithoutAnnotations``1(``0,System.Collections.Generic.IEnumerable{Loretta.CodeAnalysis.SyntaxAnnotation})">
            <summary>
            Creates a new node identical to this node with the specified annotations removed.
            </summary>
            <param name="node">Original node.</param>
            <param name="annotations">Annotations to be removed from the new node.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.AnnotationExtensions.WithoutAnnotations``1(``0,System.String)">
            <summary>
            Creates a new node identical to this node with the annotations of the specified kind removed.
            </summary>
            <param name="node">Original node.</param>
            <param name="annotationKind">The kind of annotation to remove.</param>
        </member>
        <member name="T:Loretta.CodeAnalysis.ChildSyntaxList">
            <summary>
            A list containing all children of a syntax node.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.ChildSyntaxList.Count">
            <summary>
            Gets the number of children contained in the <see cref="T:Loretta.CodeAnalysis.ChildSyntaxList"/>.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.ChildSyntaxList.Item(System.Int32)">
            <summary>Gets the child at the specified index.</summary>
            <param name="index">The zero-based index of the child to get.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
              <paramref name="index"/> is less than 0.-or-<paramref name="index" /> is equal to or greater than <see cref="P:Loretta.CodeAnalysis.ChildSyntaxList.Count"/>. </exception>
        </member>
        <member name="M:Loretta.CodeAnalysis.ChildSyntaxList.ItemInternal(Loretta.CodeAnalysis.SyntaxNode,System.Int32)">
            <summary>
            internal indexer that does not verify index.
            Used when caller has already ensured that index is within bounds.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.ChildSyntaxList.ChildThatContainsPosition(Loretta.CodeAnalysis.SyntaxNode,System.Int32)">
            <summary>
            Locate the node or token that is a child of the given <see cref="T:Loretta.CodeAnalysis.SyntaxNode"/> and contains the given position.
            </summary>
            <param name="node">The <see cref="T:Loretta.CodeAnalysis.SyntaxNode"/> to search.</param>
            <param name="targetPosition">The position.</param>
            <returns>The node or token that spans the given position.</returns>
            <remarks>
            Assumes that <paramref name="targetPosition"/> is within the span of <paramref name="node"/>.
            </remarks>
        </member>
        <member name="M:Loretta.CodeAnalysis.ChildSyntaxList.ItemInternalAsNode(Loretta.CodeAnalysis.SyntaxNode,System.Int32)">
            <summary>
            internal indexer that does not verify index.
            Used when caller has already ensured that index is within bounds.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.ChildSyntaxList.Any">
            <summary>
            Checks whether this list contains any elements.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.ChildSyntaxList.First">
            <summary>
            Returns the first child in the list.
            </summary>
            <returns>The first child in the list.</returns>
            <exception cref="T:System.InvalidOperationException">The list is empty.</exception>    
        </member>
        <member name="M:Loretta.CodeAnalysis.ChildSyntaxList.Last">
            <summary>
            Returns the last child in the list.
            </summary>
            <returns>The last child in the list.</returns>
            <exception cref="T:System.InvalidOperationException">The list is empty.</exception>    
        </member>
        <member name="M:Loretta.CodeAnalysis.ChildSyntaxList.Reverse">
            <summary>
            Returns a list which contains all children of <see cref="T:Loretta.CodeAnalysis.ChildSyntaxList"/> in reversed order.
            </summary>
            <returns><see cref="T:Loretta.CodeAnalysis.ChildSyntaxList.Reversed"/> which contains all children of <see cref="T:Loretta.CodeAnalysis.ChildSyntaxList"/> in reversed order</returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.ChildSyntaxList.GetEnumerator">
            <summary>Returns an enumerator that iterates through the <see cref="T:Loretta.CodeAnalysis.ChildSyntaxList"/>.</summary>
            <returns>A <see cref="T:Loretta.CodeAnalysis.ChildSyntaxList.Enumerator"/> for the <see cref="T:Loretta.CodeAnalysis.ChildSyntaxList"/>.</returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.ChildSyntaxList.Equals(System.Object)">
            <summary>Determines whether the specified object is equal to the current instance.</summary>
            <returns>true if the specified object is a <see cref="T:Loretta.CodeAnalysis.ChildSyntaxList" /> structure and is equal to the current instance; otherwise, false.</returns>
            <param name="obj">The object to be compared with the current instance.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.ChildSyntaxList.Equals(Loretta.CodeAnalysis.ChildSyntaxList)">
            <summary>Determines whether the specified <see cref="T:Loretta.CodeAnalysis.ChildSyntaxList" /> structure is equal to the current instance.</summary>
            <returns>true if the specified <see cref="T:Loretta.CodeAnalysis.ChildSyntaxList" /> structure is equal to the current instance; otherwise, false.</returns>
            <param name="other">The <see cref="T:Loretta.CodeAnalysis.ChildSyntaxList" /> structure to be compared with the current instance.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.ChildSyntaxList.GetHashCode">
            <summary>Returns the hash code for the current instance.</summary>
            <returns>A 32-bit signed integer hash code.</returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.ChildSyntaxList.op_Equality(Loretta.CodeAnalysis.ChildSyntaxList,Loretta.CodeAnalysis.ChildSyntaxList)">
            <summary>Indicates whether two <see cref="T:Loretta.CodeAnalysis.ChildSyntaxList" /> structures are equal.</summary>
            <returns>true if <paramref name="list1" /> is equal to <paramref name="list2" />; otherwise, false.</returns>
            <param name="list1">The <see cref="T:Loretta.CodeAnalysis.ChildSyntaxList" /> structure on the left side of the equality operator.</param>
            <param name="list2">The <see cref="T:Loretta.CodeAnalysis.ChildSyntaxList" /> structure on the right side of the equality operator.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.ChildSyntaxList.op_Inequality(Loretta.CodeAnalysis.ChildSyntaxList,Loretta.CodeAnalysis.ChildSyntaxList)">
            <summary>Indicates whether two <see cref="T:Loretta.CodeAnalysis.ChildSyntaxList" /> structures are unequal.</summary>
            <returns>true if <paramref name="list1" /> is equal to <paramref name="list2" />; otherwise, false.</returns>
            <param name="list1">The <see cref="T:Loretta.CodeAnalysis.ChildSyntaxList" /> structure on the left side of the inequality operator.</param>
            <param name="list2">The <see cref="T:Loretta.CodeAnalysis.ChildSyntaxList" /> structure on the right side of the inequality operator.</param>
        </member>
        <member name="T:Loretta.CodeAnalysis.ChildSyntaxList.Enumerator">
            <summary>Enumerates the elements of a <see cref="T:Loretta.CodeAnalysis.ChildSyntaxList" />.</summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.ChildSyntaxList.Enumerator.MoveNext">
            <summary>Advances the enumerator to the next element of the <see cref="T:Loretta.CodeAnalysis.ChildSyntaxList" />.</summary>
            <returns>true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.</returns>
        </member>
        <member name="P:Loretta.CodeAnalysis.ChildSyntaxList.Enumerator.Current">
            <summary>Gets the element at the current position of the enumerator.</summary>
            <returns>The element in the <see cref="T:Loretta.CodeAnalysis.ChildSyntaxList" /> at the current position of the enumerator.</returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.ChildSyntaxList.Enumerator.Reset">
            <summary>Sets the enumerator to its initial position, which is before the first element in the collection.</summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.ChildSyntaxList.EnumeratorImpl.Current">
            <summary>
            Gets the element in the collection at the current position of the enumerator.
            </summary>
            <returns>
            The element in the collection at the current position of the enumerator.
              </returns>
        </member>
        <member name="P:Loretta.CodeAnalysis.ChildSyntaxList.EnumeratorImpl.System#Collections#IEnumerator#Current">
            <summary>
            Gets the element in the collection at the current position of the enumerator.
            </summary>
            <returns>
            The element in the collection at the current position of the enumerator.
              </returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.ChildSyntaxList.EnumeratorImpl.MoveNext">
            <summary>
            Advances the enumerator to the next element of the collection.
            </summary>
            <returns>
            true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.
            </returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.ChildSyntaxList.EnumeratorImpl.Reset">
            <summary>
            Sets the enumerator to its initial position, which is before the first element in the collection.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.ChildSyntaxList.EnumeratorImpl.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="T:Loretta.CodeAnalysis.ChildSyntaxList.Reversed">
            <summary>
            An enumerator that enumerates the list in reverse order.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.ChildSyntaxList.Reversed.GetEnumerator">
            <summary>
            Returns the enumerator for this list.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.ChildSyntaxList.Reversed.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Loretta.CodeAnalysis.ChildSyntaxList.Reversed.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Loretta.CodeAnalysis.ChildSyntaxList.Reversed.Equals(Loretta.CodeAnalysis.ChildSyntaxList.Reversed)">
            <inheritdoc/>
        </member>
        <member name="M:Loretta.CodeAnalysis.ChildSyntaxList.Reversed.op_Equality(Loretta.CodeAnalysis.ChildSyntaxList.Reversed,Loretta.CodeAnalysis.ChildSyntaxList.Reversed)">
            <summary>
            Checks whether two reversed lists are equal.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.ChildSyntaxList.Reversed.op_Inequality(Loretta.CodeAnalysis.ChildSyntaxList.Reversed,Loretta.CodeAnalysis.ChildSyntaxList.Reversed)">
            <summary>
            Checks whether two reversed lists are not equal.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="T:Loretta.CodeAnalysis.ChildSyntaxList.Reversed.Enumerator">
            <summary>
            Enumerates the nodes in this reversed children list.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.ChildSyntaxList.Reversed.Enumerator.MoveNext">
            <summary>
            Moves to the next element.
            </summary>
            <returns>Whether there was another element to move to.</returns>
        </member>
        <member name="P:Loretta.CodeAnalysis.ChildSyntaxList.Reversed.Enumerator.Current">
            <summary>
            The element the enumerator is at.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.ChildSyntaxList.Reversed.Enumerator.Reset">
            <summary>
            Resets the enumerator to the last element.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.ChildSyntaxList.Reversed.EnumeratorImpl.Current">
            <summary>
            Gets the element in the collection at the current position of the enumerator.
            </summary>
            <returns>
            The element in the collection at the current position of the enumerator.
              </returns>
        </member>
        <member name="P:Loretta.CodeAnalysis.ChildSyntaxList.Reversed.EnumeratorImpl.System#Collections#IEnumerator#Current">
            <summary>
            Gets the element in the collection at the current position of the enumerator.
            </summary>
            <returns>
            The element in the collection at the current position of the enumerator.
              </returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.ChildSyntaxList.Reversed.EnumeratorImpl.MoveNext">
            <summary>
            Advances the enumerator to the next element of the collection.
            </summary>
            <returns>
            true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.
            </returns>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception>
        </member>
        <member name="M:Loretta.CodeAnalysis.ChildSyntaxList.Reversed.EnumeratorImpl.Reset">
            <summary>
            Sets the enumerator to its initial position, which is before the first element in the collection.
            </summary>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception>
        </member>
        <member name="M:Loretta.CodeAnalysis.ChildSyntaxList.Reversed.EnumeratorImpl.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList`1.GetSeparator(System.Int32)">
            <summary>
            Gets the separator at the given index in this list.
            </summary>
            <param name="index">The index.</param>
            <returns></returns>
        </member>
        <member name="P:Loretta.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxListBuilder`1.UnderlyingBuilder">
            <summary>
            WARN WARN WARN: This should be used with extreme caution - the underlying builder does
            not give any indication that it is from a separated syntax list but the constraints
            (node, token, node, token, ...) should still be maintained.
            </summary>
            <remarks>
            In order to avoid creating a separate pool of SeparatedSyntaxListBuilders, we expose
            our underlying SyntaxListBuilder to SyntaxListPool.
            </remarks>
        </member>
        <member name="M:Loretta.CodeAnalysis.Syntax.InternalSyntax.SyntaxList.WithLotsOfChildren.FindSlotIndexContainingOffset(System.Int32)">
            <summary>
            Find the slot that contains the given offset.
            </summary>
            <param name="offset">The target offset. Must be between 0 and <see cref="P:Loretta.CodeAnalysis.GreenNode.FullWidth"/>.</param>
            <returns>The slot index of the slot containing the given offset.</returns>
            <remarks>
            This implementation uses a binary search to find the first slot that contains
            the given offset.
            </remarks>
        </member>
        <member name="T:Loretta.CodeAnalysis.Syntax.InternalSyntax.GreenStats">
            <summary>
            Provides caching functionality for green nonterminals with up to 3 children.
            Example:
                When constructing a node with given kind, flags, child1 and child2, we can look up 
                in the cache whether we already have a node that contains same kind, flags, 
                child1 and child2 and use that.
                
                For the purpose of children comparison, reference equality is used as a much cheaper 
                alternative to the structural/recursive equality. This implies that in order to de-duplicate
                a node to a cache node, the children of two nodes must be already de-duplicated.     
                When adding a node to the cache we verify that cache does contain node's children,
                since otherwise there is no reason for the node to be used.
                Tokens/nulls are for this purpose considered deduplicated. Indeed most of the tokens
                are deduplicated via quick-scanner caching, so we just assume they all are.
                
                As a result of above, "fat" nodes with 4 or more children or their recursive parents
                will never be in the cache. This naturally limits the typical single cache item to be 
                a relatively simple expression. We do not want the cache to be completely unbounded 
                on the item size. 
                While it still may be possible to store a gigantic nested binary expression, 
                it should be a rare occurrence.
                
                We only consider "normal" nodes to be cacheable. 
                Nodes with diagnostics/annotations/directives/skipped, etc... have more complicated identity 
                and are not likely to be repetitive.
                
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.GreenNode.EnumerateNodes">
            <summary>
            Enumerates all nodes of the tree rooted by this node (including this node).
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.GreenNode.FindSlotIndexContainingOffset(System.Int32)">
            <summary>
            Find the slot that contains the given offset.
            </summary>
            <param name="offset">The target offset. Must be between 0 and <see cref="P:Loretta.CodeAnalysis.GreenNode.FullWidth"/>.</param>
            <returns>The slot index of the slot containing the given offset.</returns>
            <remarks>
            The base implementation is a linear search. This should be overridden
            if a derived class can implement it more efficiently.
            </remarks>
        </member>
        <member name="M:Loretta.CodeAnalysis.GreenNode.AddError(Loretta.CodeAnalysis.DiagnosticInfo)">
            <summary>
            Add an error to the given node, creating a new node that is the same except it has no parent,
            and has the given error attached to it. The error span is the entire span of this node.
            </summary>
            <param name="err">The error to attach to this node</param>
            <returns>A new node, with no parent, that has this error added to it.</returns>
            <remarks>Since nodes are immutable, the only way to create nodes with errors attached is to create a node without an error,
            then add an error with this method to create another node.</remarks>
        </member>
        <member name="T:Loretta.CodeAnalysis.ICompilationUnitSyntax">
             <summary>
             Interface implemented by any node that is the root 'CompilationUnit' of a <see cref="T:Loretta.CodeAnalysis.SyntaxTree"/>.  i.e. 
             any node returned by <see cref="M:Loretta.CodeAnalysis.SyntaxTree.GetRoot(System.Threading.CancellationToken)"/> where <see cref="P:Loretta.CodeAnalysis.SyntaxTree.HasCompilationUnitRoot"/>
             is <see langword="true"/> will implement this interface.
            
             This interface provides a common way to both easily find the root of a <see cref="T:Loretta.CodeAnalysis.SyntaxTree"/>
             given any <see cref="T:Loretta.CodeAnalysis.SyntaxNode"/>, as well as a common way for handling the special 
             <see cref="P:Loretta.CodeAnalysis.ICompilationUnitSyntax.EndOfFileToken"/> that is needed to store all final trivia in a <see cref="T:Loretta.CodeAnalysis.Text.SourceText"/>
             that is not owned by any other <see cref="T:Loretta.CodeAnalysis.SyntaxToken"/>.
             </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.ICompilationUnitSyntax.EndOfFileToken">
            <summary>
            Represents the end of the source file. This <see cref="T:Loretta.CodeAnalysis.SyntaxToken"/> may have
            <see cref="T:Loretta.CodeAnalysis.SyntaxTrivia"/> (whitespace, comments, directives) attached to it.
            </summary>
        </member>
        <member name="T:Loretta.CodeAnalysis.IStructuredTriviaSyntax">
            <summary>
            Represents the root node of a structured trivia tree (for example, a preprocessor directive
            or a documentation comment). From this root node you can traverse back up to the containing
            trivia in the outer tree that contains it.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.IStructuredTriviaSyntax.ParentTrivia">
            <summary>
            Returns the parent trivia syntax for this structured trivia syntax.
            </summary>
            <returns>The parent trivia syntax for this structured trivia syntax.</returns>
        </member>
        <member name="T:Loretta.CodeAnalysis.SeparatedSyntaxList`1">
            <summary>
            Represents a list of nodes separated by one token.
            May have a trailing node.
            </summary>
            <typeparam name="TNode"></typeparam>
        </member>
        <member name="P:Loretta.CodeAnalysis.SeparatedSyntaxList`1.Count">
            <summary>
            The amount of nodes contained in this list.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.SeparatedSyntaxList`1.SeparatorCount">
            <summary>
            The amount of separators contained in this list.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.SeparatedSyntaxList`1.Item(System.Int32)">
            <summary>
            Obtains a node from this list at the provided index.
            </summary>
            <param name="index"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:Loretta.CodeAnalysis.SeparatedSyntaxList`1.GetSeparator(System.Int32)">
            <summary>
            Gets the separator at the given index in this list.
            </summary>
            <param name="index">The index.</param>
            <returns></returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.SeparatedSyntaxList`1.GetSeparators">
            <summary>
            Returns the sequence of just the separator tokens.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.SeparatedSyntaxList`1.FullSpan">
            <summary>
            The absolute span of the list elements in characters, including the leading and trailing trivia of the first and last elements.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.SeparatedSyntaxList`1.Span">
            <summary>
            The absolute span of the list elements in characters, not including the leading and trailing trivia of the first and last elements.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SeparatedSyntaxList`1.ToString">
            <summary>
            Returns the string representation of the nodes in this list including separators but not including 
            the first node's leading trivia and the last node or token's trailing trivia.
            </summary>
            <returns>
            The string representation of the nodes in this list including separators but not including 
            the first node's leading trivia and the last node or token's trailing trivia.
            </returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.SeparatedSyntaxList`1.ToFullString">
            <summary>
            Returns the full string representation of the nodes in this list including separators, 
            the first node's leading trivia, and the last node or token's trailing trivia.
            </summary>
            <returns>
            The full string representation of the nodes in this list including separators including separators,
            the first node's leading trivia, and the last node or token's trailing trivia.
            </returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.SeparatedSyntaxList`1.First">
            <summary>
            Returns the first node in this list.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.SeparatedSyntaxList`1.FirstOrDefault">
            <summary>
            Returns the first node in this list if any, otherwise returns
            the default value for the type of node.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.SeparatedSyntaxList`1.Last">
            <summary>
            Returns the last element in this list.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.SeparatedSyntaxList`1.LastOrDefault">
            <summary>
            Returns the last element in this list if any, otherwise returns
            the default value for the node type.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.SeparatedSyntaxList`1.Contains(`0)">
            <summary>
            Returns whether this list contains the provided node.
            </summary>
            <param name="node"></param>
            <returns></returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.SeparatedSyntaxList`1.IndexOf(`0)">
            <summary>
            Returns the index of the provided node in this list.
            </summary>
            <param name="node"></param>
            <returns>-1 if the node was not found.</returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.SeparatedSyntaxList`1.IndexOf(System.Func{`0,System.Boolean})">
            <summary>
            Returns the index of the first node that passes the provided predicate in this list.
            </summary>
            <param name="predicate"></param>
            <returns>-1 if not found.</returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.SeparatedSyntaxList`1.LastIndexOf(`0)">
            <summary>
            Returns the index of the last node that is equal to the provided one.
            </summary>
            <param name="node"></param>
            <returns>-1 if not found.</returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.SeparatedSyntaxList`1.LastIndexOf(System.Func{`0,System.Boolean})">
            <summary>
            Returns the index of the last node that passes the provided predicate in this list.
            </summary>
            <param name="predicate"></param>
            <returns>-1 if not found.</returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.SeparatedSyntaxList`1.Any">
            <summary>
            Returns whether this list contains any elements.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.SeparatedSyntaxList`1.Any(System.Func{`0,System.Boolean})">
            <summary>
            Returns whether this list contains any elements that pass the provided predicate.
            </summary>
            <param name="predicate"></param>
            <returns></returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.SeparatedSyntaxList`1.GetWithSeparators">
            <summary>
            Returns the entire list including the separators.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.SeparatedSyntaxList`1.op_Equality(Loretta.CodeAnalysis.SeparatedSyntaxList{`0},Loretta.CodeAnalysis.SeparatedSyntaxList{`0})">
            <summary>
            Checks whether a list is equal to another.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.SeparatedSyntaxList`1.op_Inequality(Loretta.CodeAnalysis.SeparatedSyntaxList{`0},Loretta.CodeAnalysis.SeparatedSyntaxList{`0})">
            <summary>
            Checks whether two lists are not equal.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.SeparatedSyntaxList`1.Equals(Loretta.CodeAnalysis.SeparatedSyntaxList{`0})">
            <inheritdoc/>
        </member>
        <member name="M:Loretta.CodeAnalysis.SeparatedSyntaxList`1.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Loretta.CodeAnalysis.SeparatedSyntaxList`1.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Loretta.CodeAnalysis.SeparatedSyntaxList`1.Add(`0)">
            <summary>
            Creates a new list with the specified node added to the end.
            </summary>
            <param name="node">The node to add.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SeparatedSyntaxList`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Creates a new list with the specified nodes added to the end.
            </summary>
            <param name="nodes">The nodes to add.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SeparatedSyntaxList`1.Insert(System.Int32,`0)">
            <summary>
            Creates a new list with the specified node inserted at the index.
            </summary>
            <param name="index">The index to insert at.</param>
            <param name="node">The node to insert.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SeparatedSyntaxList`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Creates a new list with the specified nodes inserted at the index.
            </summary>
            <param name="index">The index to insert at.</param>
            <param name="nodes">The nodes to insert.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SeparatedSyntaxList`1.RemoveAt(System.Int32)">
            <summary>
            Creates a new list with the element at the specified index removed.
            </summary>
            <param name="index">The index of the element to remove.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SeparatedSyntaxList`1.Remove(`0)">
            <summary>
            Creates a new list with specified element removed.
            </summary>
            <param name="node">The element to remove.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SeparatedSyntaxList`1.Replace(`0,`0)">
            <summary>
            Creates a new list with the specified element replaced by the new node.
            </summary>
            <param name="nodeInList">The element to replace.</param>
            <param name="newNode">The new node.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SeparatedSyntaxList`1.ReplaceRange(`0,System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Creates a new list with the specified element replaced by the new nodes.
            </summary>
            <param name="nodeInList">The element to replace.</param>
            <param name="newNodes">The new nodes.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SeparatedSyntaxList`1.ReplaceSeparator(Loretta.CodeAnalysis.SyntaxToken,Loretta.CodeAnalysis.SyntaxToken)">
            <summary>
            Creates a new list with the specified separator token replaced with the new separator.
            </summary>
            <param name="separatorToken">The separator token to be replaced.</param>
            <param name="newSeparator">The new separator token.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SeparatedSyntaxList`1.GetEnumerator">
            <summary>
            Returns the enumerator for this list.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.SeparatedSyntaxList`1.op_Implicit(Loretta.CodeAnalysis.SeparatedSyntaxList{`0})~Loretta.CodeAnalysis.SeparatedSyntaxList{Loretta.CodeAnalysis.SyntaxNode}">
            <summary>
            Converts a typed node list into an opaquely typed node list.
            </summary>
            <param name="nodes"></param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SeparatedSyntaxList`1.op_Implicit(Loretta.CodeAnalysis.SeparatedSyntaxList{Loretta.CodeAnalysis.SyntaxNode})~Loretta.CodeAnalysis.SeparatedSyntaxList{`0}">
            <summary>
            Converts a list of opaquely typed nodes into a list of typed nodes.
            </summary>
            <param name="nodes"></param>
        </member>
        <member name="T:Loretta.CodeAnalysis.SeparatedSyntaxList`1.Enumerator">
            <summary>
            The enumerator for <see cref="T:Loretta.CodeAnalysis.SeparatedSyntaxList`1"/>.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SeparatedSyntaxList`1.Enumerator.MoveNext">
            <inheritdoc cref="M:System.Collections.IEnumerator.MoveNext"/>
        </member>
        <member name="P:Loretta.CodeAnalysis.SeparatedSyntaxList`1.Enumerator.Current">
            <inheritdoc cref="P:System.Collections.Generic.IEnumerator`1.Current"/>
        </member>
        <member name="M:Loretta.CodeAnalysis.SeparatedSyntaxList`1.Enumerator.Reset">
            <inheritdoc cref="M:System.Collections.IEnumerator.Reset"/>
        </member>
        <member name="M:Loretta.CodeAnalysis.SeparatedSyntaxList`1.Enumerator.Equals(System.Object)">
            <summary>
            Not supported. Do not call.
            </summary>
            <param name="obj"></param>
            <returns></returns>
            <exception cref="T:System.NotSupportedException">
            Always thrown.
            </exception>
        </member>
        <member name="M:Loretta.CodeAnalysis.SeparatedSyntaxList`1.Enumerator.GetHashCode">
            <summary>
            Not supported. Do not call.
            </summary>
            <returns></returns>
            <exception cref="T:System.NotSupportedException">
            Always thrown.
            </exception>
        </member>
        <member name="M:Loretta.CodeAnalysis.SeparatedSyntaxList`1.Enumerator.op_Equality(Loretta.CodeAnalysis.SeparatedSyntaxList{`0}.Enumerator,Loretta.CodeAnalysis.SeparatedSyntaxList{`0}.Enumerator)">
            <summary>
            Not supported. Do not use.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
            <exception cref="T:System.NotSupportedException">
            Always thrown.
            </exception>
        </member>
        <member name="M:Loretta.CodeAnalysis.SeparatedSyntaxList`1.Enumerator.op_Inequality(Loretta.CodeAnalysis.SeparatedSyntaxList{`0}.Enumerator,Loretta.CodeAnalysis.SeparatedSyntaxList{`0}.Enumerator)">
            <summary>
            Not supported. Do not use.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
            <exception cref="T:System.NotSupportedException">
            Always thrown.
            </exception>
        </member>
        <member name="T:Loretta.CodeAnalysis.SyntaxAnnotation">
            <summary>
            A SyntaxAnnotation is used to annotate syntax elements with additional information. 
            
            Since syntax elements are immutable, annotating them requires creating new instances of them
            with the annotations attached.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxAnnotation.ElasticAnnotation">
            <summary>
            A predefined syntax annotation that indicates whether the syntax element has elastic trivia.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxAnnotation.Kind">
            <summary>
            The kind of annotation.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxAnnotation.Data">
            <summary>
            The annotation's data.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxAnnotation.#ctor">
            <summary>
            Creates a new empty annotation.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxAnnotation.#ctor(System.String)">
            <summary>
            Creates a new annotation without a value.
            </summary>
            <param name="kind"></param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxAnnotation.#ctor(System.String,System.String)">
            <summary>
            Creates a new annotation.
            </summary>
            <param name="kind"></param>
            <param name="data"></param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxAnnotation.Equals(Loretta.CodeAnalysis.SyntaxAnnotation)">
            <inheritdoc/>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxAnnotation.op_Equality(Loretta.CodeAnalysis.SyntaxAnnotation,Loretta.CodeAnalysis.SyntaxAnnotation)">
            <summary>
            Checks whether two annotations are equal.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxAnnotation.op_Inequality(Loretta.CodeAnalysis.SyntaxAnnotation,Loretta.CodeAnalysis.SyntaxAnnotation)">
            <summary>
            Checks whether two annotations are not equal.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxAnnotation.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxAnnotation.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="T:Loretta.CodeAnalysis.SyntaxList`1">
            <summary>
            A list of <see cref="T:Loretta.CodeAnalysis.SyntaxNode"/>.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxList`1.#ctor(`0)">
            <summary>
            Creates a singleton list of syntax nodes.
            </summary>
            <param name="node">The single element node.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxList`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Creates a list of syntax nodes.
            </summary>
            <param name="nodes">A sequence of element nodes.</param>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxList`1.Count">
            <summary>
            The number of nodes in the list.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxList`1.Item(System.Int32)">
            <summary>
            Gets the node at the specified index.
            </summary>
            <param name="index">The zero-based index of the node to get or set.</param>
            <returns>The node at the specified index.</returns>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxList`1.FullSpan">
            <summary>
            The absolute span of the list elements in characters, including the leading and trailing trivia of the first and last elements.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxList`1.Span">
            <summary>
            The absolute span of the list elements in characters, not including the leading and trailing trivia of the first and last elements.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxList`1.ToString">
            <summary>
            Returns the string representation of the nodes in this list, not including 
            the first node's leading trivia and the last node's trailing trivia.
            </summary>
            <returns>
            The string representation of the nodes in this list, not including 
            the first node's leading trivia and the last node's trailing trivia.
            </returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxList`1.ToFullString">
            <summary>
            Returns the full string representation of the nodes in this list including 
            the first node's leading trivia and the last node's trailing trivia.
            </summary>
            <returns>
            The full string representation of the nodes in this list including 
            the first node's leading trivia and the last node's trailing trivia.
            </returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxList`1.Add(`0)">
            <summary>
            Creates a new list with the specified node added at the end.
            </summary>
            <param name="node">The node to add.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxList`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Creates a new list with the specified nodes added at the end.
            </summary>
            <param name="nodes">The nodes to add.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxList`1.Insert(System.Int32,`0)">
            <summary>
            Creates a new list with the specified node inserted at the index.
            </summary>
            <param name="index">The index to insert at.</param>
            <param name="node">The node to insert.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxList`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Creates a new list with the specified nodes inserted at the index.
            </summary>
            <param name="index">The index to insert at.</param>
            <param name="nodes">The nodes to insert.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxList`1.RemoveAt(System.Int32)">
            <summary>
            Creates a new list with the element at specified index removed.
            </summary>
            <param name="index">The index of the element to remove.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxList`1.Remove(`0)">
            <summary>
            Creates a new list with the element removed.
            </summary>
            <param name="node">The element to remove.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxList`1.Replace(`0,`0)">
            <summary>
            Creates a new list with the specified element replaced with the new node.
            </summary>
            <param name="nodeInList">The element to replace.</param>
            <param name="newNode">The new node.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxList`1.ReplaceRange(`0,System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Creates a new list with the specified element replaced with new nodes.
            </summary>
            <param name="nodeInList">The element to replace.</param>
            <param name="newNodes">The new nodes.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxList`1.First">
            <summary>
            The first node in the list.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxList`1.FirstOrDefault">
            <summary>
            The first node in the list or default if the list is empty.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxList`1.Last">
            <summary>
            The last node in the list.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxList`1.LastOrDefault">
            <summary>
            The last node in the list or default if the list is empty.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxList`1.Any">
            <summary>
            True if the list has at least one node.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxList`1.GetEnumerator">
            <summary>
            Gets the enumerator for this list.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxList`1.op_Equality(Loretta.CodeAnalysis.SyntaxList{`0},Loretta.CodeAnalysis.SyntaxList{`0})">
            <summary>
            Checks whether two lists are equal.
            Does a reference check instead of structural.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxList`1.op_Inequality(Loretta.CodeAnalysis.SyntaxList{`0},Loretta.CodeAnalysis.SyntaxList{`0})">
            <summary>
            Checks whether two lists are not equal.
            Does a reference check instead of structural.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxList`1.Equals(Loretta.CodeAnalysis.SyntaxList{`0})">
            <inheritdoc/>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxList`1.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxList`1.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxList`1.op_Implicit(Loretta.CodeAnalysis.SyntaxList{Loretta.CodeAnalysis.SyntaxNode})~Loretta.CodeAnalysis.SyntaxList{`0}">
            <summary>
            Converts an opaquely typed node list into a typed node list.
            </summary>
            <param name="nodes"></param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxList`1.op_Implicit(Loretta.CodeAnalysis.SyntaxList{`0})~Loretta.CodeAnalysis.SyntaxList{Loretta.CodeAnalysis.SyntaxNode}">
            <summary>
            Converts a typed node list into an opaquely typed node list.
            </summary>
            <param name="nodes"></param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxList`1.IndexOf(`0)">
            <summary>
            The index of the node in this list, or -1 if the node is not in the list.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxList`1.IndexOf(System.Func{`0,System.Boolean})">
            <summary>
            Returns the index of the first node in this list that passes the provided predicate.
            </summary>
            <param name="predicate"></param>
            <returns>-1 if not found.</returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxList`1.LastIndexOf(`0)">
            <summary>
            Returns the index of the last item that is equal to the provided node in this list.
            </summary>
            <param name="node"></param>
            <returns>-1 if not found.</returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxList`1.LastIndexOf(System.Func{`0,System.Boolean})">
            <summary>
            Returns the index of the last node in this list that passes the provided predicate.
            </summary>
            <param name="predicate"></param>
            <returns></returns>
        </member>
        <member name="T:Loretta.CodeAnalysis.SyntaxList`1.Enumerator">
            <summary>
            The enumerator for <see cref="T:Loretta.CodeAnalysis.SyntaxList`1"/>.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxList`1.Enumerator.MoveNext">
            <inheritdoc cref="M:System.Collections.IEnumerator.MoveNext"/>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxList`1.Enumerator.Current">
            <inheritdoc cref="P:System.Collections.Generic.IEnumerator`1.Current"/>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxList`1.Enumerator.Reset">
            <inheritdoc cref="M:System.Collections.IEnumerator.Reset"/>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxList`1.Enumerator.Equals(System.Object)">
            <summary>
            Not supported. Do not call.
            </summary>
            <param name="obj"></param>
            <returns></returns>
            <exception cref="T:System.NotSupportedException">
            Always thrown.
            </exception>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxList`1.Enumerator.GetHashCode">
            <summary>
            Not supported. Do not call.
            </summary>
            <returns></returns>
            <exception cref="T:System.NotSupportedException">
            Always thrown.
            </exception>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxList`1.Enumerator.op_Equality(Loretta.CodeAnalysis.SyntaxList{`0}.Enumerator,Loretta.CodeAnalysis.SyntaxList{`0}.Enumerator)">
            <summary>
            Not supported. Do not use.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
            <exception cref="T:System.NotSupportedException">
            Always thrown.
            </exception>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxList`1.Enumerator.op_Inequality(Loretta.CodeAnalysis.SyntaxList{`0}.Enumerator,Loretta.CodeAnalysis.SyntaxList{`0}.Enumerator)">
            <summary>
            Not supported. Do not use.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <exception cref="T:System.NotSupportedException">
            Always thrown.
            </exception>
        </member>
        <member name="T:Loretta.CodeAnalysis.SyntaxNode">
            <summary>
            Represents a non-terminal node in the syntax tree.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNode.#ctor(Loretta.CodeAnalysis.GreenNode,System.Int32,Loretta.CodeAnalysis.SyntaxTree)">
            <summary>
            Used by structured trivia which has "parent == null", and therefore must know its
            SyntaxTree explicitly when created.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxNode.RawKind">
            <summary>
            An integer representing the language specific kind of this node.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxNode.KindText">
            <summary>
            The textual representation of this node's kind.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxNode.Language">
            <summary>
            The language name that this node is syntax of.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxNode.SyntaxTree">
            <summary>
            Returns SyntaxTree that owns the node or null if node does not belong to a
            SyntaxTree
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxNode.FullSpan">
            <summary>
            The absolute span of this node in characters, including its leading and trailing trivia.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxNode.Span">
            <summary>
            The absolute span of this node in characters, not including its leading and trailing trivia.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxNode.SpanStart">
            <summary>
            Same as accessing <see cref="P:Loretta.CodeAnalysis.Text.TextSpan.Start"/> on <see cref="P:Loretta.CodeAnalysis.SyntaxNode.Span"/>.
            </summary>
            <remarks>
            Slight performance improvement.
            </remarks>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxNode.Width">
            <summary>
            The width of the node in characters, not including leading and trailing trivia.
            </summary>
            <remarks>
            The Width property returns the same value as Span.Length, but is somewhat more efficient.
            </remarks>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxNode.FullWidth">
            <summary>
            The complete width of the node in characters, including leading and trailing trivia.
            </summary>
            <remarks>The FullWidth property returns the same value as FullSpan.Length, but is
            somewhat more efficient.</remarks>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNode.GetRed``1(``0@,System.Int32)">
            <summary>internal</summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNode.GetRedAtZero``1(``0@)">
            <summary>internal</summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNode.GetRedElement(Loretta.CodeAnalysis.SyntaxNode@,System.Int32)">
            <summary>
            This works the same as GetRed, but intended to be used in lists
            The only difference is that the public parent of the node is not the list, 
            but the list's parent. (element's grand parent).
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNode.GetRedElementIfNotToken(Loretta.CodeAnalysis.SyntaxNode@)">
            <summary>
            special cased helper for 2 and 3 children lists where child #1 may map to a token
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNode.ToString">
            <summary>
            Returns the string representation of this node, not including its leading and trailing trivia.
            </summary>
            <returns>The string representation of this node, not including its leading and trailing trivia.</returns>
            <remarks>The length of the returned string is always the same as Span.Length</remarks>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNode.ToFullString">
            <summary>
            Returns full string representation of this node including its leading and trailing trivia.
            </summary>
            <returns>The full string representation of this node including its leading and trailing trivia.</returns>
            <remarks>The length of the returned string is always the same as FullSpan.Length</remarks>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNode.WriteTo(System.IO.TextWriter)">
            <summary>
            Writes the full text of this node to the specified <see cref="T:System.IO.TextWriter"/>.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNode.GetText(System.Text.Encoding,Loretta.CodeAnalysis.Text.SourceHashAlgorithm)">
            <summary>
            Gets the full text of this node as a new <see cref="T:Loretta.CodeAnalysis.Text.SourceText"/> instance.
            </summary>
            <param name="encoding">
            Encoding of the file that the text was read from or is going to be saved to.
            <c>null</c> if the encoding is unspecified.
            If the encoding is not specified the <see cref="T:Loretta.CodeAnalysis.Text.SourceText"/> isn't debuggable.
            If an encoding-less <see cref="T:Loretta.CodeAnalysis.Text.SourceText"/> is written to a file a <see cref="P:System.Text.Encoding.UTF8"/> shall be used as a default.
            </param>
            <param name="checksumAlgorithm">
            Hash algorithm to use to calculate checksum of the text that's saved to PDB.
            </param>
            <exception cref="T:System.ArgumentException"><paramref name="checksumAlgorithm"/> is not supported.</exception>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNode.IsEquivalentTo(Loretta.CodeAnalysis.SyntaxNode)">
            <summary>
            Determine whether this node is structurally equivalent to another.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNode.IsIncrementallyIdenticalTo(Loretta.CodeAnalysis.SyntaxNode)">
            <summary>
            Returns true if these two nodes are considered "incrementally identical".  An incrementally identical node
            occurs when a <see cref="P:Loretta.CodeAnalysis.SyntaxNode.SyntaxTree"/> is incrementally parsed using <see cref="M:Loretta.CodeAnalysis.SyntaxTree.WithChangedText(Loretta.CodeAnalysis.Text.SourceText)"/>
            and the incremental parser is able to take the node from the original tree and use it in its entirety in the
            new tree.  In this case, the <see cref="M:Loretta.CodeAnalysis.SyntaxNode.ToFullString"/> of each node will be the same, though
            they could have different parents, and may occur at different positions in their respective trees.  If two nodes are
            incrementally identical, all children of each node will be incrementally identical as well.
            </summary>
            <remarks>
            Incrementally identical nodes can also appear within the same syntax tree, or syntax trees that did not arise
            from <see cref="M:Loretta.CodeAnalysis.SyntaxTree.WithChangedText(Loretta.CodeAnalysis.Text.SourceText)"/>.  This can happen as the parser is allowed to construct parse
            trees from shared nodes for efficiency.  In all these cases though, it will still remain true that the incrementally
            identical nodes could have different parents and may occur at different positions in their respective trees.
            </remarks>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxNode.IsMissing">
            <summary>
            Determines whether the node represents a language construct that was actually parsed
            from the source code. Missing nodes are generated by the parser in error scenarios to
            represent constructs that should have been present in the source code in order to
            compile successfully but were actually missing.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNode.IsPartOfStructuredTrivia">
            <summary>
            Determines whether this node is a descendant of a structured trivia.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxNode.IsStructuredTrivia">
            <summary>
            Determines whether this node represents a structured trivia.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxNode.HasStructuredTrivia">
            <summary>
            Determines whether a descendant trivia of this node is structured.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxNode.ContainsSkippedText">
            <summary>
            Determines whether this node has any descendant skipped text.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxNode.ContainsDirectives">
            <summary>
            Determines whether this node has any descendant preprocessor directives.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxNode.ContainsDiagnostics">
            <summary>
            Determines whether this node or any of its descendant nodes, tokens or trivia have any diagnostics on them. 
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNode.Contains(Loretta.CodeAnalysis.SyntaxNode)">
            <summary>
            Determines if the specified node is a descendant of this node.
            Returns true for current node.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxNode.HasLeadingTrivia">
            <summary>
            Determines whether this node has any leading trivia.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxNode.HasTrailingTrivia">
            <summary>
            Determines whether this node has any trailing trivia.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNode.GetCachedSlot(System.Int32)">
            <summary>
            Gets a node at given node index without forcing its creation.
            If node was not created it would return null.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNode.GetChildPosition(System.Int32)">
            <summary>
            This function calculates the offset of a child at given position. It is very common that
            some children to the left of the given index already know their positions so we first
            check if that is the case. In a worst case the cost is O(n), but it is not generally an
            issue because number of children in regular nodes is fixed and small. In a case where
            the number of children could be large (lists) this function is overridden with more
            efficient implementations.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNode.GetLocation">
            <summary>
            Returns the <see cref="T:Loretta.CodeAnalysis.Location"/> for this node.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNode.GetDiagnostics">
            <summary>
            Gets a list of all the diagnostics in the sub tree that has this node as its root.
            This method does not filter diagnostics based on #pragmas and compiler options
            like nowarn, warnaserror etc.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNode.GetReference">
            <summary>
            Gets a <see cref="T:Loretta.CodeAnalysis.SyntaxReference"/> for this syntax node. CommonSyntaxReferences can be used to
            regain access to a syntax node without keeping the entire tree and source text in
            memory.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxNode.Parent">
            <summary>
            The node that contains this node in its <see cref="M:Loretta.CodeAnalysis.SyntaxNode.ChildNodes"/> collection.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxNode.ParentTrivia">
            <summary>
            The parent trivia for this node in case it is part of structured trivia.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNode.ChildNodesAndTokens">
            <summary>
            The list of child nodes and tokens of this node, where each element is a SyntaxNodeOrToken instance.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNode.ChildThatContainsPosition(System.Int32)">
            <summary>
            Returns the child node or token that contains the provided position.
            </summary>
            <param name="position"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown if the provided position is outside of this node.
            </exception>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNode.GetNodeSlot(System.Int32)">
            <summary>
            Gets node at given node index. 
            This WILL force node creation if node has not yet been created.
            Can still return null for invalid slot numbers
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNode.ChildNodes">
            <summary>
            Gets a list of the child nodes in prefix document order.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNode.Ancestors(System.Boolean)">
            <summary>
            Gets a list of ancestor nodes
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNode.AncestorsAndSelf(System.Boolean)">
            <summary>
            Gets a list of ancestor nodes (including this node) 
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNode.FirstAncestorOrSelf``1(System.Func{``0,System.Boolean},System.Boolean)">
            <summary>
            Gets the first node of type TNode that matches the predicate.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNode.FirstAncestorOrSelf``2(System.Func{``0,``1,System.Boolean},``1,System.Boolean)">
            <summary>
            Gets the first node of type TNode that matches the predicate.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNode.DescendantNodes(System.Func{Loretta.CodeAnalysis.SyntaxNode,System.Boolean},System.Boolean)">
            <summary>
            Gets a list of descendant nodes in prefix document order.
            </summary>
            <param name="descendIntoChildren">An optional function that determines if the search descends into the argument node's children.</param>
            <param name="descendIntoTrivia">Determines if nodes that are part of structured trivia are included in the list.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNode.DescendantNodes(Loretta.CodeAnalysis.Text.TextSpan,System.Func{Loretta.CodeAnalysis.SyntaxNode,System.Boolean},System.Boolean)">
            <summary>
            Gets a list of descendant nodes in prefix document order.
            </summary>
            <param name="span">The span the node's full span must intersect.</param>
            <param name="descendIntoChildren">An optional function that determines if the search descends into the argument node's children.</param>
            <param name="descendIntoTrivia">Determines if nodes that are part of structured trivia are included in the list.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNode.DescendantNodesAndSelf(System.Func{Loretta.CodeAnalysis.SyntaxNode,System.Boolean},System.Boolean)">
            <summary>
            Gets a list of descendant nodes (including this node) in prefix document order.
            </summary>
            <param name="descendIntoChildren">An optional function that determines if the search descends into the argument node's children.</param>
            <param name="descendIntoTrivia">Determines if nodes that are part of structured trivia are included in the list.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNode.DescendantNodesAndSelf(Loretta.CodeAnalysis.Text.TextSpan,System.Func{Loretta.CodeAnalysis.SyntaxNode,System.Boolean},System.Boolean)">
            <summary>
            Gets a list of descendant nodes (including this node) in prefix document order.
            </summary>
            <param name="span">The span the node's full span must intersect.</param>
            <param name="descendIntoChildren">An optional function that determines if the search descends into the argument node's children.</param>
            <param name="descendIntoTrivia">Determines if nodes that are part of structured trivia are included in the list.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNode.DescendantNodesAndTokens(System.Func{Loretta.CodeAnalysis.SyntaxNode,System.Boolean},System.Boolean)">
            <summary>
            Gets a list of descendant nodes and tokens in prefix document order.
            </summary>
            <param name="descendIntoChildren">An optional function that determines if the search descends into the argument node's children.</param>
            <param name="descendIntoTrivia">Determines if nodes that are part of structured trivia are included in the list.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNode.DescendantNodesAndTokens(Loretta.CodeAnalysis.Text.TextSpan,System.Func{Loretta.CodeAnalysis.SyntaxNode,System.Boolean},System.Boolean)">
            <summary>
            Gets a list of the descendant nodes and tokens in prefix document order.
            </summary>
            <param name="span">The span the node's full span must intersect.</param>
            <param name="descendIntoChildren">An optional function that determines if the search descends into the argument node's children.</param>
            <param name="descendIntoTrivia">Determines if nodes that are part of structured trivia are included in the list.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNode.DescendantNodesAndTokensAndSelf(System.Func{Loretta.CodeAnalysis.SyntaxNode,System.Boolean},System.Boolean)">
            <summary>
            Gets a list of descendant nodes and tokens (including this node) in prefix document order.
            </summary>
            <param name="descendIntoChildren">An optional function that determines if the search descends into the argument node's children.</param>
            <param name="descendIntoTrivia">Determines if nodes that are part of structured trivia are included in the list.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNode.DescendantNodesAndTokensAndSelf(Loretta.CodeAnalysis.Text.TextSpan,System.Func{Loretta.CodeAnalysis.SyntaxNode,System.Boolean},System.Boolean)">
            <summary>
            Gets a list of the descendant nodes and tokens (including this node) in prefix document order.
            </summary>
            <param name="span">The span the node's full span must intersect.</param>
            <param name="descendIntoChildren">An optional function that determines if the search descends into the argument node's children.</param>
            <param name="descendIntoTrivia">Determines if nodes that are part of structured trivia are included in the list.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNode.FindNode(Loretta.CodeAnalysis.Text.TextSpan,System.Boolean,System.Boolean)">
            <summary>
            Finds the node with the smallest <see cref="P:Loretta.CodeAnalysis.SyntaxNode.FullSpan"/> that contains <paramref name="span"/>.
            <paramref name="getInnermostNodeForTie"/> is used to determine the behavior in case of a tie (i.e. a node having the same span as its parent).
            If <paramref name="getInnermostNodeForTie"/> is true, then it returns lowest descending node encompassing the given <paramref name="span"/>.
            Otherwise, it returns the outermost node encompassing the given <paramref name="span"/>.
            </summary>
            <devdoc>
            TODO: This should probably be reimplemented with <see cref="M:Loretta.CodeAnalysis.SyntaxNode.ChildThatContainsPosition(System.Int32)"/>
            </devdoc>
            <exception cref="T:System.ArgumentOutOfRangeException">This exception is thrown if <see cref="P:Loretta.CodeAnalysis.SyntaxNode.FullSpan"/> doesn't contain the given span.</exception>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNode.FindToken(System.Int32,System.Boolean)">
            <summary>
            Finds a descendant token of this node whose span includes the supplied position. 
            </summary>
            <param name="position">The character position of the token relative to the beginning of the file.</param>
            <param name="findInsideTrivia">
            True to return tokens that are part of trivia. If false finds the token whose full span (including trivia)
            includes the position.
            </param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNode.GetFirstToken(System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Gets the first token of the tree rooted by this node. Skips zero-width tokens.
            </summary>
            <returns>The first token or <c>default(SyntaxToken)</c> if it doesn't exist.</returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNode.GetLastToken(System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Gets the last token of the tree rooted by this node. Skips zero-width tokens.
            </summary>
            <returns>The last token or <c>default(SyntaxToken)</c> if it doesn't exist.</returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNode.ChildTokens">
            <summary>
            Gets a list of the direct child tokens of this node.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNode.DescendantTokens(System.Func{Loretta.CodeAnalysis.SyntaxNode,System.Boolean},System.Boolean)">
            <summary>
            Gets a list of all the tokens in the span of this node.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNode.DescendantTokens(Loretta.CodeAnalysis.Text.TextSpan,System.Func{Loretta.CodeAnalysis.SyntaxNode,System.Boolean},System.Boolean)">
            <summary>
            Gets a list of all the tokens in the full span of this node.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNode.GetLeadingTrivia">
            <summary>
            The list of trivia that appears before this node in the source code and are attached to a token that is a
            descendant of this node.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNode.GetTrailingTrivia">
            <summary>
            The list of trivia that appears after this node in the source code and are attached to a token that is a
            descendant of this node.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNode.FindTrivia(System.Int32,System.Boolean)">
            <summary>
            Finds a descendant trivia of this node whose span includes the supplied position.
            </summary>
            <param name="position">The character position of the trivia relative to the beginning of the file.</param>
            <param name="findInsideTrivia">
            True to return tokens that are part of trivia. If false finds the token whose full span (including trivia)
            includes the position.
            </param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNode.FindTrivia(System.Int32,System.Func{Loretta.CodeAnalysis.SyntaxTrivia,System.Boolean})">
            <summary>
            Finds a descendant trivia of this node at the specified position, where the position is
            within the span of the node.
            </summary>
            <param name="position">The character position of the trivia relative to the beginning of
            the file.</param>
            <param name="stepInto">Specifies a function that determines per trivia node, whether to
            descend into structured trivia of that node.</param>
            <returns></returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNode.DescendantTrivia(System.Func{Loretta.CodeAnalysis.SyntaxNode,System.Boolean},System.Boolean)">
            <summary>
            Get a list of all the trivia associated with the descendant nodes and tokens.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNode.DescendantTrivia(Loretta.CodeAnalysis.Text.TextSpan,System.Func{Loretta.CodeAnalysis.SyntaxNode,System.Boolean},System.Boolean)">
            <summary>
            Get a list of all the trivia associated with the descendant nodes and tokens.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxNode.ContainsAnnotations">
            <summary>
            Determines whether this node or any sub node, token or trivia has annotations.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNode.HasAnnotations(System.String)">
            <summary>
            Determines whether this node has any annotations with the specific annotation kind.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNode.HasAnnotations(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Determines whether this node has any annotations with any of the specific annotation kinds.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNode.HasAnnotation(Loretta.CodeAnalysis.SyntaxAnnotation)">
            <summary>
            Determines whether this node has the specific annotation.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNode.GetAnnotations(System.String)">
            <summary>
            Gets all the annotations with the specified annotation kind. 
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNode.GetAnnotations(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Gets all the annotations with the specified annotation kinds. 
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNode.GetAnnotatedNodesAndTokens(System.String)">
            <summary>
            Gets all nodes and tokens with an annotation of the specified annotation kind.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNode.GetAnnotatedNodesAndTokens(System.String[])">
            <summary>
            Gets all nodes and tokens with an annotation of the specified annotation kinds.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNode.GetAnnotatedNodesAndTokens(Loretta.CodeAnalysis.SyntaxAnnotation)">
            <summary>
            Gets all nodes and tokens with the specified annotation.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNode.GetAnnotatedNodes(Loretta.CodeAnalysis.SyntaxAnnotation)">
            <summary>
            Gets all nodes with the specified annotation.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNode.GetAnnotatedNodes(System.String)">
            <summary>
            Gets all nodes with the specified annotation kind.
            </summary>
            <param name="annotationKind"></param>
            <returns></returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNode.GetAnnotatedTokens(Loretta.CodeAnalysis.SyntaxAnnotation)">
            <summary>
            Gets all tokens with the specified annotation.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNode.GetAnnotatedTokens(System.String)">
            <summary>
            Gets all tokens with the specified annotation kind.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNode.GetAnnotatedTrivia(System.String)">
            <summary>
            Gets all trivia with an annotation of the specified annotation kind.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNode.GetAnnotatedTrivia(System.String[])">
            <summary>
            Gets all trivia with an annotation of the specified annotation kinds.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNode.GetAnnotatedTrivia(Loretta.CodeAnalysis.SyntaxAnnotation)">
            <summary>
            Gets all trivia with the specified annotation.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNode.CopyAnnotationsTo``1(``0)">
            <summary>
            Copies all SyntaxAnnotations, if any, from this SyntaxNode instance and attaches them to a new instance based on <paramref name="node" />.
            </summary>
            <remarks>
            <para>
            If no annotations are copied, just returns <paramref name="node" />.
            </para>
            <para>
            It can also be used manually to preserve annotations in a more complex tree
            modification, even if the type of a node changes.
            </para>
            </remarks>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNode.IsEquivalentTo(Loretta.CodeAnalysis.SyntaxNode,System.Boolean)">
            <summary>
            Determines if two nodes are the same, disregarding trivia differences.
            </summary>
            <param name="node">The node to compare against.</param>
            <param name="topLevel"> If true then the nodes are equivalent if the contained nodes and
            tokens declaring metadata visible symbolic information are equivalent, ignoring any
            differences of nodes inside method bodies or initializer expressions, otherwise all
            nodes and tokens must be equivalent. 
            </param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNode.SerializeTo(System.IO.Stream,System.Threading.CancellationToken)">
            <summary>
            Serializes the node to the given <paramref name="stream"/>.
            Leaves the <paramref name="stream"/> open for further writes.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNode.EquivalentToCore(Loretta.CodeAnalysis.SyntaxNode)">
            <summary>
            Determine if this node is structurally equivalent to another.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxNode.SyntaxTreeCore">
            <summary>
            Returns SyntaxTree that owns the node. If the node does not belong to a tree then
            one will be generated.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNode.FindTokenCore(System.Int32,System.Boolean)">
            <summary>
            Finds a descendant token of this node whose span includes the supplied position. 
            </summary>
            <param name="position">The character position of the token relative to the beginning of the file.</param>
            <param name="findInsideTrivia">
            True to return tokens that are part of trivia.
            If false finds the token whose full span (including trivia) includes the position.
            </param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNode.FindTokenCore(System.Int32,System.Func{Loretta.CodeAnalysis.SyntaxTrivia,System.Boolean})">
            <summary>
            Finds a descendant token of this node whose span includes the supplied position. 
            </summary>
            <param name="position">The character position of the token relative to the beginning of the file.</param>
            <param name="stepInto">
            Applied on every structured trivia. Return false if the tokens included in the trivia should be skipped. 
            Pass null to skip all structured trivia.
            </param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNode.FindTriviaCore(System.Int32,System.Boolean)">
            <summary>
            Finds a descendant trivia of this node whose span includes the supplied position.
            </summary>
            <param name="position">The character position of the trivia relative to the beginning of the file.</param>
            <param name="findInsideTrivia">Whether to search inside structured trivia.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNode.ReplaceCore``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``0,Loretta.CodeAnalysis.SyntaxNode},System.Collections.Generic.IEnumerable{Loretta.CodeAnalysis.SyntaxToken},System.Func{Loretta.CodeAnalysis.SyntaxToken,Loretta.CodeAnalysis.SyntaxToken,Loretta.CodeAnalysis.SyntaxToken},System.Collections.Generic.IEnumerable{Loretta.CodeAnalysis.SyntaxTrivia},System.Func{Loretta.CodeAnalysis.SyntaxTrivia,Loretta.CodeAnalysis.SyntaxTrivia,Loretta.CodeAnalysis.SyntaxTrivia})">
            <summary>
            Creates a new tree of nodes with the specified nodes, tokens or trivia replaced.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNode.ReplaceNodeInListCore(Loretta.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Loretta.CodeAnalysis.SyntaxNode})">
            <summary>internal</summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNode.InsertNodesInListCore(Loretta.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Loretta.CodeAnalysis.SyntaxNode},System.Boolean)">
            <summary>internal</summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNode.ReplaceTokenInListCore(Loretta.CodeAnalysis.SyntaxToken,System.Collections.Generic.IEnumerable{Loretta.CodeAnalysis.SyntaxToken})">
            <summary>internal</summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNode.InsertTokensInListCore(Loretta.CodeAnalysis.SyntaxToken,System.Collections.Generic.IEnumerable{Loretta.CodeAnalysis.SyntaxToken},System.Boolean)">
            <summary>internal</summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNode.ReplaceTriviaInListCore(Loretta.CodeAnalysis.SyntaxTrivia,System.Collections.Generic.IEnumerable{Loretta.CodeAnalysis.SyntaxTrivia})">
            <summary>internal</summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNode.InsertTriviaInListCore(Loretta.CodeAnalysis.SyntaxTrivia,System.Collections.Generic.IEnumerable{Loretta.CodeAnalysis.SyntaxTrivia},System.Boolean)">
            <summary>internal</summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNode.RemoveNodesCore(System.Collections.Generic.IEnumerable{Loretta.CodeAnalysis.SyntaxNode},Loretta.CodeAnalysis.SyntaxRemoveOptions)">
            <summary>
            Creates a new tree of nodes with the specified node removed.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNode.NormalizeWhitespaceCore(System.String,System.String,System.Boolean)">
            <summary>internal</summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNode.IsEquivalentToCore(Loretta.CodeAnalysis.SyntaxNode,System.Boolean)">
            <summary>
            Determines if two nodes are the same, disregarding trivia differences.
            </summary>
            <param name="node">The node to compare against.</param>
            <param name="topLevel"> If true then the nodes are equivalent if the contained nodes and
            tokens declaring metadata visible symbolic information are equivalent, ignoring any
            differences of nodes inside method bodies or initializer expressions, otherwise all
            nodes and tokens must be equivalent. 
            </param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNode.ShouldCreateWeakList">
            <summary>
            Whether or not this parent node wants its child SyntaxList node to be 
            converted to a Weak-SyntaxList when creating the red-node equivalent.
            For example, in C# the statements of a Block-Node that is parented by a 
            MethodDeclaration will be held weakly.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNode.CloneNodeAsRoot``1(``0,Loretta.CodeAnalysis.SyntaxTree)">
            <summary>
            Creates a clone of a red node that can be used as a root of given syntaxTree.
            New node has no parents, position == 0, and syntaxTree as specified.
            </summary>
        </member>
        <member name="T:Loretta.CodeAnalysis.SyntaxNodeExtensions">
            <summary>
            Extension methods for <see cref="T:Loretta.CodeAnalysis.SyntaxNode"/>.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeExtensions.ReplaceSyntax``1(``0,System.Collections.Generic.IEnumerable{Loretta.CodeAnalysis.SyntaxNode},System.Func{Loretta.CodeAnalysis.SyntaxNode,Loretta.CodeAnalysis.SyntaxNode,Loretta.CodeAnalysis.SyntaxNode},System.Collections.Generic.IEnumerable{Loretta.CodeAnalysis.SyntaxToken},System.Func{Loretta.CodeAnalysis.SyntaxToken,Loretta.CodeAnalysis.SyntaxToken,Loretta.CodeAnalysis.SyntaxToken},System.Collections.Generic.IEnumerable{Loretta.CodeAnalysis.SyntaxTrivia},System.Func{Loretta.CodeAnalysis.SyntaxTrivia,Loretta.CodeAnalysis.SyntaxTrivia,Loretta.CodeAnalysis.SyntaxTrivia})">
            <summary>
            Creates a new tree of nodes with the specified nodes, tokens and trivia replaced.
            </summary>
            <typeparam name="TRoot">The type of the root node.</typeparam>
            <param name="root">The root node of the tree of nodes.</param>
            <param name="nodes">The nodes to be replaced.</param>
            <param name="computeReplacementNode">A function that computes a replacement node for the
            argument nodes. The first argument is the original node. The second argument is the same
            node potentially rewritten with replaced descendants.</param>
            <param name="tokens">The tokens to be replaced.</param>
            <param name="computeReplacementToken">A function that computes a replacement token for
            the argument tokens. The first argument is the original token. The second argument is
            the same token potentially rewritten with replaced trivia.</param>
            <param name="trivia">The trivia to be replaced.</param>
            <param name="computeReplacementTrivia">A function that computes replacement trivia for
            the specified arguments. The first argument is the original trivia. The second argument is
            the same trivia with potentially rewritten sub structure.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeExtensions.ReplaceNodes``2(``0,System.Collections.Generic.IEnumerable{``1},System.Func{``1,``1,Loretta.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a new tree of nodes with the specified old node replaced with a new node.
            </summary>
            <typeparam name="TRoot">The type of the root node.</typeparam>
            <typeparam name="TNode">The type of the nodes being replaced.</typeparam>
            <param name="root">The root node of the tree of nodes.</param>
            <param name="nodes">The nodes to be replaced; descendants of the root node.</param>
            <param name="computeReplacementNode">A function that computes a replacement node for the
            argument nodes. The first argument is the original node. The second argument is the same
            node potentially rewritten with replaced descendants.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode``1(``0,Loretta.CodeAnalysis.SyntaxNode,Loretta.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates a new tree of nodes with the specified old node replaced with a new node.
            </summary>
            <typeparam name="TRoot">The type of the root node.</typeparam>
            <param name="root">The root node of the tree of nodes.</param>
            <param name="oldNode">The node to be replaced; a descendant of the root node.</param>
            <param name="newNode">The new node to use in the new tree in place of the old node.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode``1(``0,Loretta.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Loretta.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a new tree of nodes with specified old node replaced with a new nodes.
            </summary>
            <typeparam name="TRoot">The type of the root node.</typeparam>
            <param name="root">The root of the tree of nodes.</param>
            <param name="oldNode">The node to be replaced; a descendant of the root node and an element of a list member.</param>
            <param name="newNodes">A sequence of nodes to use in the tree in place of the old node.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeExtensions.InsertNodesBefore``1(``0,Loretta.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Loretta.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a new tree of nodes with new nodes inserted before the specified node.
            </summary>
            <typeparam name="TRoot">The type of the root node.</typeparam>
            <param name="root">The root of the tree of nodes.</param>
            <param name="nodeInList">The node to insert before; a descendant of the root node an element of a list member.</param>
            <param name="newNodes">A sequence of nodes to insert into the tree immediately before the specified node.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeExtensions.InsertNodesAfter``1(``0,Loretta.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Loretta.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a new tree of nodes with new nodes inserted after the specified node.
            </summary>
            <typeparam name="TRoot">The type of the root node.</typeparam>
            <param name="root">The root of the tree of nodes.</param>
            <param name="nodeInList">The node to insert after; a descendant of the root node an element of a list member.</param>
            <param name="newNodes">A sequence of nodes to insert into the tree immediately after the specified node.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeExtensions.ReplaceToken``1(``0,Loretta.CodeAnalysis.SyntaxToken,System.Collections.Generic.IEnumerable{Loretta.CodeAnalysis.SyntaxToken})">
            <summary>
            Creates a new tree of nodes with the specified old token replaced with new tokens.
            </summary>
            <typeparam name="TRoot">The type of the root node.</typeparam>
            <param name="root">The root of the tree of nodes.</param>
            <param name="tokenInList">The token to be replaced; a descendant of the root node and an element of a list member.</param>
            <param name="newTokens">A sequence of tokens to use in the tree in place of the specified token.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeExtensions.InsertTokensBefore``1(``0,Loretta.CodeAnalysis.SyntaxToken,System.Collections.Generic.IEnumerable{Loretta.CodeAnalysis.SyntaxToken})">
            <summary>
            Creates a new tree of nodes with new tokens inserted before the specified token.
            </summary>
            <typeparam name="TRoot">The type of the root node.</typeparam>
            <param name="root">The root of the tree of nodes.</param>
            <param name="tokenInList">The token to insert before; a descendant of the root node and an element of a list member.</param>
            <param name="newTokens">A sequence of tokens to insert into the tree immediately before the specified token.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeExtensions.InsertTokensAfter``1(``0,Loretta.CodeAnalysis.SyntaxToken,System.Collections.Generic.IEnumerable{Loretta.CodeAnalysis.SyntaxToken})">
            <summary>
            Creates a new tree of nodes with new tokens inserted after the specified token.
            </summary>
            <typeparam name="TRoot">The type of the root node.</typeparam>
            <param name="root">The root of the tree of nodes.</param>
            <param name="tokenInList">The token to insert after; a descendant of the root node and an element of a list member.</param>
            <param name="newTokens">A sequence of tokens to insert into the tree immediately after the specified token.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeExtensions.ReplaceTrivia``1(``0,Loretta.CodeAnalysis.SyntaxTrivia,System.Collections.Generic.IEnumerable{Loretta.CodeAnalysis.SyntaxTrivia})">
            <summary>
            Creates a new tree of nodes with the specified old trivia replaced with new trivia.
            </summary>
            <typeparam name="TRoot">The type of the root node.</typeparam>
            <param name="root">The root of the tree of nodes.</param>
            <param name="oldTrivia">The trivia to be replaced; a descendant of the root node.</param>
            <param name="newTrivia">A sequence of trivia to use in the tree in place of the specified trivia.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeExtensions.InsertTriviaBefore``1(``0,Loretta.CodeAnalysis.SyntaxTrivia,System.Collections.Generic.IEnumerable{Loretta.CodeAnalysis.SyntaxTrivia})">
            <summary>
            Creates a new tree of nodes with new trivia inserted before the specified trivia.
            </summary>
            <typeparam name="TRoot">The type of the root node.</typeparam>
            <param name="root">The root of the tree of nodes.</param>
            <param name="trivia">The trivia to insert before; a descendant of the root node.</param>
            <param name="newTrivia">A sequence of trivia to insert into the tree immediately before the specified trivia.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeExtensions.InsertTriviaAfter``1(``0,Loretta.CodeAnalysis.SyntaxTrivia,System.Collections.Generic.IEnumerable{Loretta.CodeAnalysis.SyntaxTrivia})">
            <summary>
            Creates a new tree of nodes with new trivia inserted after the specified trivia.
            </summary>
            <typeparam name="TRoot">The type of the root node.</typeparam>
            <param name="root">The root of the tree of nodes.</param>
            <param name="trivia">The trivia to insert after; a descendant of the root node.</param>
            <param name="newTrivia">A sequence of trivia to insert into the tree immediately after the specified trivia.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeExtensions.ReplaceTokens``1(``0,System.Collections.Generic.IEnumerable{Loretta.CodeAnalysis.SyntaxToken},System.Func{Loretta.CodeAnalysis.SyntaxToken,Loretta.CodeAnalysis.SyntaxToken,Loretta.CodeAnalysis.SyntaxToken})">
            <summary>
            Creates a new tree of nodes with the specified old node replaced with a new node.
            </summary>
            <typeparam name="TRoot">The type of the root node.</typeparam>
            <param name="root">The root node of the tree of nodes.</param>
            <param name="tokens">The token to be replaced; descendants of the root node.</param>
            <param name="computeReplacementToken">A function that computes a replacement token for
            the argument tokens. The first argument is the original token. The second argument is
            the same token potentially rewritten with replaced trivia.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeExtensions.ReplaceToken``1(``0,Loretta.CodeAnalysis.SyntaxToken,Loretta.CodeAnalysis.SyntaxToken)">
            <summary>
            Creates a new tree of nodes with the specified old token replaced with a new token.
            </summary>
            <typeparam name="TRoot">The type of the root node.</typeparam>
            <param name="root">The root node of the tree of nodes.</param>
            <param name="oldToken">The token to be replaced.</param>
            <param name="newToken">The new token to use in the new tree in place of the old
            token.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeExtensions.ReplaceTrivia``1(``0,System.Collections.Generic.IEnumerable{Loretta.CodeAnalysis.SyntaxTrivia},System.Func{Loretta.CodeAnalysis.SyntaxTrivia,Loretta.CodeAnalysis.SyntaxTrivia,Loretta.CodeAnalysis.SyntaxTrivia})">
            <summary>
            Creates a new tree of nodes with the specified trivia replaced with new trivia.
            </summary>
            <typeparam name="TRoot">The type of the root node.</typeparam>
            <param name="root">The root node of the tree of nodes.</param>
            <param name="trivia">The trivia to be replaced; descendants of the root node.</param>
            <param name="computeReplacementTrivia">A function that computes replacement trivia for
            the specified arguments. The first argument is the original trivia. The second argument is
            the same trivia with potentially rewritten sub structure.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeExtensions.ReplaceTrivia``1(``0,Loretta.CodeAnalysis.SyntaxTrivia,Loretta.CodeAnalysis.SyntaxTrivia)">
            <summary>
            Creates a new tree of nodes with the specified trivia replaced with new trivia.
            </summary>
            <typeparam name="TRoot">The type of the root node.</typeparam>
            <param name="root">The root node of the tree of nodes.</param>
            <param name="trivia">The trivia to be replaced.</param>
            <param name="newTrivia">The new trivia to use in the new tree in place of the old trivia.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeExtensions.RemoveNode``1(``0,Loretta.CodeAnalysis.SyntaxNode,Loretta.CodeAnalysis.SyntaxRemoveOptions)">
            <summary>
            Creates a new tree of nodes with the specified node removed.
            </summary>
            <typeparam name="TRoot">The type of the root node.</typeparam>
            <param name="root">The root node from which to remove a descendant node from.</param>
            <param name="node">The node to remove.</param>
            <param name="options">Options that determine how the node's trivia is treated.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeExtensions.RemoveNodes``1(``0,System.Collections.Generic.IEnumerable{Loretta.CodeAnalysis.SyntaxNode},Loretta.CodeAnalysis.SyntaxRemoveOptions)">
            <summary>
            Creates a new tree of nodes with the specified nodes removed.
            </summary>
            <typeparam name="TRoot">The type of the root node.</typeparam>
            <param name="root">The root node from which to remove a descendant node from.</param>
            <param name="nodes">The nodes to remove.</param>
            <param name="options">Options that determine how the nodes' trivia is treated.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeExtensions.NormalizeWhitespace``1(``0,System.String,System.Boolean)">
            <summary>
            Creates a new syntax node with all whitespace and end of line trivia replaced with
            regularly formatted trivia.
            </summary>
            <typeparam name="TNode">The type of the node.</typeparam>
            <param name="node">The node to format.</param>
            <param name="indentation">A sequence of whitespace characters that defines a single level of indentation.</param>
            <param name="elasticTrivia">If true the replaced trivia is elastic trivia.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeExtensions.NormalizeWhitespace``1(``0,System.String,System.String,System.Boolean)">
            <summary>
            Creates a new syntax node with all whitespace and end of line trivia replaced with
            regularly formatted trivia.
            </summary>
            <typeparam name="TNode">The type of the node.</typeparam>
            <param name="node">The node to format.</param>
            <param name="indentation">An optional sequence of whitespace characters that defines a single level of indentation.</param>
            <param name="eol">An optional sequence of whitespace characters used for end of line.</param>
            <param name="elasticTrivia">If true the replaced trivia is elastic trivia.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeExtensions.WithTriviaFrom``1(``0,Loretta.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates a new node from this node with both the leading and trailing trivia of the specified node.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeExtensions.WithoutTrivia``1(``0)">
            <summary>
            Creates a new node from this node without leading or trailing trivia.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeExtensions.WithoutTrivia(Loretta.CodeAnalysis.SyntaxToken)">
            <summary>
            Creates a new token from this token without leading or trailing trivia.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeExtensions.WithLeadingTrivia``1(``0,Loretta.CodeAnalysis.SyntaxTriviaList)">
            <summary>
            Creates a new node from this node with the leading trivia replaced.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeExtensions.WithLeadingTrivia``1(``0,System.Collections.Generic.IEnumerable{Loretta.CodeAnalysis.SyntaxTrivia})">
            <summary>
            Creates a new node from this node with the leading trivia replaced.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeExtensions.WithoutLeadingTrivia``1(``0)">
            <summary>
            Creates a new node from this node with the leading trivia removed.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeExtensions.WithLeadingTrivia``1(``0,Loretta.CodeAnalysis.SyntaxTrivia[])">
            <summary>
            Creates a new node from this node with the leading trivia replaced.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeExtensions.WithTrailingTrivia``1(``0,Loretta.CodeAnalysis.SyntaxTriviaList)">
            <summary>
            Creates a new node from this node with the trailing trivia replaced.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeExtensions.WithTrailingTrivia``1(``0,System.Collections.Generic.IEnumerable{Loretta.CodeAnalysis.SyntaxTrivia})">
            <summary>
            Creates a new node from this node with the trailing trivia replaced.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeExtensions.WithoutTrailingTrivia``1(``0)">
            <summary>
            Creates a new node from this node with the trailing trivia removed.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeExtensions.WithTrailingTrivia``1(``0,Loretta.CodeAnalysis.SyntaxTrivia[])">
            <summary>
            Creates a new node from this node with the trailing trivia replaced.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeExtensions.AsRootOfNewTreeWithOptionsFrom(Loretta.CodeAnalysis.SyntaxNode,Loretta.CodeAnalysis.SyntaxTree)">
            <summary>
            Attaches the node to a SyntaxTree that the same options as <paramref name="oldTree"/>
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeExtensions.TrackNodes``1(``0,System.Collections.Generic.IEnumerable{Loretta.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a new tree of nodes with the specified nodes being tracked.
            
            Use GetCurrentNode on the subtree resulting from this operation, or any transformation of it,
            to get the current node corresponding to the original tracked node.
            </summary>
            <param name="root">The root of the subtree containing the nodes to be tracked.</param>
            <param name="nodes">One or more nodes that are descendants of the root node.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeExtensions.TrackNodes``1(``0,Loretta.CodeAnalysis.SyntaxNode[])">
            <summary>
            Creates a new tree of nodes with the specified nodes being tracked.
            
            Use GetCurrentNode on the subtree resulting from this operation, or any transformation of it,
            to get the current node corresponding to the original tracked node.
            </summary>
            <param name="root">The root of the subtree containing the nodes to be tracked.</param>
            <param name="nodes">One or more nodes that are descendants of the root node.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeExtensions.GetCurrentNodes``1(Loretta.CodeAnalysis.SyntaxNode,``0)">
            <summary>
            Gets the nodes within the subtree corresponding to the original tracked node.
            Use TrackNodes to start tracking nodes.
            </summary>
            <param name="root">The root of the subtree containing the current node corresponding to the original tracked node.</param>
            <param name="node">The node instance originally tracked.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeExtensions.GetCurrentNode``1(Loretta.CodeAnalysis.SyntaxNode,``0)">
            <summary>
            Gets the node within the subtree corresponding to the original tracked node.
            Use TrackNodes to start tracking nodes.
            </summary>
            <param name="root">The root of the subtree containing the current node corresponding to the original tracked node.</param>
            <param name="node">The node instance originally tracked.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeExtensions.GetCurrentNodes``1(Loretta.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Gets the nodes within the subtree corresponding to the original tracked nodes.
            Use TrackNodes to start tracking nodes.
            </summary>
            <param name="root">The root of the subtree containing the current nodes corresponding to the original tracked nodes.</param>
            <param name="nodes">One or more node instances originally tracked.</param>
        </member>
        <member name="T:Loretta.CodeAnalysis.SyntaxNodeOrToken">
            <summary>
            A wrapper for either a syntax node (<see cref="T:Loretta.CodeAnalysis.SyntaxNode"/>) or a syntax token (<see
            cref="T:Loretta.CodeAnalysis.SyntaxToken"/>).
            </summary>
            <remarks>
            Note that we do not store the token directly, we just store enough information to reconstruct it.
            This allows us to reuse nodeOrToken as a token's parent.
            </remarks>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxNodeOrToken.RawKind">
            <summary>
            An integer representing the language specific kind of the underlying node or token.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxNodeOrToken.Language">
            <summary>
            The language name that this node or token is syntax of.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxNodeOrToken.IsMissing">
            <summary>
            Determines whether the underlying node or token represents a language construct that was actually parsed
            from source code. Missing nodes and tokens are typically generated by the parser in error scenarios to
            represent constructs that should have been present in the source code for the source code to compile
            successfully but were actually missing.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxNodeOrToken.Parent">
            <summary>
            The node that contains the underlying node or token in its Children collection.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxNodeOrToken.IsToken">
            <summary>
            Determines whether this <see cref="T:Loretta.CodeAnalysis.SyntaxNodeOrToken"/> is wrapping a token.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxNodeOrToken.IsNode">
            <summary>
            Determines whether this <see cref="T:Loretta.CodeAnalysis.SyntaxNodeOrToken"/> is wrapping a node.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeOrToken.AsToken">
            <summary>
            Returns the underlying token if this <see cref="T:Loretta.CodeAnalysis.SyntaxNodeOrToken"/> is wrapping a
            token.
            </summary>
            <returns>
            The underlying token if this <see cref="T:Loretta.CodeAnalysis.SyntaxNodeOrToken"/> is wrapping a token.
            </returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeOrToken.AsNode">
            <summary>
            Returns the underlying node if this <see cref="T:Loretta.CodeAnalysis.SyntaxNodeOrToken"/> is wrapping a
            node.
            </summary>
            <returns>
            The underlying node if this <see cref="T:Loretta.CodeAnalysis.SyntaxNodeOrToken"/> is wrapping a node.
            </returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeOrToken.ChildNodesAndTokens">
            <summary>
            The list of child nodes and tokens of the underlying node or token.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxNodeOrToken.Span">
            <summary>
            The absolute span of the underlying node or token in characters, not including its leading and trailing
            trivia.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxNodeOrToken.SpanStart">
            <summary>
            Same as accessing <see cref="P:Loretta.CodeAnalysis.Text.TextSpan.Start"/> on <see cref="P:Loretta.CodeAnalysis.SyntaxNodeOrToken.Span"/>.
            </summary>
            <remarks>
            Slight performance improvement.
            </remarks>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxNodeOrToken.FullSpan">
            <summary>
            The absolute span of the underlying node or token in characters, including its leading and trailing trivia.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeOrToken.ToString">
            <summary>
            Returns the string representation of this node or token, not including its leading and trailing
            trivia.
            </summary>
            <returns>
            The string representation of this node or token, not including its leading and trailing trivia.
            </returns>
            <remarks>The length of the returned string is always the same as Span.Length</remarks>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeOrToken.ToFullString">
            <summary>
            Returns the full string representation of this node or token including its leading and trailing trivia.
            </summary>
            <returns>The full string representation of this node or token including its leading and trailing
            trivia.</returns>
            <remarks>The length of the returned string is always the same as FullSpan.Length</remarks>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeOrToken.WriteTo(System.IO.TextWriter)">
            <summary>
            Writes the full text of this node or token to the specified TextWriter.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxNodeOrToken.HasLeadingTrivia">
            <summary>
            Determines whether the underlying node or token has any leading trivia.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeOrToken.GetLeadingTrivia">
            <summary>
            The list of trivia that appear before the underlying node or token in the source code and are attached to a
            token that is a descendant of the underlying node or token.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxNodeOrToken.HasTrailingTrivia">
            <summary>
            Determines whether the underlying node or token has any trailing trivia.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeOrToken.GetTrailingTrivia">
            <summary>
            The list of trivia that appear after the underlying node or token in the source code and are attached to a
            token that is a descendant of the underlying node or token.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeOrToken.WithLeadingTrivia(System.Collections.Generic.IEnumerable{Loretta.CodeAnalysis.SyntaxTrivia})">
            <summary>
            Returns this <see cref="T:Loretta.CodeAnalysis.SyntaxNode"/> or <see cref="T:Loretta.CodeAnalysis.SyntaxToken"/> with the provided
            leading trivia.
            </summary>
            <param name="trivia"></param>
            <returns></returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeOrToken.WithLeadingTrivia(Loretta.CodeAnalysis.SyntaxTrivia[])">
            <inheritdoc cref="M:Loretta.CodeAnalysis.SyntaxNodeOrToken.WithLeadingTrivia(System.Collections.Generic.IEnumerable{Loretta.CodeAnalysis.SyntaxTrivia})"/>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeOrToken.WithTrailingTrivia(System.Collections.Generic.IEnumerable{Loretta.CodeAnalysis.SyntaxTrivia})">
            <summary>
            Returns this <see cref="T:Loretta.CodeAnalysis.SyntaxNode"/> or <see cref="T:Loretta.CodeAnalysis.SyntaxToken"/> with the provided
            trailing trivia.
            </summary>
            <param name="trivia"></param>
            <returns></returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeOrToken.WithTrailingTrivia(Loretta.CodeAnalysis.SyntaxTrivia[])">
            <inheritdoc cref="M:Loretta.CodeAnalysis.SyntaxNodeOrToken.WithTrailingTrivia(System.Collections.Generic.IEnumerable{Loretta.CodeAnalysis.SyntaxTrivia})"/>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxNodeOrToken.ContainsDiagnostics">
            <summary>
            Determines whether the underlying node or token or any of its descendant nodes, tokens or trivia have any
            diagnostics on them. 
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeOrToken.GetDiagnostics">
            <summary>
            Gets a list of all the diagnostics in either the sub tree that has this node as its root or
            associated with this token and its related trivia. 
            This method does not filter diagnostics based on #pragmas and compiler options
            like nowarn, warnaserror etc.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxNodeOrToken.ContainsDirectives">
            <summary>
            Determines whether the underlying node or token has any descendant preprocessor directives.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxNodeOrToken.ContainsAnnotations">
            <summary>
            Determines whether this node or token (or any sub node, token or trivia) as annotations.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeOrToken.HasAnnotations(System.String)">
            <summary>
            Determines whether this node or token has annotations of the specified kind.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeOrToken.HasAnnotations(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Determines whether this node or token has annotations of the specified kind.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeOrToken.HasAnnotation(Loretta.CodeAnalysis.SyntaxAnnotation)">
            <summary>
            Determines if this node or token has the specific annotation.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeOrToken.GetAnnotations(System.String)">
            <summary>
            Gets all annotations of the specified annotation kind.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeOrToken.GetAnnotations(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Gets all annotations of the specified annotation kind.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeOrToken.WithAdditionalAnnotations(Loretta.CodeAnalysis.SyntaxAnnotation[])">
            <summary>
            Creates a new node or token identical to this one with the specified annotations.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeOrToken.WithAdditionalAnnotations(System.Collections.Generic.IEnumerable{Loretta.CodeAnalysis.SyntaxAnnotation})">
            <summary>
            Creates a new node or token identical to this one with the specified annotations.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeOrToken.WithoutAnnotations(Loretta.CodeAnalysis.SyntaxAnnotation[])">
            <summary>
            Creates a new node or token identical to this one without the specified annotations.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeOrToken.WithoutAnnotations(System.Collections.Generic.IEnumerable{Loretta.CodeAnalysis.SyntaxAnnotation})">
            <summary>
            Creates a new node or token identical to this one without the specified annotations.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeOrToken.WithoutAnnotations(System.String)">
            <summary>
            Creates a new node or token identical to this one without annotations of the specified kind.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeOrToken.Equals(Loretta.CodeAnalysis.SyntaxNodeOrToken)">
            <summary>
            Determines whether the supplied <see cref="T:Loretta.CodeAnalysis.SyntaxNodeOrToken"/> is equal to this
            <see cref="T:Loretta.CodeAnalysis.SyntaxNodeOrToken"/>.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeOrToken.op_Equality(Loretta.CodeAnalysis.SyntaxNodeOrToken,Loretta.CodeAnalysis.SyntaxNodeOrToken)">
            <summary>
            Determines whether two <see cref="T:Loretta.CodeAnalysis.SyntaxNodeOrToken"/>s are equal.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeOrToken.op_Inequality(Loretta.CodeAnalysis.SyntaxNodeOrToken,Loretta.CodeAnalysis.SyntaxNodeOrToken)">
            <summary>
            Determines whether two <see cref="T:Loretta.CodeAnalysis.SyntaxNodeOrToken"/>s are unequal.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeOrToken.Equals(System.Object)">
            <summary>
            Determines whether the supplied <see cref="T:Loretta.CodeAnalysis.SyntaxNodeOrToken"/> is equal to this
            <see cref="T:Loretta.CodeAnalysis.SyntaxNodeOrToken"/>.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeOrToken.GetHashCode">
            <summary>
            Serves as hash function for <see cref="T:Loretta.CodeAnalysis.SyntaxNodeOrToken"/>.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeOrToken.IsEquivalentTo(Loretta.CodeAnalysis.SyntaxNodeOrToken)">
            <summary>
            Determines if the two nodes or tokens are equivalent.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeOrToken.IsIncrementallyIdenticalTo(Loretta.CodeAnalysis.SyntaxNodeOrToken)">
            <summary>
            See <see cref="M:Loretta.CodeAnalysis.SyntaxNode.IsIncrementallyIdenticalTo(Loretta.CodeAnalysis.SyntaxNode)"/> and <see cref="M:Loretta.CodeAnalysis.SyntaxToken.IsIncrementallyIdenticalTo(Loretta.CodeAnalysis.SyntaxToken)"/>.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeOrToken.op_Implicit(Loretta.CodeAnalysis.SyntaxToken)~Loretta.CodeAnalysis.SyntaxNodeOrToken">
            <summary>
            Returns a new <see cref="T:Loretta.CodeAnalysis.SyntaxNodeOrToken"/> that wraps the supplied token.
            </summary>
            <param name="token">The input token.</param>
            <returns>
            A <see cref="T:Loretta.CodeAnalysis.SyntaxNodeOrToken"/> that wraps the supplied token.
            </returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeOrToken.op_Explicit(Loretta.CodeAnalysis.SyntaxNodeOrToken)~Loretta.CodeAnalysis.SyntaxToken">
            <summary>
            Returns the underlying token wrapped by the supplied <see cref="T:Loretta.CodeAnalysis.SyntaxNodeOrToken"/>.
            </summary>
            <param name="nodeOrToken">
            The input <see cref="T:Loretta.CodeAnalysis.SyntaxNodeOrToken"/>.
            </param>
            <returns>
            The underlying token wrapped by the supplied <see cref="T:Loretta.CodeAnalysis.SyntaxNodeOrToken"/>.
            </returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeOrToken.op_Implicit(Loretta.CodeAnalysis.SyntaxNode)~Loretta.CodeAnalysis.SyntaxNodeOrToken">
            <summary>
            Returns a new <see cref="T:Loretta.CodeAnalysis.SyntaxNodeOrToken"/> that wraps the supplied node.
            </summary>
            <param name="node">The input node.</param>
            <returns>
            A <see cref="T:Loretta.CodeAnalysis.SyntaxNodeOrToken"/> that wraps the supplied node.
            </returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeOrToken.op_Explicit(Loretta.CodeAnalysis.SyntaxNodeOrToken)~Loretta.CodeAnalysis.SyntaxNode">
            <summary>
            Returns the underlying node wrapped by the supplied <see cref="T:Loretta.CodeAnalysis.SyntaxNodeOrToken"/>.
            </summary>
            <param name="nodeOrToken">
            The input <see cref="T:Loretta.CodeAnalysis.SyntaxNodeOrToken"/>.
            </param>
            <returns>
            The underlying node wrapped by the supplied <see cref="T:Loretta.CodeAnalysis.SyntaxNodeOrToken"/>.
            </returns>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxNodeOrToken.SyntaxTree">
            <summary>
            SyntaxTree which contains current SyntaxNodeOrToken.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeOrToken.GetLocation">
            <summary>
            Get the location of this node or token.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeOrToken.GetFirstChildIndexSpanningPosition(Loretta.CodeAnalysis.SyntaxNode,System.Int32)">
            <summary>
            Returns the index of the first child of the provided node that contains the provided position.
            </summary>
            <param name="node"></param>
            <param name="position"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentException">
            Thrown when the provided position is outside of the node's span.
            </exception>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeOrToken.GetNextSibling">
            <summary>
            Returns the sibling to the right of this node or token.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeOrToken.GetPreviousSibling">
            <summary>
            Returns the sibling to the left of this node or token.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Loretta.CodeAnalysis.SyntaxNodeOrTokenList">
            <summary>
            A list of <see cref="T:Loretta.CodeAnalysis.SyntaxNodeOrToken"/> structures.
            </summary>
        </member>
        <member name="F:Loretta.CodeAnalysis.SyntaxNodeOrTokenList._node">
            <summary>
            The underlying field
            </summary>
        </member>
        <member name="F:Loretta.CodeAnalysis.SyntaxNodeOrTokenList.index">
            <summary>
            The index from the parent's children list of this node.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeOrTokenList.#ctor(Loretta.CodeAnalysis.SyntaxNode,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Loretta.CodeAnalysis.SyntaxNodeOrTokenList"/> structure.
            </summary>
            <param name="node">The underlying syntax node.</param>
            <param name="index">The index.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeOrTokenList.#ctor(System.Collections.Generic.IEnumerable{Loretta.CodeAnalysis.SyntaxNodeOrToken})">
            <summary>
            Create a <see cref="T:Loretta.CodeAnalysis.SyntaxNodeOrTokenList"/> from a sequence of <see cref="T:Loretta.CodeAnalysis.SyntaxNodeOrToken"/>.
            </summary>
            <param name="nodesAndTokens">The sequence of nodes and tokens</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeOrTokenList.#ctor(Loretta.CodeAnalysis.SyntaxNodeOrToken[])">
            <summary>
            Create a <see cref="T:Loretta.CodeAnalysis.SyntaxNodeOrTokenList"/> from one or more <see cref="T:Loretta.CodeAnalysis.SyntaxNodeOrToken"/>.
            </summary>
            <param name="nodesAndTokens">The nodes and tokens</param>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxNodeOrTokenList.Node">
            <summary>
            Gets the underlying syntax node.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxNodeOrTokenList.Count">
            <summary>
            Gets the count of nodes in this list
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxNodeOrTokenList.Item(System.Int32)">
            <summary>
            Gets the <see cref="T:Loretta.CodeAnalysis.SyntaxNodeOrToken"/> at the specified index. 
            </summary>
            <exception cref="T:System.IndexOutOfRangeException"><paramref name="index"/> is out of range.</exception>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxNodeOrTokenList.FullSpan">
            <summary>
            The absolute span of the list elements in characters, including the leading and trailing trivia of the first and last elements.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxNodeOrTokenList.Span">
            <summary>
            The absolute span of the list elements in characters, not including the leading and trailing trivia of the first and last elements.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeOrTokenList.ToString">
            <summary>
            Returns the string representation of the nodes and tokens in this list, not including the first node or token's leading trivia 
            and the last node or token's trailing trivia.
            </summary>
            <returns>
            The string representation of the nodes and tokens in this list, not including the first node or token's leading trivia 
            and the last node or token's trailing trivia.
            </returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeOrTokenList.ToFullString">
            <summary>
            Returns the full string representation of the nodes and tokens in this list including the first node or token's leading trivia 
            and the last node or token's trailing trivia.
            </summary>
            <returns>
            The full string representation of the nodes and tokens in this list including the first node or token's leading trivia 
            and the last node or token's trailing trivia.
            </returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeOrTokenList.First">
            <summary>
            Gets the first SyntaxNodeOrToken structure from this list.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeOrTokenList.FirstOrDefault">
            <summary>
            Gets the first SyntaxNodeOrToken structure from this list if present, else default(SyntaxNodeOrToken).
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeOrTokenList.Last">
            <summary>
            Gets the last SyntaxNodeOrToken structure from this list.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeOrTokenList.LastOrDefault">
            <summary>
            Gets the last SyntaxNodeOrToken structure from this list if present, else default(SyntaxNodeOrToken).
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeOrTokenList.IndexOf(Loretta.CodeAnalysis.SyntaxNodeOrToken)">
            <summary>
            Returns the index from the list for the given <see cref="T:Loretta.CodeAnalysis.SyntaxNodeOrToken"/>.
            </summary>
            <param name="nodeOrToken">The node or token to search for in the list.</param>
            <returns>The index of the found nodeOrToken, or -1 if it wasn't found</returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeOrTokenList.Any">
            <summary>
            Indicates whether there is any element in the list.
            </summary>
            <returns><c>true</c> if there are any elements in the list, else <c>false</c>.</returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeOrTokenList.CopyTo(System.Int32,Loretta.CodeAnalysis.GreenNode[],System.Int32,System.Int32)">
            <summary>
            Copies a given count of elements into the given array at specified offsets.
            </summary>
            <param name="offset">The offset to start copying from.</param>
            <param name="array">The array to copy the elements into.</param>
            <param name="arrayOffset">The array offset to start writing to.</param>
            <param name="count">The count of elements to copy.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeOrTokenList.Add(Loretta.CodeAnalysis.SyntaxNodeOrToken)">
            <summary>
            Creates a new <see cref="T:Loretta.CodeAnalysis.SyntaxNodeOrTokenList"/> with the specified node or token added to the end.
            </summary>
            <param name="nodeOrToken">The node or token to add.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeOrTokenList.AddRange(System.Collections.Generic.IEnumerable{Loretta.CodeAnalysis.SyntaxNodeOrToken})">
            <summary>
            Creates a new <see cref="T:Loretta.CodeAnalysis.SyntaxNodeOrTokenList"/> with the specified nodes or tokens added to the end.
            </summary>
            <param name="nodesOrTokens">The nodes or tokens to add.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeOrTokenList.Insert(System.Int32,Loretta.CodeAnalysis.SyntaxNodeOrToken)">
            <summary>
            Creates a new <see cref="T:Loretta.CodeAnalysis.SyntaxNodeOrTokenList"/> with the specified node or token inserted at the index.
            </summary>
            <param name="index">The index to insert at.</param>
            <param name="nodeOrToken">The node or token to insert.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeOrTokenList.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{Loretta.CodeAnalysis.SyntaxNodeOrToken})">
            <summary>
            Creates a new <see cref="T:Loretta.CodeAnalysis.SyntaxNodeOrTokenList"/> with the specified nodes or tokens inserted at the index.
            </summary>
            <param name="index">The index to insert at.</param>
            <param name="nodesAndTokens">The nodes or tokens to insert.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeOrTokenList.RemoveAt(System.Int32)">
            <summary>
            Creates a new <see cref="T:Loretta.CodeAnalysis.SyntaxNodeOrTokenList"/> with the element at the specified index removed.
            </summary>
            <param name="index">The index of the element to remove.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeOrTokenList.Remove(Loretta.CodeAnalysis.SyntaxNodeOrToken)">
            <summary>
            Creates a new <see cref="T:Loretta.CodeAnalysis.SyntaxNodeOrTokenList"/> with the specified element removed.
            </summary>
            <param name="nodeOrTokenInList">The element to remove.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeOrTokenList.Replace(Loretta.CodeAnalysis.SyntaxNodeOrToken,Loretta.CodeAnalysis.SyntaxNodeOrToken)">
            <summary>
            Creates a new <see cref="T:Loretta.CodeAnalysis.SyntaxNodeOrTokenList"/> with the specified element replaced with a new node or token.
            </summary>
            <param name="nodeOrTokenInList">The element to replace.</param>
            <param name="newNodeOrToken">The new node or token.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeOrTokenList.ReplaceRange(Loretta.CodeAnalysis.SyntaxNodeOrToken,System.Collections.Generic.IEnumerable{Loretta.CodeAnalysis.SyntaxNodeOrToken})">
            <summary>
            Creates a new <see cref="T:Loretta.CodeAnalysis.SyntaxNodeOrTokenList"/> with the specified element replaced with a new nodes and tokens.
            </summary>
            <param name="nodeOrTokenInList">The element to replace.</param>
            <param name="newNodesAndTokens">The new nodes and tokens.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeOrTokenList.GetEnumerator">
            <summary>
            Gets the enumerator.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeOrTokenList.System#Collections#Generic#IEnumerable{Loretta#CodeAnalysis#SyntaxNodeOrToken}#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeOrTokenList.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeOrTokenList.op_Equality(Loretta.CodeAnalysis.SyntaxNodeOrTokenList,Loretta.CodeAnalysis.SyntaxNodeOrTokenList)">
            <summary>
            Implements the operator ==.
            </summary>
            <param name="left">The left SyntaxNodeOrTokenList</param>
            <param name="right">The right SyntaxNodeOrTokenList</param>
            <returns>
            <c>true</c> if both lists equal, else <c>false</c>.
            </returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeOrTokenList.op_Inequality(Loretta.CodeAnalysis.SyntaxNodeOrTokenList,Loretta.CodeAnalysis.SyntaxNodeOrTokenList)">
            <summary>
            Implements the operator !=.
            </summary>
            <param name="left">The left SyntaxNodeOrTokenList</param>
            <param name="right">The right SyntaxNodeOrTokenList</param>
            <returns>
            <c>true</c> if both lists not equal, else <c>false</c>.
            </returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeOrTokenList.Equals(Loretta.CodeAnalysis.SyntaxNodeOrTokenList)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <param name="other">An object to compare with this object.</param>
            <returns>
            <c>true</c> if the current object is equal to the <paramref name="other"/> parameter; otherwise,
            <c>false</c>.
            </returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeOrTokenList.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to this instance.
            </summary>
            <param name="obj">The <see cref="T:System.Object"/> to compare with this instance.</param>
            <returns>
              <c>true</c> if the specified <see cref="T:System.Object"/> is equal to this instance; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeOrTokenList.GetHashCode">
            <summary>
            Returns a hash code for this instance.
            </summary>
            <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table. 
            </returns>
        </member>
        <member name="T:Loretta.CodeAnalysis.SyntaxNodeOrTokenList.Enumerator">
            <summary>
            Enumerator for lists of SyntaxNodeOrToken structs.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeOrTokenList.Enumerator.MoveNext">
            <inheritdoc cref="M:System.Collections.IEnumerator.MoveNext"/>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxNodeOrTokenList.Enumerator.Current">
            <inheritdoc cref="P:System.Collections.Generic.IEnumerator`1.Current"/>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeOrTokenList.Enumerator.System#Collections#IEnumerator#Reset">
            <inheritdoc cref="M:System.Collections.IEnumerator.Reset"/>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeOrTokenList.Enumerator.System#IDisposable#Dispose">
            <inheritdoc cref="M:System.IDisposable.Dispose"/>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeOrTokenList.Enumerator.Equals(System.Object)">
            <summary>
            Not supported. Do not use.
            </summary>
            <param name="obj"></param>
            <returns></returns>
            <exception cref="T:System.NotSupportedException">
            Always thrown.
            </exception>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeOrTokenList.Enumerator.GetHashCode">
            <summary>
            Not supported. Do not use.
            </summary>
            <returns></returns>
            <exception cref="T:System.NotSupportedException">
            Always thrown.
            </exception>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeOrTokenList.Enumerator.op_Equality(Loretta.CodeAnalysis.SyntaxNodeOrTokenList.Enumerator,Loretta.CodeAnalysis.SyntaxNodeOrTokenList.Enumerator)">
            <summary>
            Not supported. Do not use.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
            <exception cref="T:System.NotSupportedException">
            Always thrown.
            </exception>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxNodeOrTokenList.Enumerator.op_Inequality(Loretta.CodeAnalysis.SyntaxNodeOrTokenList.Enumerator,Loretta.CodeAnalysis.SyntaxNodeOrTokenList.Enumerator)">
            <summary>
            Not supported. Do not use.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
            <exception cref="T:System.NotSupportedException">
            Always thrown.
            </exception>
        </member>
        <member name="T:Loretta.CodeAnalysis.SyntaxReference">
            <summary>
            A reference to a syntax node.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxReference.SyntaxTree">
            <summary>
            The syntax tree that this references a node within.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxReference.Span">
            <summary>
            The span of the node referenced.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxReference.GetSyntax(System.Threading.CancellationToken)">
            <summary>
            Retrieves the original referenced syntax node.  
            This action may cause a parse to happen to recover the syntax node.
            </summary>
            <returns>The original referenced syntax node.</returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxReference.GetSyntaxAsync(System.Threading.CancellationToken)">
            <summary>
            Retrieves the original referenced syntax node.  
            This action may cause a parse to happen to recover the syntax node.
            </summary>
            <returns>The original referenced syntax node.</returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxReference.GetLocation">
            <summary>
            The location of this syntax reference.
            </summary>
            <returns>The location of this syntax reference.</returns>
            <remarks>
            More performant than GetSyntax().GetLocation().
            </remarks>
        </member>
        <member name="T:Loretta.CodeAnalysis.SyntaxRemoveOptions">
            <summary>
            The option flags for the RemoveNode(s) methods.
            </summary>
        </member>
        <member name="F:Loretta.CodeAnalysis.SyntaxRemoveOptions.KeepNoTrivia">
            <summary>
            None of the trivia associated with the node or token is kept.
            </summary>
        </member>
        <member name="F:Loretta.CodeAnalysis.SyntaxRemoveOptions.KeepLeadingTrivia">
            <summary>
            The leading trivia associated with the node or token is kept.
            </summary>
        </member>
        <member name="F:Loretta.CodeAnalysis.SyntaxRemoveOptions.KeepTrailingTrivia">
            <summary>
            The trailing trivia associated with the node or token is kept.
            </summary>
        </member>
        <member name="F:Loretta.CodeAnalysis.SyntaxRemoveOptions.KeepExteriorTrivia">
            <summary>
            The leading and trailing trivia associated with the node or token is kept.
            </summary>
        </member>
        <member name="F:Loretta.CodeAnalysis.SyntaxRemoveOptions.KeepUnbalancedDirectives">
            <summary>
            Any directives that would become unbalanced are kept.
            </summary>
        </member>
        <member name="F:Loretta.CodeAnalysis.SyntaxRemoveOptions.KeepDirectives">
            <summary>
            All directives are kept
            </summary>
        </member>
        <member name="F:Loretta.CodeAnalysis.SyntaxRemoveOptions.KeepEndOfLine">
            <summary>
            Ensure that at least one EndOfLine trivia is kept if one was present 
            </summary>
        </member>
        <member name="F:Loretta.CodeAnalysis.SyntaxRemoveOptions.AddElasticMarker">
            <summary>
            Adds elastic marker trivia
            </summary>
        </member>
        <member name="T:Loretta.CodeAnalysis.SyntaxToken">
            <summary>
            Represents a token in the syntax tree.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxToken.RawKind">
            <summary>
            An integer representing the language specific kind of this token.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxToken.Language">
            <summary>
            The language name that this token is syntax of.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxToken.RawContextualKind">
            <summary>
            The kind of token, given its position in the syntax. This differs from <see
            cref="P:Loretta.CodeAnalysis.SyntaxToken.RawKind"/> when a contextual keyword is used in a place in the syntax that gives it
            its keyword meaning.
            </summary>
            <remarks>
            The ContextualKind is relevant only on contextual keyword tokens. ContextualKind differs
            from Kind when a token is used in context where the token should be interpreted as a
            keyword.
            </remarks>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxToken.Parent">
            <summary>
            The node that contains this token in its Children collection.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxToken.Width">
            <summary>
            The width of the token in characters, not including its leading and trailing trivia.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxToken.FullWidth">
            <summary>
            The complete width of the token in characters including its leading and trailing trivia.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxToken.Span">
            <summary>
            The absolute span of this token in characters, not including its leading and trailing trivia.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxToken.SpanStart">
            <summary>
            Same as accessing <see cref="P:Loretta.CodeAnalysis.Text.TextSpan.Start"/> on <see cref="P:Loretta.CodeAnalysis.SyntaxToken.Span"/>.
            </summary>
            <remarks>
            Slight performance improvement.
            </remarks>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxToken.FullSpan">
            <summary>
            The absolute span of this token in characters, including its leading and trailing trivia.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxToken.IsMissing">
            <summary>
            Determines whether this token represents a language construct that was actually parsed from source code.
            Missing tokens are typically generated by the parser in error scenarios to represent constructs that should
            have been present in the source code for the source code to compile successfully but were actually missing.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxToken.Value">
            <summary>
            Returns the value of the token. For example, if the token represents an integer literal, then this property
            would return the actual integer.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxToken.ValueText">
            <summary>
            Returns the text representation of the value of the token. For example, if the token represents an integer
            literal, then this property would return a string representing the integer.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxToken.Text">
            <summary>
            The token's text.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxToken.ToString">
            <summary>
            Returns the string representation of this token, not including its leading and trailing trivia.
            </summary>
            <returns>The string representation of this token, not including its leading and trailing trivia.</returns>
            <remarks>The length of the returned string is always the same as Span.Length</remarks>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxToken.ToFullString">
            <summary>
            Returns the full string representation of this token including its leading and trailing trivia.
            </summary>
            <returns>The full string representation of this token including its leading and trailing trivia.</returns>
            <remarks>The length of the returned string is always the same as FullSpan.Length</remarks>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxToken.WriteTo(System.IO.TextWriter)">
            <summary>
            Writes the full text of this token to the specified <paramref name="writer"/>.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxToken.WriteTo(System.IO.TextWriter,System.Boolean,System.Boolean)">
            <summary>
            Writes the text of this token to the specified TextWriter, optionally including trivia.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxToken.HasLeadingTrivia">
            <summary>
            Determines whether this token has any leading trivia.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxToken.HasTrailingTrivia">
            <summary>
            Determines whether this token has any trailing trivia.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxToken.LeadingWidth">
            <summary>
            Full width of the leading trivia of this token.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxToken.TrailingWidth">
            <summary>
            Full width of the trailing trivia of this token.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxToken.ContainsDiagnostics">
            <summary>
            Determines whether this token or any of its descendant trivia have any diagnostics on them. 
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxToken.ContainsDirectives">
            <summary>
            Determines whether this token has any descendant preprocessor directives.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxToken.IsPartOfStructuredTrivia">
            <summary>
            Determines whether this token is a descendant of a structured trivia.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxToken.HasStructuredTrivia">
            <summary>
            Determines whether any of this token's trivia is structured.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxToken.ContainsAnnotations">
            <summary>
            True if this token or its trivia has any annotations.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxToken.HasAnnotations(System.String)">
            <summary>
            True if this token has annotations of the specified annotation kind.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxToken.HasAnnotations(System.String[])">
            <summary>
            True if this token has annotations of the specified annotation kinds.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxToken.HasAnnotation(Loretta.CodeAnalysis.SyntaxAnnotation)">
            <summary>
            True if this token has the specified annotation.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxToken.GetAnnotations(System.String)">
            <summary>
            Gets all the annotations of the specified annotation kind.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxToken.GetAnnotations(System.String[])">
            <summary>
            Gets all the annotations of the specified annotation kind.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxToken.GetAnnotations(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Gets all the annotations of the specified annotation kind.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxToken.WithAdditionalAnnotations(Loretta.CodeAnalysis.SyntaxAnnotation[])">
            <summary>
            Adds this annotation to a given syntax token, creating a new syntax token of the same type with the
            annotation on it.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxToken.WithAdditionalAnnotations(System.Collections.Generic.IEnumerable{Loretta.CodeAnalysis.SyntaxAnnotation})">
            <summary>
            Adds this annotation to a given syntax token, creating a new syntax token of the same type with the
            annotation on it.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxToken.WithoutAnnotations(Loretta.CodeAnalysis.SyntaxAnnotation[])">
            <summary>
            Creates a new syntax token identical to this one without the specified annotations.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxToken.WithoutAnnotations(System.Collections.Generic.IEnumerable{Loretta.CodeAnalysis.SyntaxAnnotation})">
            <summary>
            Creates a new syntax token identical to this one without the specified annotations.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxToken.WithoutAnnotations(System.String)">
            <summary>
            Creates a new syntax token identical to this one without annotations of the specified kind.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxToken.CopyAnnotationsTo(Loretta.CodeAnalysis.SyntaxToken)">
            <summary>
            Copies all SyntaxAnnotations, if any, from this SyntaxToken instance and attaches them to a new instance based on <paramref name="token" />.
            </summary>
            <remarks>
            If no annotations are copied, just returns <paramref name="token" />.
            </remarks>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxToken.LeadingTrivia">
            <summary>
            The list of trivia that appear before this token in the source code.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxToken.TrailingTrivia">
            <summary>
            The list of trivia that appear after this token in the source code and are attached to this token or any of
            its descendants.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxToken.WithTriviaFrom(Loretta.CodeAnalysis.SyntaxToken)">
            <summary>
            Creates a new token from this token with the leading and trailing trivia from the specified token.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxToken.WithLeadingTrivia(Loretta.CodeAnalysis.SyntaxTriviaList)">
            <summary>
            Creates a new token from this token with the leading trivia specified.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxToken.WithLeadingTrivia(Loretta.CodeAnalysis.SyntaxTrivia[])">
            <summary>
            Creates a new token from this token with the leading trivia specified..
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxToken.WithLeadingTrivia(System.Collections.Generic.IEnumerable{Loretta.CodeAnalysis.SyntaxTrivia})">
            <summary>
            Creates a new token from this token with the leading trivia specified.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxToken.WithTrailingTrivia(Loretta.CodeAnalysis.SyntaxTriviaList)">
            <summary>
            Creates a new token from this token with the trailing trivia specified.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxToken.WithTrailingTrivia(Loretta.CodeAnalysis.SyntaxTrivia[])">
            <summary>
            Creates a new token from this token with the trailing trivia specified.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxToken.WithTrailingTrivia(System.Collections.Generic.IEnumerable{Loretta.CodeAnalysis.SyntaxTrivia})">
            <summary>
            Creates a new token from this token with the trailing trivia specified.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxToken.GetAllTrivia">
            <summary>
            Gets a list of all the trivia (both leading and trailing) for this token.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxToken.op_Equality(Loretta.CodeAnalysis.SyntaxToken,Loretta.CodeAnalysis.SyntaxToken)">
            <summary>
            Determines whether two <see cref="T:Loretta.CodeAnalysis.SyntaxToken"/>s are equal.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxToken.op_Inequality(Loretta.CodeAnalysis.SyntaxToken,Loretta.CodeAnalysis.SyntaxToken)">
            <summary>
            Determines whether two <see cref="T:Loretta.CodeAnalysis.SyntaxToken"/>s are unequal.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxToken.Equals(Loretta.CodeAnalysis.SyntaxToken)">
            <summary>
            Determines whether the supplied <see cref="T:Loretta.CodeAnalysis.SyntaxToken"/> is equal to this
            <see cref="T:Loretta.CodeAnalysis.SyntaxToken"/>.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxToken.Equals(System.Object)">
            <summary>
            Determines whether the supplied <see cref="T:Loretta.CodeAnalysis.SyntaxToken"/> is equal to this
            <see cref="T:Loretta.CodeAnalysis.SyntaxToken"/>.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxToken.GetHashCode">
            <summary>
            Serves as hash function for <see cref="T:Loretta.CodeAnalysis.SyntaxToken"/>.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxToken.GetNextToken(System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Gets the token that follows this token in the syntax tree.
            </summary>
            <returns>The token that follows this token in the syntax tree.</returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxToken.GetNextToken(System.Func{Loretta.CodeAnalysis.SyntaxToken,System.Boolean},System.Func{Loretta.CodeAnalysis.SyntaxTrivia,System.Boolean})">
            <summary>
            Returns the token after this token in the syntax tree.
            </summary>
            <param name="predicate">Delegate applied to each token.  The token is returned if the predicate returns
            true.</param>
            <param name="stepInto">Delegate applied to trivia.  If this delegate is present then trailing trivia is
            included in the search.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxToken.GetPreviousToken(System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Gets the token that precedes this token in the syntax tree.
            </summary>
            <returns>The next token that follows this token in the syntax tree.</returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxToken.GetPreviousToken(System.Func{Loretta.CodeAnalysis.SyntaxToken,System.Boolean},System.Func{Loretta.CodeAnalysis.SyntaxTrivia,System.Boolean})">
            <summary>
            Returns the token before this token in the syntax tree.
            </summary>
            <param name="predicate">Delegate applied to each token.  The token is returned if the predicate returns
            true.</param>
            <param name="stepInto">Delegate applied to trivia.  If this delegate is present then trailing trivia is
            included in the search.</param>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxToken.SyntaxTree">
            <summary>
            The SyntaxTree that contains this token.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxToken.GetLocation">
            <summary>
            Gets the location for this token.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxToken.GetDiagnostics">
            <summary>
            Gets a list of all the diagnostics associated with this token and any related trivia.
            This method does not filter diagnostics based on #pragmas and compiler options
            like nowarn, warnaserror etc.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxToken.IsEquivalentTo(Loretta.CodeAnalysis.SyntaxToken)">
            <summary>
            Determines if this token is equivalent to the specified token.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxToken.IsIncrementallyIdenticalTo(Loretta.CodeAnalysis.SyntaxToken)">
            <summary>
            Returns true if these two tokens are considered "incrementally identical".  An incrementally identical token
            occurs when a <see cref="P:Loretta.CodeAnalysis.SyntaxToken.SyntaxTree"/> is incrementally parsed using <see cref="M:Loretta.CodeAnalysis.SyntaxTree.WithChangedText(Loretta.CodeAnalysis.Text.SourceText)"/>
            and the incremental parser is able to take the token from the original tree and use it in its entirety in the
            new tree.  In this case, the <see cref="M:Loretta.CodeAnalysis.SyntaxToken.ToFullString"/> of each token will be the same, though
            they could have different parents, and may occur at different positions in the respective trees.  If two tokens are
            incrementally identical, all trivial of each node will be incrementally identical as well.
            </summary>
            <remarks>
            Incrementally identical tokens can also appear within the same syntax tree, or syntax trees that did not arise
            from <see cref="M:Loretta.CodeAnalysis.SyntaxTree.WithChangedText(Loretta.CodeAnalysis.Text.SourceText)"/>.  This can happen as the parser is allowed to construct parse
            trees using shared tokens for efficiency.  In all these cases though, it will still remain true that the incrementally
            identical tokens could have different parents and may occur at different positions in their respective trees.
            </remarks>
        </member>
        <member name="T:Loretta.CodeAnalysis.SyntaxTokenList">
            <summary>
            Represents a read-only list of <see cref="T:Loretta.CodeAnalysis.SyntaxToken"/>.
            </summary>
            <summary>
             Represents a read-only list of <see cref="T:Loretta.CodeAnalysis.SyntaxToken"/>s.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTokenList.#ctor(Loretta.CodeAnalysis.SyntaxToken)">
            <summary>
            Creates a new token list with the provided token as its only element.
            </summary>
            <param name="token"></param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTokenList.#ctor(Loretta.CodeAnalysis.SyntaxToken[])">
            <summary>
            Creates a list of tokens.
            </summary>
            <param name="tokens">An array of tokens.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTokenList.#ctor(System.Collections.Generic.IEnumerable{Loretta.CodeAnalysis.SyntaxToken})">
            <summary>
            Creates a list of tokens.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxTokenList.Count">
            <summary>
            Returns the number of tokens in the list.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxTokenList.Item(System.Int32)">
            <summary>
            Gets the token at the specified index.
            </summary>
            <param name="index">The zero-based index of the token to get.</param>
            <returns>The token at the specified index.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="index" /> is less than 0.-or-<paramref name="index" /> is equal to or greater than <see cref="P:Loretta.CodeAnalysis.SyntaxTokenList.Count" />. </exception>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxTokenList.FullSpan">
            <summary>
            The absolute span of the list elements in characters, including the leading and trailing trivia of the first and last elements.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxTokenList.Span">
            <summary>
            The absolute span of the list elements in characters, not including the leading and trailing trivia of the first and last elements.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTokenList.ToString">
            <summary>
            Returns the string representation of the tokens in this list, not including 
            the first token's leading trivia and the last token's trailing trivia.
            </summary>
            <returns>
            The string representation of the tokens in this list, not including 
            the first token's leading trivia and the last token's trailing trivia.
            </returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTokenList.ToFullString">
            <summary>
            Returns the full string representation of the tokens in this list including 
            the first token's leading trivia and the last token's trailing trivia.
            </summary>
            <returns>
            The full string representation of the tokens in this list including 
            the first token's leading trivia and the last token's trailing trivia.
            </returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTokenList.First">
            <summary>
            Returns the first token in the list.
            </summary>
            <returns>The first token in the list.</returns>
            <exception cref="T:System.InvalidOperationException">The list is empty.</exception>        
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTokenList.Last">
            <summary>
            Returns the last token in the list.
            </summary>
            <returns> The last token in the list.</returns>
            <exception cref="T:System.InvalidOperationException">The list is empty.</exception>        
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTokenList.Any">
            <summary>
            Tests whether the list is non-empty.
            </summary>
            <returns>True if the list contains any tokens.</returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTokenList.Reverse">
            <summary>
            Returns a list which contains all elements of <see cref="T:Loretta.CodeAnalysis.SyntaxTokenList"/> in reversed order.
            </summary>
            <returns><see cref="T:Loretta.CodeAnalysis.SyntaxTokenList.Reversed"/> which contains all elements of <see cref="T:Loretta.CodeAnalysis.SyntaxTokenList"/> in reversed order</returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTokenList.GetGreenNodeAt(System.Int32)">
            <summary>
            get the green node at the given slot
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTokenList.GetGreenNodeAt(Loretta.CodeAnalysis.GreenNode,System.Int32)">
            <summary>
            get the green node at the given slot
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTokenList.IndexOf(Loretta.CodeAnalysis.SyntaxToken)">
            <summary>
            Retuns the index of the provided token in this list.
            </summary>
            <param name="tokenInList"></param>
            <returns>-1 if not found.</returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTokenList.Add(Loretta.CodeAnalysis.SyntaxToken)">
            <summary>
            Creates a new <see cref="T:Loretta.CodeAnalysis.SyntaxTokenList"/> with the specified token added to the end.
            </summary>
            <param name="token">The token to add.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTokenList.AddRange(System.Collections.Generic.IEnumerable{Loretta.CodeAnalysis.SyntaxToken})">
            <summary>
            Creates a new <see cref="T:Loretta.CodeAnalysis.SyntaxTokenList"/> with the specified tokens added to the end.
            </summary>
            <param name="tokens">The tokens to add.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTokenList.Insert(System.Int32,Loretta.CodeAnalysis.SyntaxToken)">
            <summary>
            Creates a new <see cref="T:Loretta.CodeAnalysis.SyntaxTokenList"/> with the specified token insert at the index.
            </summary>
            <param name="index">The index to insert the new token.</param>
            <param name="token">The token to insert.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTokenList.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{Loretta.CodeAnalysis.SyntaxToken})">
            <summary>
            Creates a new <see cref="T:Loretta.CodeAnalysis.SyntaxTokenList"/> with the specified tokens insert at the index.
            </summary>
            <param name="index">The index to insert the new tokens.</param>
            <param name="tokens">The tokens to insert.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTokenList.RemoveAt(System.Int32)">
            <summary>
            Creates a new <see cref="T:Loretta.CodeAnalysis.SyntaxTokenList"/> with the token at the specified index removed.
            </summary>
            <param name="index">The index of the token to remove.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTokenList.Remove(Loretta.CodeAnalysis.SyntaxToken)">
            <summary>
            Creates a new <see cref="T:Loretta.CodeAnalysis.SyntaxTokenList"/> with the specified token removed.
            </summary>
            <param name="tokenInList">The token to remove.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTokenList.Replace(Loretta.CodeAnalysis.SyntaxToken,Loretta.CodeAnalysis.SyntaxToken)">
            <summary>
            Creates a new <see cref="T:Loretta.CodeAnalysis.SyntaxTokenList"/> with the specified token replaced with a new token.
            </summary>
            <param name="tokenInList">The token to replace.</param>
            <param name="newToken">The new token.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTokenList.ReplaceRange(Loretta.CodeAnalysis.SyntaxToken,System.Collections.Generic.IEnumerable{Loretta.CodeAnalysis.SyntaxToken})">
            <summary>
            Creates a new <see cref="T:Loretta.CodeAnalysis.SyntaxTokenList"/> with the specified token replaced with new tokens.
            </summary>
            <param name="tokenInList">The token to replace.</param>
            <param name="newTokens">The new tokens.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTokenList.GetEnumerator">
            <summary>
            Returns an enumerator for the tokens in the <see cref="T:Loretta.CodeAnalysis.SyntaxTokenList"/>
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTokenList.op_Equality(Loretta.CodeAnalysis.SyntaxTokenList,Loretta.CodeAnalysis.SyntaxTokenList)">
            <summary>
            Compares <paramref name="left"/> and <paramref name="right"/> for equality.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns>True if the two <see cref="T:Loretta.CodeAnalysis.SyntaxTokenList"/>s are equal.</returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTokenList.op_Inequality(Loretta.CodeAnalysis.SyntaxTokenList,Loretta.CodeAnalysis.SyntaxTokenList)">
            <summary>
            Compares <paramref name="left"/> and <paramref name="right"/> for inequality.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns>True if the two <see cref="T:Loretta.CodeAnalysis.SyntaxTokenList"/>s are not equal.</returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTokenList.Equals(Loretta.CodeAnalysis.SyntaxTokenList)">
            <inheritdoc/>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTokenList.Equals(System.Object)">
            <summary>
            Compares this <see cref="T:Loretta.CodeAnalysis.SyntaxTokenList"/> with the <paramref name="obj"/> for equality.
            </summary>
            <returns>True if the two objects are equal.</returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTokenList.GetHashCode">
            <summary>
            Serves as a hash function for the <see cref="T:Loretta.CodeAnalysis.SyntaxTokenList"/>
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTokenList.Create(Loretta.CodeAnalysis.SyntaxToken)">
            <summary>
            Create a new Token List
            </summary>
            <param name="token">Element of the return Token List</param>
        </member>
        <member name="T:Loretta.CodeAnalysis.SyntaxTokenList.Enumerator">
            <summary>
            A structure for enumerating a <see cref="T:Loretta.CodeAnalysis.SyntaxTokenList"/>
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTokenList.Enumerator.MoveNext">
            <summary>
            Advances the enumerator to the next token in the collection.
            </summary>
            <returns>true if the enumerator was successfully advanced to the next element; false if the enumerator
            has passed the end of the collection.</returns>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxTokenList.Enumerator.Current">
            <summary>
            Gets the current element in the collection.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTokenList.Enumerator.Equals(System.Object)">
            <summary>
            Not supported. Do not use.
            </summary>
            <param name="obj"></param>
            <returns></returns>
            <exception cref="T:System.NotSupportedException">
            Always thrown.
            </exception>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTokenList.Enumerator.GetHashCode">
            <summary>
            Not supported. Do not use.
            </summary>
            <returns></returns>
            <exception cref="T:System.NotSupportedException">
            Always thrown.
            </exception>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTokenList.Enumerator.op_Equality(Loretta.CodeAnalysis.SyntaxTokenList.Enumerator,Loretta.CodeAnalysis.SyntaxTokenList.Enumerator)">
            <summary>
            Not supported. Do not use.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
            <exception cref="T:System.NotSupportedException">
            Always thrown.
            </exception>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTokenList.Enumerator.op_Inequality(Loretta.CodeAnalysis.SyntaxTokenList.Enumerator,Loretta.CodeAnalysis.SyntaxTokenList.Enumerator)">
            <summary>
            Not supported. Do not use.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
            <exception cref="T:System.NotSupportedException">
            Always thrown.
            </exception>
        </member>
        <member name="T:Loretta.CodeAnalysis.SyntaxTokenList.Reversed">
            <summary>
            Reversed enumerable.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTokenList.Reversed.#ctor(Loretta.CodeAnalysis.SyntaxTokenList)">
            <summary>
            Creates a new reversed token list.
            </summary>
            <param name="list"></param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTokenList.Reversed.GetEnumerator">
            <summary>
            Returns the enumerator for this reversed list.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTokenList.Reversed.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTokenList.Reversed.Equals(Loretta.CodeAnalysis.SyntaxTokenList.Reversed)">
            <inheritdoc/>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTokenList.Reversed.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTokenList.Reversed.op_Equality(Loretta.CodeAnalysis.SyntaxTokenList.Reversed,Loretta.CodeAnalysis.SyntaxTokenList.Reversed)">
            <summary>
            Checks whether two reversed lists are equal.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTokenList.Reversed.op_Inequality(Loretta.CodeAnalysis.SyntaxTokenList.Reversed,Loretta.CodeAnalysis.SyntaxTokenList.Reversed)">
            <summary>
            Checks whether two reversed lists are equal.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="T:Loretta.CodeAnalysis.SyntaxTokenList.Reversed.Enumerator">
            <summary>
            The enumerator for this reversed list.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTokenList.Reversed.Enumerator.MoveNext">
            <inheritdoc cref="M:System.Collections.IEnumerator.MoveNext"/>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxTokenList.Reversed.Enumerator.Current">
            <inheritdoc cref="P:System.Collections.Generic.IEnumerator`1.Current"/>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTokenList.Reversed.Enumerator.Equals(System.Object)">
            <summary>
            Not supported. Do not use.
            </summary>
            <param name="obj"></param>
            <returns></returns>
            <exception cref="T:System.NotSupportedException">
            Always thrown.
            </exception>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTokenList.Reversed.Enumerator.GetHashCode">
            <summary>
            Not supported. Do not use.
            </summary>
            <returns></returns>
            <exception cref="T:System.NotSupportedException">
            Always thrown.
            </exception>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTokenList.Reversed.Enumerator.op_Equality(Loretta.CodeAnalysis.SyntaxTokenList.Reversed.Enumerator,Loretta.CodeAnalysis.SyntaxTokenList.Reversed.Enumerator)">
            <summary>
            Not supported. Do not use.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
            <exception cref="T:System.NotSupportedException">
            Always thrown.
            </exception>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTokenList.Reversed.Enumerator.op_Inequality(Loretta.CodeAnalysis.SyntaxTokenList.Reversed.Enumerator,Loretta.CodeAnalysis.SyntaxTokenList.Reversed.Enumerator)">
            <summary>
            Not supported. Do not use.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
            <exception cref="T:System.NotSupportedException">
            Always thrown.
            </exception>
        </member>
        <member name="T:Loretta.CodeAnalysis.SyntaxTree">
            <summary>
            The parsed representation of a source document.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxTree.FilePath">
            <summary>
            The path of the source document file.
            </summary>
            <remarks>
            If this syntax tree is not associated with a file, this value can be empty.
            The path shall not be null.
            
            The file doesn't need to exist on disk. The path is opaque to the compiler.
            </remarks>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxTree.HasCompilationUnitRoot">
            <summary>
            Returns true if this syntax tree has a root with SyntaxKind "CompilationUnit".
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxTree.Options">
            <summary>
            The options used by the parser to produce the syntax tree.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxTree.OptionsCore">
            <summary>
            The options used by the parser to produce the syntax tree.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxTree.Length">
            <summary>
            The length of the text of the syntax tree.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTree.TryGetText(Loretta.CodeAnalysis.Text.SourceText@)">
            <summary>
            Gets the syntax tree's text if it is available.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTree.GetText(System.Threading.CancellationToken)">
            <summary>
            Gets the text of the source document.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxTree.Encoding">
            <summary>
            The text encoding of the source document.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTree.GetTextAsync(System.Threading.CancellationToken)">
            <summary>
            Gets the text of the source document asynchronously.
            </summary>
            <remarks>
            By default, the work associated with this method will be executed immediately on the current thread.
            Implementations that wish to schedule this work differently should override <see cref="M:Loretta.CodeAnalysis.SyntaxTree.GetTextAsync(System.Threading.CancellationToken)"/>.
            </remarks>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTree.TryGetRoot(Loretta.CodeAnalysis.SyntaxNode@)">
            <summary>
            Gets the root of the syntax tree if it is available.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTree.TryGetRootCore(Loretta.CodeAnalysis.SyntaxNode@)">
            <summary>
            Gets the root of the syntax tree if it is available.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTree.GetRoot(System.Threading.CancellationToken)">
            <summary>
            Gets the root node of the syntax tree, causing computation if necessary.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTree.GetRootCore(System.Threading.CancellationToken)">
            <summary>
            Gets the root node of the syntax tree, causing computation if necessary.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTree.GetRootAsync(System.Threading.CancellationToken)">
            <summary>
            Gets the root node of the syntax tree asynchronously.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTree.GetRootAsyncCore(System.Threading.CancellationToken)">
            <summary>
            Gets the root node of the syntax tree asynchronously.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTree.WithChangedText(Loretta.CodeAnalysis.Text.SourceText)">
            <summary>
            Create a new syntax tree based off this tree using a new source text.
            
            If the new source text is a minor change from the current source text an incremental
            parse will occur reusing most of the current syntax tree internal data.  Otherwise, a
            full parse will occur using the new source text.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTree.GetDiagnostics(System.Threading.CancellationToken)">
            <summary>
            Gets a list of all the diagnostics in the syntax tree.
            This method does not filter diagnostics based on #pragmas and compiler options
            like nowarn, warnaserror etc.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTree.GetDiagnostics(Loretta.CodeAnalysis.SyntaxNode)">
            <summary>
            Gets a list of all the diagnostics in the sub tree that has the specified node as its root.
            This method does not filter diagnostics based on #pragmas and compiler options
            like nowarn, warnaserror etc.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTree.GetDiagnostics(Loretta.CodeAnalysis.SyntaxToken)">
            <summary>
            Gets a list of all the diagnostics associated with the token and any related trivia.
            This method does not filter diagnostics based on #pragmas and compiler options
            like nowarn, warnaserror etc.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTree.GetDiagnostics(Loretta.CodeAnalysis.SyntaxTrivia)">
            <summary>
            Gets a list of all the diagnostics associated with the trivia.
            This method does not filter diagnostics based on #pragmas and compiler options
            like nowarn, warnaserror etc.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTree.GetDiagnostics(Loretta.CodeAnalysis.SyntaxNodeOrToken)">
            <summary>
            Gets a list of all the diagnostics in either the sub tree that has the specified node as its root or
            associated with the token and its related trivia. 
            This method does not filter diagnostics based on #pragmas and compiler options
            like nowarn, warnaserror etc.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTree.GetLineSpan(Loretta.CodeAnalysis.Text.TextSpan,System.Threading.CancellationToken)">
            <summary>
            Gets the location in terms of path, line and column for a given span.
            </summary>
            <param name="span">Span within the tree.</param>
            <param name="cancellationToken">Cancellation token.</param>
            <returns>
            A valid <see cref="T:Loretta.CodeAnalysis.FileLinePositionSpan"/> that contains path, line and column information.
            The values are not affected by line mapping directives (<c>#line</c>).
            </returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTree.GetChangedSpans(Loretta.CodeAnalysis.SyntaxTree)">
            <summary>
            Returns a list of the changed regions between this tree and the specified tree. The list is conservative for
            performance reasons. It may return larger regions than what has actually changed.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTree.GetLocation(Loretta.CodeAnalysis.Text.TextSpan)">
            <summary>
            Gets a location for the specified text span.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTree.IsEquivalentTo(Loretta.CodeAnalysis.SyntaxTree,System.Boolean)">
            <summary>
            Determines if two trees are the same, disregarding trivia differences.
            </summary>
            <param name="tree">The tree to compare against.</param>
            <param name="topLevel"> If true then the trees are equivalent if the contained nodes and tokens declaring
            metadata visible symbolic information are equivalent, ignoring any differences of nodes inside method bodies
            or initializer expressions, otherwise all nodes and tokens must be equivalent. 
            </param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTree.GetReference(Loretta.CodeAnalysis.SyntaxNode)">
            <summary>
            Gets a SyntaxReference for a specified syntax node. SyntaxReferences can be used to
            regain access to a syntax node without keeping the entire tree and source text in
            memory.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTree.GetChanges(Loretta.CodeAnalysis.SyntaxTree)">
            <summary>
            Gets a list of text changes that when applied to the old tree produce this tree.
            </summary>
            <param name="oldTree">The old tree.</param>
            <remarks>The list of changes may be different than the original changes that produced
            this tree.</remarks>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTree.WithRootAndOptions(Loretta.CodeAnalysis.SyntaxNode,Loretta.CodeAnalysis.ParseOptions)">
            <summary>
            Returns a new tree whose root and options are as specified and other properties are copied from the current tree.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTree.WithFilePath(System.String)">
            <summary>
            Returns a new tree whose <see cref="P:Loretta.CodeAnalysis.SyntaxTree.FilePath"/> is the specified node and other properties are copied from the current tree.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTree.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents the entire source text of this <see cref="T:Loretta.CodeAnalysis.SyntaxTree"/>.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTreeExtensions.VerifySource(Loretta.CodeAnalysis.SyntaxTree,System.Collections.Generic.IEnumerable{Loretta.CodeAnalysis.Text.TextChangeRange})">
            <summary>
            Verify nodes match source.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTreeExtensions.FindFirstDifference(System.String,System.String)">
            <summary>
            Return the index of the first difference between
            the two strings, or -1 if the strings are the same.
            </summary>
        </member>
        <member name="T:Loretta.CodeAnalysis.SyntaxTrivia">
            <summary>
            Represents a trivia in the syntax tree.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxTrivia.RawKind">
            <summary>
            An integer representing the language specific kind of this trivia.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxTrivia.Language">
            <summary>
            The language name that this trivia is syntax of.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxTrivia.Token">
            <summary>
            The parent token that contains this token in its LeadingTrivia or TrailingTrivia collection.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxTrivia.Width">
            <summary>
            The width of this trivia in characters. If this trivia is a structured trivia then the returned width will
            not include the widths of any leading or trailing trivia present on the child non-terminal node of this
            trivia.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxTrivia.FullWidth">
            <summary>
            The width of this trivia in characters. If this trivia is a structured trivia then the returned width will
            include the widths of any leading or trailing trivia present on the child non-terminal node of this trivia.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxTrivia.Span">
            <summary>
            The absolute span of this trivia in characters. If this trivia is a structured trivia then the returned span
            will not include spans of any leading or trailing trivia present on the child non-terminal node of this
            trivia.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxTrivia.SpanStart">
            <summary>
            Same as accessing <see cref="P:Loretta.CodeAnalysis.Text.TextSpan.Start"/> on <see cref="P:Loretta.CodeAnalysis.SyntaxTrivia.Span"/>.
            </summary>
            <remarks>
            Slight performance improvement.
            </remarks>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxTrivia.FullSpan">
            <summary>
            The absolute span of this trivia in characters. If this trivia is a structured trivia then the returned span
            will include spans of any leading or trailing trivia present on the child non-terminal node of this trivia.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxTrivia.ContainsDiagnostics">
            <summary>
            Determines whether this trivia has any diagnostics on it. If this trivia is a structured trivia then the
            returned value will indicate whether this trivia or any of its descendant nodes, tokens or trivia have any
            diagnostics on them.
            </summary>>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxTrivia.HasStructure">
            <summary>
            Determines whether this trivia is a structured trivia.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTrivia.IsPartOfStructuredTrivia">
            <summary>
            Determines whether this trivia is a descendant of a structured trivia.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxTrivia.ContainsAnnotations">
            <summary>
            Determines whether this trivia or any of its structure has annotations.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTrivia.HasAnnotations(System.String)">
            <summary>
            Determines where this trivia has annotations of the specified annotation kind.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTrivia.HasAnnotations(System.String[])">
            <summary>
            Determines where this trivia has any annotations of the specified annotation kinds.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTrivia.HasAnnotation(Loretta.CodeAnalysis.SyntaxAnnotation)">
            <summary>
            Determines whether this trivia has the specific annotation.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTrivia.GetAnnotations(System.String)">
            <summary>
            Get all the annotations of the specified annotation kind.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTrivia.GetAnnotations(System.String[])">
            <summary>
            Get all the annotations of the specified annotation kinds.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxTrivia.IsDirective">
            <summary>
            Determines whether this trivia represents a preprocessor directive.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTrivia.GetStructure">
            <summary>
            Returns the child non-terminal node representing the syntax tree structure under this structured trivia.
            </summary>
            <returns>The child non-terminal node representing the syntax tree structure under this structured
            trivia.</returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTrivia.ToString">
            <summary> 
            Returns the string representation of this trivia. If this trivia is structured trivia then the returned string
            will not include any leading or trailing trivia present on the StructuredTriviaSyntax node of this trivia.
            </summary>
            <returns>The string representation of this trivia.</returns>
            <remarks>The length of the returned string is always the same as Span.Length</remarks>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTrivia.ToFullString">
            <summary> 
            Returns the full string representation of this trivia. If this trivia is structured trivia then the returned string will
            include any leading or trailing trivia present on the StructuredTriviaSyntax node of this trivia.
            </summary>
            <returns>The full string representation of this trivia.</returns>
            <remarks>The length of the returned string is always the same as FullSpan.Length</remarks>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTrivia.WriteTo(System.IO.TextWriter)">
            <summary>
            Writes the full text of this trivia to the specified TextWriter.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTrivia.op_Equality(Loretta.CodeAnalysis.SyntaxTrivia,Loretta.CodeAnalysis.SyntaxTrivia)">
            <summary>
            Determines whether two <see cref="T:Loretta.CodeAnalysis.SyntaxTrivia"/>s are equal.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTrivia.op_Inequality(Loretta.CodeAnalysis.SyntaxTrivia,Loretta.CodeAnalysis.SyntaxTrivia)">
            <summary>
            Determines whether two <see cref="T:Loretta.CodeAnalysis.SyntaxTrivia"/>s are unequal.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTrivia.Equals(Loretta.CodeAnalysis.SyntaxTrivia)">
            <summary>
            Determines whether the supplied <see cref="T:Loretta.CodeAnalysis.SyntaxTrivia"/> is equal to this
            <see cref="T:Loretta.CodeAnalysis.SyntaxTrivia"/>.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTrivia.Equals(System.Object)">
            <summary>
            Determines whether the supplied <see cref="T:Loretta.CodeAnalysis.SyntaxTrivia"/> is equal to this
            <see cref="T:Loretta.CodeAnalysis.SyntaxTrivia"/>.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTrivia.GetHashCode">
            <summary>
            Serves as hash function for <see cref="T:Loretta.CodeAnalysis.SyntaxTrivia"/>.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTrivia.WithAdditionalAnnotations(Loretta.CodeAnalysis.SyntaxAnnotation[])">
            <summary>
            Creates a new SyntaxTrivia with the specified annotations.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTrivia.WithAdditionalAnnotations(System.Collections.Generic.IEnumerable{Loretta.CodeAnalysis.SyntaxAnnotation})">
            <summary>
            Creates a new SyntaxTrivia with the specified annotations.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTrivia.WithoutAnnotations(Loretta.CodeAnalysis.SyntaxAnnotation[])">
            <summary>
            Creates a new SyntaxTrivia without the specified annotations.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTrivia.WithoutAnnotations(System.Collections.Generic.IEnumerable{Loretta.CodeAnalysis.SyntaxAnnotation})">
            <summary>
            Creates a new SyntaxTrivia without the specified annotations.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTrivia.WithoutAnnotations(System.String)">
            <summary>
            Creates a new SyntaxTrivia without annotations of the specified kind.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTrivia.CopyAnnotationsTo(Loretta.CodeAnalysis.SyntaxTrivia)">
            <summary>
            Copies all SyntaxAnnotations, if any, from this SyntaxTrivia instance and attaches them to a new instance based on <paramref name="trivia" />.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxTrivia.SyntaxTree">
            <summary>
            SyntaxTree which contains current SyntaxTrivia.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTrivia.GetLocation">
            <summary>
            Get the location of this trivia.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTrivia.GetDiagnostics">
            <summary>
            Gets a list of all the diagnostics associated with this trivia.
            This method does not filter diagnostics based on #pragmas and compiler options
            like nowarn, warnaserror etc.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTrivia.IsEquivalentTo(Loretta.CodeAnalysis.SyntaxTrivia)">
            <summary>
            Determines if this trivia is equivalent to the specified trivia.
            </summary>
        </member>
        <member name="T:Loretta.CodeAnalysis.SyntaxTriviaList">
            <summary>
            Represents a read-only list of <see cref="T:Loretta.CodeAnalysis.SyntaxTrivia"/>.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxTriviaList.Empty">
            <summary>
            An empty trivia list.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTriviaList.#ctor(Loretta.CodeAnalysis.SyntaxTrivia)">
            <summary>
            Creates a new trivia list with the provided trivia as the only element.
            </summary>
            <param name="trivia"></param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTriviaList.#ctor(Loretta.CodeAnalysis.SyntaxTrivia[])">
            <summary>
            Creates a list of trivia.
            </summary>
            <param name="trivias">An array of trivia.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTriviaList.#ctor(System.Collections.Generic.IEnumerable{Loretta.CodeAnalysis.SyntaxTrivia})">
            <summary>
            Creates a list of trivia.
            </summary>
            <param name="trivias">A sequence of trivia.</param>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxTriviaList.Count">
            <summary>
            The amount of elements in this list.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTriviaList.ElementAt(System.Int32)">
            <summary>
            Returns the element at the provided index.
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxTriviaList.Item(System.Int32)">
            <summary>
            Gets the trivia at the specified index.
            </summary>
            <param name="index">The zero-based index of the trivia to get.</param>
            <returns>The token at the specified index.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="index" /> is less than 0.-or-<paramref name="index" /> is equal to or greater than <see cref="P:Loretta.CodeAnalysis.SyntaxTriviaList.Count" />. </exception>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxTriviaList.FullSpan">
            <summary>
            The absolute span of the list elements in characters, including the leading and trailing trivia of the first and last elements.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxTriviaList.Span">
            <summary>
            The absolute span of the list elements in characters, not including the leading and trailing trivia of the first and last elements.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTriviaList.First">
            <summary>
            Returns the first trivia in the list.
            </summary>
            <returns>The first trivia in the list.</returns>
            <exception cref="T:System.InvalidOperationException">The list is empty.</exception>        
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTriviaList.Last">
            <summary>
            Returns the last trivia in the list.
            </summary>
            <returns>The last trivia in the list.</returns>
            <exception cref="T:System.InvalidOperationException">The list is empty.</exception>        
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTriviaList.Any">
            <summary>
            Does this list have any items.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTriviaList.Reverse">
            <summary>
            Returns a list which contains all elements of <see cref="T:Loretta.CodeAnalysis.SyntaxTriviaList"/> in reversed order.
            </summary>
            <returns><see cref="T:Loretta.CodeAnalysis.SyntaxTriviaList.Reversed"/> which contains all elements of <see cref="T:Loretta.CodeAnalysis.SyntaxTriviaList"/> in reversed order</returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTriviaList.GetEnumerator">
            <summary>
            Returns the enumerator for this list.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTriviaList.IndexOf(Loretta.CodeAnalysis.SyntaxTrivia)">
            <summary>
            Returns the index of the provided trivia in this list.
            </summary>
            <param name="triviaInList"></param>
            <returns>-1 if not found.</returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTriviaList.Add(Loretta.CodeAnalysis.SyntaxTrivia)">
            <summary>
            Creates a new <see cref="T:Loretta.CodeAnalysis.SyntaxTriviaList"/> with the specified trivia added to the end.
            </summary>
            <param name="trivia">The trivia to add.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTriviaList.AddRange(System.Collections.Generic.IEnumerable{Loretta.CodeAnalysis.SyntaxTrivia})">
            <summary>
            Creates a new <see cref="T:Loretta.CodeAnalysis.SyntaxTriviaList"/> with the specified trivia added to the end.
            </summary>
            <param name="trivia">The trivia to add.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTriviaList.Insert(System.Int32,Loretta.CodeAnalysis.SyntaxTrivia)">
            <summary>
            Creates a new <see cref="T:Loretta.CodeAnalysis.SyntaxTriviaList"/> with the specified trivia inserted at the index.
            </summary>
            <param name="index">The index in the list to insert the trivia at.</param>
            <param name="trivia">The trivia to insert.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTriviaList.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{Loretta.CodeAnalysis.SyntaxTrivia})">
            <summary>
            Creates a new <see cref="T:Loretta.CodeAnalysis.SyntaxTriviaList"/> with the specified trivia inserted at the index.
            </summary>
            <param name="index">The index in the list to insert the trivia at.</param>
            <param name="trivia">The trivia to insert.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTriviaList.RemoveAt(System.Int32)">
            <summary>
            Creates a new <see cref="T:Loretta.CodeAnalysis.SyntaxTriviaList"/> with the element at the specified index removed.
            </summary>
            <param name="index">The index identifying the element to remove.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTriviaList.Remove(Loretta.CodeAnalysis.SyntaxTrivia)">
            <summary>
            Creates a new <see cref="T:Loretta.CodeAnalysis.SyntaxTriviaList"/> with the specified element removed.
            </summary>
            <param name="triviaInList">The trivia element to remove.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTriviaList.Replace(Loretta.CodeAnalysis.SyntaxTrivia,Loretta.CodeAnalysis.SyntaxTrivia)">
            <summary>
            Creates a new <see cref="T:Loretta.CodeAnalysis.SyntaxTriviaList"/> with the specified element replaced with new trivia.
            </summary>
            <param name="triviaInList">The trivia element to replace.</param>
            <param name="newTrivia">The trivia to replace the element with.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTriviaList.ReplaceRange(Loretta.CodeAnalysis.SyntaxTrivia,System.Collections.Generic.IEnumerable{Loretta.CodeAnalysis.SyntaxTrivia})">
            <summary>
            Creates a new <see cref="T:Loretta.CodeAnalysis.SyntaxTriviaList"/> with the specified element replaced with new trivia.
            </summary>
            <param name="triviaInList">The trivia element to replace.</param>
            <param name="newTrivia">The trivia to replace the element with.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTriviaList.GetGreenNodeAt(System.Int32)">
            <summary>
            get the green node at the specific slot
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTriviaList.Equals(Loretta.CodeAnalysis.SyntaxTriviaList)">
            <inheritdoc/>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTriviaList.op_Equality(Loretta.CodeAnalysis.SyntaxTriviaList,Loretta.CodeAnalysis.SyntaxTriviaList)">
            <summary>
            Checks whether two trivia lists are equal.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTriviaList.op_Inequality(Loretta.CodeAnalysis.SyntaxTriviaList,Loretta.CodeAnalysis.SyntaxTriviaList)">
            <summary>
            Checks whether two trivia lists are not equal.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTriviaList.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTriviaList.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTriviaList.CopyTo(System.Int32,Loretta.CodeAnalysis.SyntaxTrivia[],System.Int32,System.Int32)">
            <summary>
            Copy <paramref name="count"/> number of items starting at <paramref name="offset"/> from this list into <paramref name="array"/> starting at <paramref name="arrayOffset"/>.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTriviaList.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTriviaList.ToFullString">
            <summary>
            Returns the list as a string including leading and trailing trivia.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTriviaList.Create(Loretta.CodeAnalysis.SyntaxTrivia)">
            <summary>
            Creates a new trivia list.
            </summary>
            <param name="trivia"></param>
            <returns></returns>
        </member>
        <member name="T:Loretta.CodeAnalysis.SyntaxTriviaList.Enumerator">
            <summary>
            The enumerator for this trivia list.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTriviaList.Enumerator.MoveNext">
            <inheritdoc cref="M:System.Collections.IEnumerator.MoveNext"/>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxTriviaList.Enumerator.Current">
            <inheritdoc cref="P:System.Collections.Generic.IEnumerator`1.Current"/>
        </member>
        <member name="T:Loretta.CodeAnalysis.SyntaxTriviaList.Reversed">
            <summary>
            Reversed enumerable.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTriviaList.Reversed.#ctor(Loretta.CodeAnalysis.SyntaxTriviaList)">
            <summary>
            Creates a new reversed trivia list.
            </summary>
            <param name="list"></param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTriviaList.Reversed.GetEnumerator">
            <summary>
            Returns the enumerator for this reversed trivia list.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTriviaList.Reversed.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTriviaList.Reversed.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTriviaList.Reversed.Equals(Loretta.CodeAnalysis.SyntaxTriviaList.Reversed)">
            <inheritdoc/>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTriviaList.Reversed.op_Equality(Loretta.CodeAnalysis.SyntaxTriviaList.Reversed,Loretta.CodeAnalysis.SyntaxTriviaList.Reversed)">
            <summary>
            Checks whether two reversed lists are equal.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTriviaList.Reversed.op_Inequality(Loretta.CodeAnalysis.SyntaxTriviaList.Reversed,Loretta.CodeAnalysis.SyntaxTriviaList.Reversed)">
            <summary>
            Checks whether two reversed lists are equal.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="T:Loretta.CodeAnalysis.SyntaxTriviaList.Reversed.Enumerator">
            <summary>
            The enumerator for reversed trivia lists.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxTriviaList.Reversed.Enumerator.MoveNext">
            <inheritdoc cref="M:System.Collections.IEnumerator.MoveNext"/>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxTriviaList.Reversed.Enumerator.Current">
            <inheritdoc cref="P:System.Collections.Generic.IEnumerator`1.Current"/>
        </member>
        <member name="T:Loretta.CodeAnalysis.SyntaxWalker">
            <summary>
            Walks the syntax tree, allowing subclasses to operate on all nodes, token and trivia.  The
            walker will perform a depth first walk of the tree.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.SyntaxWalker.Depth">
            <summary>
            Syntax the <see cref="T:Loretta.CodeAnalysis.SyntaxWalker"/> should descend into.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxWalker.#ctor(Loretta.CodeAnalysis.SyntaxWalkerDepth)">
            <summary>
            Creates a new walker instance.
            </summary>
            <param name="depth">Syntax the <see cref="T:Loretta.CodeAnalysis.SyntaxWalker"/> should descend into.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxWalker.Visit(Loretta.CodeAnalysis.SyntaxNode)">
            <summary>
            Called when the walker visits a node.  This method may be overridden if subclasses want
            to handle the node.  Overrides should call back into this base method if they want the
            children of this node to be visited.
            </summary>
            <param name="node">The current node that the walker is visiting.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxWalker.VisitToken(Loretta.CodeAnalysis.SyntaxToken)">
            <summary>
            Called when the walker visits a token.  This method may be overridden if subclasses want
            to handle the token.  Overrides should call back into this base method if they want the 
            trivia of this token to be visited.
            </summary>
            <param name="token">The current token that the walker is visiting.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.SyntaxWalker.VisitTrivia(Loretta.CodeAnalysis.SyntaxTrivia)">
            <summary>
            Called when the walker visits a trivia syntax.  This method may be overridden if
            subclasses want to handle the token.  Overrides should call back into this base method if
            they want the children of this trivia syntax to be visited.
            </summary>
            <param name="trivia">The current trivia syntax that the walker is visiting.</param>
        </member>
        <member name="T:Loretta.CodeAnalysis.SyntaxWalkerDepth">
            <summary>
            Syntax the <see cref="T:Loretta.CodeAnalysis.SyntaxWalker"/> should descend into.
            </summary>
        </member>
        <member name="F:Loretta.CodeAnalysis.SyntaxWalkerDepth.Node">
            <summary>
            descend into only nodes
            </summary>
        </member>
        <member name="F:Loretta.CodeAnalysis.SyntaxWalkerDepth.Token">
            <summary>
            descend into nodes and tokens
            </summary>
        </member>
        <member name="F:Loretta.CodeAnalysis.SyntaxWalkerDepth.Trivia">
            <summary>
            descend into nodes, tokens and trivia
            </summary>
        </member>
        <member name="F:Loretta.CodeAnalysis.SyntaxWalkerDepth.StructuredTrivia">
            <summary>
            descend into everything
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.ChangedText.GetLinesCore">
            <summary>
            Computes line starts faster given already computed line starts from text before the change.
            </summary>
        </member>
        <member name="T:Loretta.CodeAnalysis.Text.CompositeText">
            <summary>
            A composite of a sequence of <see cref="T:Loretta.CodeAnalysis.Text.SourceText"/>s.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.CompositeText.CheckCopyToArguments(System.Int32,System.Char[],System.Int32,System.Int32)">
            <summary>
            Validates the arguments passed to <see cref="M:Loretta.CodeAnalysis.Text.CompositeText.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)"/> against the published contract.
            </summary>
            <returns>True if should bother to proceed with copying.</returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.CompositeText.ReduceSegmentCountIfNecessary(Loretta.CodeAnalysis.PooledObjects.ArrayBuilder{Loretta.CodeAnalysis.Text.SourceText})">
            <summary>
            Reduces the number of segments toward the target number of segments,
            if the number of segments is deemed to be too large (beyond the maximum).
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.CompositeText.GetMinimalSegmentSizeToUseForCombining(Loretta.CodeAnalysis.PooledObjects.ArrayBuilder{Loretta.CodeAnalysis.Text.SourceText})">
            <summary>
            Determines the segment size to use for call to CombineSegments, that will result in the segment count
            being reduced to less than or equal to the target segment count.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.CompositeText.GetSegmentCountIfCombined(Loretta.CodeAnalysis.PooledObjects.ArrayBuilder{Loretta.CodeAnalysis.Text.SourceText},System.Int32)">
            <summary>
            Determines the segment count that would result if the segments of size less than or equal to 
            the specified segment size were to be combined.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.CompositeText.CombineSegments(Loretta.CodeAnalysis.PooledObjects.ArrayBuilder{Loretta.CodeAnalysis.Text.SourceText},System.Int32)">
            <summary>
            Combines contiguous segments with lengths that are each less than or equal to the specified segment size.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.CompositeText.ComputeLengthAndStorageSize(System.Collections.Generic.IReadOnlyList{Loretta.CodeAnalysis.Text.SourceText},System.Int32@,System.Int32@)">
            <summary>
            Compute total text length and total size of storage buffers held
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.CompositeText.TrimInaccessibleText(Loretta.CodeAnalysis.PooledObjects.ArrayBuilder{Loretta.CodeAnalysis.Text.SourceText})">
            <summary>
            Trim excessive inaccessible text.
            </summary>
        </member>
        <member name="T:Loretta.CodeAnalysis.Text.LargeText">
            <summary>
            A <see cref="T:Loretta.CodeAnalysis.Text.SourceText"/> optimized for very large sources. The text is stored as
            a list of chunks (char arrays).
            </summary>
        </member>
        <member name="F:Loretta.CodeAnalysis.Text.LargeText.ChunkSize">
            <remarks>
            internal for unit testing
            </remarks>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.LargeText.IsBinary(System.Char[])">
            <summary>
            Check for occurrence of two consecutive NUL (U+0000) characters.
            This is unlikely to appear in genuine text, so it's a good heuristic
            to detect binary files.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.LargeText.GetLinesCore">
            <summary>
            Called from <see cref="P:Loretta.CodeAnalysis.Text.SourceText.Lines"/> to initialize the <see cref="T:Loretta.CodeAnalysis.Text.TextLineCollection"/>. Thereafter,
            the collection is cached.
            </summary>
            <returns>A new <see cref="T:Loretta.CodeAnalysis.Text.TextLineCollection"/> representing the individual text lines.</returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.LargeTextWriter.AppendChunk(System.Char[])">
            <summary>
            Append chunk to writer (may reuse char array)
            </summary>
        </member>
        <member name="T:Loretta.CodeAnalysis.Text.LinePosition">
            <summary>
            Immutable representation of a line number and position within a SourceText instance.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.Text.LinePosition.Zero">
            <summary>
            A <see cref="T:Loretta.CodeAnalysis.Text.LinePosition"/> that represents position 0 at line 0.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.LinePosition.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of a <see cref="T:Loretta.CodeAnalysis.Text.LinePosition"/> with the given line and character.
            </summary>
            <param name="line">
            The line of the line position. The first line in a file is defined as line 0 (zero based line numbering).
            </param>
            <param name="character">
            The character position in the line.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="line"/> or <paramref name="character"/> is less than zero. </exception>
        </member>
        <member name="P:Loretta.CodeAnalysis.Text.LinePosition.Line">
            <summary>
            The line number. The first line in a file is defined as line 0 (zero based line numbering).
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.Text.LinePosition.Character">
            <summary>
            The character position within the line.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.LinePosition.op_Equality(Loretta.CodeAnalysis.Text.LinePosition,Loretta.CodeAnalysis.Text.LinePosition)">
            <summary>
            Determines whether two <see cref="T:Loretta.CodeAnalysis.Text.LinePosition"/> are the same.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.LinePosition.op_Inequality(Loretta.CodeAnalysis.Text.LinePosition,Loretta.CodeAnalysis.Text.LinePosition)">
            <summary>
            Determines whether two <see cref="T:Loretta.CodeAnalysis.Text.LinePosition"/> are different.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.LinePosition.Equals(Loretta.CodeAnalysis.Text.LinePosition)">
            <summary>
            Determines whether two <see cref="T:Loretta.CodeAnalysis.Text.LinePosition"/> are the same.
            </summary>
            <param name="other">The object to compare.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.LinePosition.Equals(System.Object)">
            <summary>
            Determines whether two <see cref="T:Loretta.CodeAnalysis.Text.LinePosition"/> are the same.
            </summary>
            <param name="obj">The object to compare.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.LinePosition.GetHashCode">
            <summary>
            Provides a hash function for <see cref="T:Loretta.CodeAnalysis.Text.LinePosition"/>.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.LinePosition.ToString">
            <summary>
            Provides a string representation for <see cref="T:Loretta.CodeAnalysis.Text.LinePosition"/>.
            </summary>
            <example>0,10</example>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.LinePosition.CompareTo(Loretta.CodeAnalysis.Text.LinePosition)">
            <inheritdoc/>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.LinePosition.op_GreaterThan(Loretta.CodeAnalysis.Text.LinePosition,Loretta.CodeAnalysis.Text.LinePosition)">
            <summary>
            Checks whether one position is located after another.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.LinePosition.op_GreaterThanOrEqual(Loretta.CodeAnalysis.Text.LinePosition,Loretta.CodeAnalysis.Text.LinePosition)">
            <summary>
            Checks whether one position is located after or at the same location as another.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.LinePosition.op_LessThan(Loretta.CodeAnalysis.Text.LinePosition,Loretta.CodeAnalysis.Text.LinePosition)">
            <summary>
            Checks whether one position is located before another.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.LinePosition.op_LessThanOrEqual(Loretta.CodeAnalysis.Text.LinePosition,Loretta.CodeAnalysis.Text.LinePosition)">
            <summary>
            Checks whether one position is located before or at the same location as another.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="T:Loretta.CodeAnalysis.Text.LinePositionSpan">
            <summary>
            Immutable span represented by a pair of line number and index within the line.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.LinePositionSpan.#ctor(Loretta.CodeAnalysis.Text.LinePosition,Loretta.CodeAnalysis.Text.LinePosition)">
            <summary>
            Creates <see cref="T:Loretta.CodeAnalysis.Text.LinePositionSpan"/>.
            </summary>
            <param name="start">Start position.</param>
            <param name="end">End position.</param>
            <exception cref="T:System.ArgumentException"><paramref name="end"/> precedes <paramref name="start"/>.</exception>
        </member>
        <member name="P:Loretta.CodeAnalysis.Text.LinePositionSpan.Start">
            <summary>
            Gets the start position of the span.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.Text.LinePositionSpan.End">
            <summary>
            Gets the end position of the span.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.LinePositionSpan.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.LinePositionSpan.Equals(Loretta.CodeAnalysis.Text.LinePositionSpan)">
            <inheritdoc/>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.LinePositionSpan.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.LinePositionSpan.op_Equality(Loretta.CodeAnalysis.Text.LinePositionSpan,Loretta.CodeAnalysis.Text.LinePositionSpan)">
            <summary>
            Checks whether two line position spans are equal.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.LinePositionSpan.op_Inequality(Loretta.CodeAnalysis.Text.LinePositionSpan,Loretta.CodeAnalysis.Text.LinePositionSpan)">
            <summary>
            Checks whether two line position spans are not equal.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.LinePositionSpan.ToString">
            <summary>
            Provides a string representation for <see cref="T:Loretta.CodeAnalysis.Text.LinePositionSpan"/>.
            </summary>
            <example>(0,0)-(5,6)</example>
        </member>
        <member name="T:Loretta.CodeAnalysis.Text.SourceHashAlgorithm">
            <summary>
            Specifies a hash algorithms used for hashing source files.
            </summary>
        </member>
        <member name="F:Loretta.CodeAnalysis.Text.SourceHashAlgorithm.None">
            <summary>
            No algorithm specified.
            </summary>
        </member>
        <member name="F:Loretta.CodeAnalysis.Text.SourceHashAlgorithm.Sha1">
            <summary>
            Secure Hash Algorithm 1.
            </summary>
        </member>
        <member name="F:Loretta.CodeAnalysis.Text.SourceHashAlgorithm.Sha256">
            <summary>
            Secure Hash Algorithm 2 with a hash size of 256 bits.
            </summary>
        </member>
        <member name="T:Loretta.CodeAnalysis.Text.SourceText">
            <summary>
            An abstraction of source text.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.SourceText.#ctor(System.Collections.Immutable.ImmutableArray{System.Byte},Loretta.CodeAnalysis.Text.SourceHashAlgorithm,Loretta.CodeAnalysis.Text.SourceTextContainer)">
            <summary>internal</summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.SourceText.From(System.String,System.Text.Encoding,Loretta.CodeAnalysis.Text.SourceHashAlgorithm)">
            <summary>
            Constructs a <see cref="T:Loretta.CodeAnalysis.Text.SourceText"/> from text in a string.
            </summary>
            <param name="text">Text.</param>
            <param name="encoding">
            Encoding of the file that the <paramref name="text"/> was read from or is going to be saved to.
            <c>null</c> if the encoding is unspecified.
            If the encoding is not specified the resulting <see cref="T:Loretta.CodeAnalysis.Text.SourceText"/> isn't debuggable.
            If an encoding-less <see cref="T:Loretta.CodeAnalysis.Text.SourceText"/> is written to a file a <see cref="P:System.Text.Encoding.UTF8"/> shall be used as a default.
            </param>
            <param name="checksumAlgorithm">
            Hash algorithm to use to calculate checksum of the text that's saved to PDB.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="text"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="checksumAlgorithm"/> is not supported.</exception>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.SourceText.From(System.IO.TextReader,System.Int32,System.Text.Encoding,Loretta.CodeAnalysis.Text.SourceHashAlgorithm)">
            <summary>
            Constructs a <see cref="T:Loretta.CodeAnalysis.Text.SourceText"/> from text in a string.
            </summary>
            <param name="reader">TextReader</param>
            <param name="length">length of content from <paramref name="reader"/></param>
            <param name="encoding">
            Encoding of the file that the <paramref name="reader"/> was read from or is going to be saved to.
            <c>null</c> if the encoding is unspecified.
            If the encoding is not specified the resulting <see cref="T:Loretta.CodeAnalysis.Text.SourceText"/> isn't debuggable.
            If an encoding-less <see cref="T:Loretta.CodeAnalysis.Text.SourceText"/> is written to a file a <see cref="P:System.Text.Encoding.UTF8"/> shall be used as a default.
            </param>
            <param name="checksumAlgorithm">
            Hash algorithm to use to calculate checksum of the text that's saved to PDB.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="reader"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="checksumAlgorithm"/> is not supported.</exception>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.SourceText.From(System.IO.Stream,System.Text.Encoding,Loretta.CodeAnalysis.Text.SourceHashAlgorithm,System.Boolean)">
            <summary>
            Constructs a <see cref="T:Loretta.CodeAnalysis.Text.SourceText"/> from stream content.
            </summary>
            <param name="stream">Stream. The stream must be seekable.</param>
            <param name="encoding">
            Data encoding to use if the stream doesn't start with Byte Order Mark specifying the encoding.
            <see cref="P:System.Text.Encoding.UTF8"/> if not specified.
            </param>
            <param name="checksumAlgorithm">
            Hash algorithm to use to calculate checksum of the text that's saved to PDB.
            </param>
            <param name="throwIfBinaryDetected">If the decoded text contains at least two consecutive NUL
            characters, then an <see cref="T:System.IO.InvalidDataException"/> is thrown.</param>
            
            <exception cref="T:System.ArgumentNullException"><paramref name="stream"/> is null.</exception>
            <exception cref="T:System.ArgumentException">
            <paramref name="stream"/> doesn't support reading or seeking.
            <paramref name="checksumAlgorithm"/> is not supported.
            </exception>
            <exception cref="T:System.Text.DecoderFallbackException">If the given encoding is set to use a throwing decoder as a fallback</exception>
            <exception cref="T:System.IO.InvalidDataException">Two consecutive NUL characters were detected in the decoded text and <paramref name="throwIfBinaryDetected"/> was true.</exception>
            <exception cref="T:System.IO.IOException">An I/O error occurs.</exception>
            <remarks>Reads from the beginning of the stream. Leaves the stream open.</remarks>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.SourceText.From(System.Byte[],System.Int32,System.Text.Encoding,Loretta.CodeAnalysis.Text.SourceHashAlgorithm,System.Boolean)">
            <summary>
            Constructs a <see cref="T:Loretta.CodeAnalysis.Text.SourceText"/> from a byte array.
            </summary>
            <param name="buffer">The encoded source buffer.</param>
            <param name="length">The number of bytes to read from the buffer.</param>
            <param name="encoding">
            Data encoding to use if the encoded buffer doesn't start with Byte Order Mark.
            <see cref="P:System.Text.Encoding.UTF8"/> if not specified.
            </param>
            <param name="checksumAlgorithm">
            Hash algorithm to use to calculate checksum of the text that's saved to PDB.
            </param>
            <param name="throwIfBinaryDetected">If the decoded text contains at least two consecutive NUL
            characters, then an <see cref="T:System.IO.InvalidDataException"/> is thrown.</param>
            <returns>The decoded text.</returns>
            <exception cref="T:System.ArgumentNullException">The <paramref name="buffer"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="length"/> is negative or longer than the <paramref name="buffer"/>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="checksumAlgorithm"/> is not supported.</exception>
            <exception cref="T:System.Text.DecoderFallbackException">If the given encoding is set to use a throwing decoder as a fallback</exception>
            <exception cref="T:System.IO.InvalidDataException">Two consecutive NUL characters were detected in the decoded text and <paramref name="throwIfBinaryDetected"/> was true.</exception>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.SourceText.Decode(System.IO.Stream,System.Text.Encoding,System.Text.Encoding@)">
            <summary>
            Decode text from a stream.
            </summary>
            <param name="stream">The stream containing encoded text.</param>
            <param name="encoding">The encoding to use if an encoding cannot be determined from the byte order mark.</param>
            <param name="actualEncoding">The actual encoding used.</param>
            <returns>The decoded text.</returns>
            <exception cref="T:System.Text.DecoderFallbackException">If the given encoding is set to use a throwing decoder as a fallback</exception>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.SourceText.Decode(System.Byte[],System.Int32,System.Text.Encoding,System.Text.Encoding@)">
            <summary>
            Decode text from a byte array.
            </summary>
            <param name="buffer">The byte array containing encoded text.</param>
            <param name="length">The count of valid bytes in <paramref name="buffer"/>.</param>
            <param name="encoding">The encoding to use if an encoding cannot be determined from the byte order mark.</param>
            <param name="actualEncoding">The actual encoding used.</param>
            <returns>The decoded text.</returns>
            <exception cref="T:System.Text.DecoderFallbackException">If the given encoding is set to use a throwing decoder as a fallback</exception>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.SourceText.IsBinary(System.String)">
            <summary>
            Check for occurrence of two consecutive NUL (U+0000) characters.
            This is unlikely to appear in genuine text, so it's a good heuristic
            to detect binary files.
            </summary>
            <remarks>
            internal for unit testing
            </remarks>
        </member>
        <member name="P:Loretta.CodeAnalysis.Text.SourceText.ChecksumAlgorithm">
            <summary>
            Hash algorithm to use to calculate checksum of the text that's saved to PDB.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.Text.SourceText.Encoding">
            <summary>
            Encoding of the file that the text was read from or is going to be saved to.
            <c>null</c> if the encoding is unspecified.
            </summary>
            <remarks>
            If the encoding is not specified the source isn't debuggable.
            If an encoding-less <see cref="T:Loretta.CodeAnalysis.Text.SourceText"/> is written to a file a <see cref="P:System.Text.Encoding.UTF8"/> shall be used as a default.
            </remarks>
        </member>
        <member name="P:Loretta.CodeAnalysis.Text.SourceText.Length">
            <summary>
            The length of the text in characters.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.Text.SourceText.StorageSize">
            <summary>
            The size of the storage representation of the text (in characters).
            This can differ from length when storage buffers are reused to represent fragments/subtext.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.Text.SourceText.Item(System.Int32)">
            <summary>
            Returns a character at given position.
            </summary>
            <param name="position">The position to get the character from.</param>
            <returns>The character.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">When position is negative or 
            greater than <see cref="P:Loretta.CodeAnalysis.Text.SourceText.Length"/>.</exception>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.SourceText.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)">
            <summary>
            Copy a range of characters from this SourceText to a destination array.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.Text.SourceText.Container">
            <summary>
            The container of this <see cref="T:Loretta.CodeAnalysis.Text.SourceText"/>.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.SourceText.GetSubText(Loretta.CodeAnalysis.Text.TextSpan)">
            <summary>
            Gets a <see cref="T:Loretta.CodeAnalysis.Text.SourceText"/> that contains the characters in the specified span of this text.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.SourceText.GetSubText(System.Int32)">
            <summary>
            Returns a <see cref="T:Loretta.CodeAnalysis.Text.SourceText"/> that has the contents of this text including and after the start position.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.SourceText.Write(System.IO.TextWriter,System.Threading.CancellationToken)">
            <summary>
            Write this <see cref="T:Loretta.CodeAnalysis.Text.SourceText"/> to a text writer.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.SourceText.Write(System.IO.TextWriter,Loretta.CodeAnalysis.Text.TextSpan,System.Threading.CancellationToken)">
            <summary>
            Write a span of text to a text writer.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.SourceText.GetChecksum">
            <summary>
            Returns the checksum for this text.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.SourceText.ToString">
            <summary>
            Provides a string representation of the SourceText.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.SourceText.ToString(Loretta.CodeAnalysis.Text.TextSpan)">
            <summary>
            Gets a string containing the characters in specified span.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">When given span is outside of the text range.</exception>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.SourceText.WithChanges(System.Collections.Generic.IEnumerable{Loretta.CodeAnalysis.Text.TextChange})">
            <summary>
            Constructs a new SourceText from this text with the specified changes.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.SourceText.WithChanges(Loretta.CodeAnalysis.Text.TextChange[])">
            <summary>
            Constructs a new SourceText from this text with the specified changes.
            <exception cref="T:System.ArgumentException">If any changes are not in bounds of this <see cref="T:Loretta.CodeAnalysis.Text.SourceText"/>.</exception>
            <exception cref="T:System.ArgumentException">If any changes overlap other changes.</exception>
            </summary>
            <remarks>
            Changes do not have to be in sorted order.  However, <see cref="M:Loretta.CodeAnalysis.Text.SourceText.WithChanges(System.Collections.Generic.IEnumerable{Loretta.CodeAnalysis.Text.TextChange})"/> will
            perform better if they are.
            </remarks>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.SourceText.Replace(Loretta.CodeAnalysis.Text.TextSpan,System.String)">
            <summary>
            Returns a new SourceText with the specified span of characters replaced by the new text.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.SourceText.Replace(System.Int32,System.Int32,System.String)">
            <summary>
            Returns a new SourceText with the specified range of characters replaced by the new text.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.SourceText.GetChangeRanges(Loretta.CodeAnalysis.Text.SourceText)">
            <summary>
            Gets the set of <see cref="T:Loretta.CodeAnalysis.Text.TextChangeRange"/> that describe how the text changed
            between this text an older version. This may be multiple detailed changes
            or a single change encompassing the entire text.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.SourceText.GetTextChanges(Loretta.CodeAnalysis.Text.SourceText)">
            <summary>
            Gets the set of <see cref="T:Loretta.CodeAnalysis.Text.TextChange"/> that describe how the text changed
            between this text and an older version. This may be multiple detailed changes 
            or a single change encompassing the entire text.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.Text.SourceText.Lines">
            <summary>
            The collection of individual text lines.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.SourceText.GetLinesCore">
            <summary>
            Called from <see cref="P:Loretta.CodeAnalysis.Text.SourceText.Lines"/> to initialize the <see cref="T:Loretta.CodeAnalysis.Text.TextLineCollection"/>. Thereafter,
            the collection is cached.
            </summary>
            <returns>A new <see cref="T:Loretta.CodeAnalysis.Text.TextLineCollection"/> representing the individual text lines.</returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.SourceText.ContentEquals(Loretta.CodeAnalysis.Text.SourceText)">
            <summary>
            Compares the content with content of another <see cref="T:Loretta.CodeAnalysis.Text.SourceText"/>.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.SourceText.ContentEqualsImpl(Loretta.CodeAnalysis.Text.SourceText)">
            <summary>
            Implements equality comparison of the content of two different instances of <see cref="T:Loretta.CodeAnalysis.Text.SourceText"/>.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.SourceText.TryReadByteOrderMark(System.Byte[],System.Int32,System.Int32@)">
            <summary>
            Detect an encoding by looking for byte order marks.
            </summary>
            <param name="source">A buffer containing the encoded text.</param>
            <param name="length">The length of valid data in the buffer.</param>
            <param name="preambleLength">The length of any detected byte order marks.</param>
            <returns>The detected encoding or null if no recognized byte order mark was present.</returns>
        </member>
        <member name="T:Loretta.CodeAnalysis.Text.SourceTextContainer">
            <summary>
            An object that contains an instance of a SourceText and raises events when its current instance
            changes.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.Text.SourceTextContainer.CurrentText">
            <summary>
            The current text instance.
            </summary>
        </member>
        <member name="E:Loretta.CodeAnalysis.Text.SourceTextContainer.TextChanged">
            <summary>
            Raised when the current text instance changes.
            </summary>
        </member>
        <member name="T:Loretta.CodeAnalysis.Text.SourceTextStream">
            <summary>
            A read-only, non-seekable <see cref="T:System.IO.Stream"/> over a <see cref="T:Loretta.CodeAnalysis.Text.SourceText"/>.
            </summary>
        </member>
        <member name="T:Loretta.CodeAnalysis.Text.StringBuilderText">
            <summary>
            Implementation of <see cref="T:Loretta.CodeAnalysis.Text.SourceText"/> based on a <see cref="T:System.Text.StringBuilder"/> input
            </summary>
        </member>
        <member name="F:Loretta.CodeAnalysis.Text.StringBuilderText._builder">
            <summary>
            Underlying string on which this SourceText instance is based
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.Text.StringBuilderText.Builder">
            <summary>
            Underlying string which is the source of this SourceText instance
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.Text.StringBuilderText.Length">
            <summary>
            The length of the text represented by <see cref="T:Loretta.CodeAnalysis.Text.StringBuilderText"/>.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.Text.StringBuilderText.Item(System.Int32)">
            <summary>
            Returns a character at given position.
            </summary>
            <param name="position">The position to get the character from.</param>
            <returns>The character.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">When position is negative or 
            greater than <see cref="P:Loretta.CodeAnalysis.Text.StringBuilderText.Length"/>.</exception>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.StringBuilderText.ToString(Loretta.CodeAnalysis.Text.TextSpan)">
            <summary>
            Provides a string representation of the StringBuilderText located within given span.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">When given span is outside of the text range.</exception>
        </member>
        <member name="T:Loretta.CodeAnalysis.Text.StringText">
            <summary>
            Implementation of SourceText based on a <see cref="T:System.String"/> input
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.Text.StringText.Source">
            <summary>
            Underlying string which is the source of this <see cref="T:Loretta.CodeAnalysis.Text.StringText"/>instance
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.Text.StringText.Length">
            <summary>
            The length of the text represented by <see cref="T:Loretta.CodeAnalysis.Text.StringText"/>.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.Text.StringText.Item(System.Int32)">
            <summary>
            Returns a character at given position.
            </summary>
            <param name="position">The position to get the character from.</param>
            <returns>The character.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">When position is negative or 
            greater than <see cref="P:Loretta.CodeAnalysis.Text.StringText.Length"/>.</exception>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.StringText.ToString(Loretta.CodeAnalysis.Text.TextSpan)">
            <summary>
            Provides a string representation of the StringText located within given span.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">When given span is outside of the text range.</exception>
        </member>
        <member name="T:Loretta.CodeAnalysis.Text.SubText">
            <summary>
            A <see cref="T:Loretta.CodeAnalysis.Text.SourceText"/> that represents a subrange of another <see cref="T:Loretta.CodeAnalysis.Text.SourceText"/>.
            </summary>
        </member>
        <member name="T:Loretta.CodeAnalysis.Text.TextChange">
            <summary>
            Describes a single change when a particular span is replaced with a new text.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.Text.TextChange.Span">
            <summary>
            The original span of the changed text. 
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.Text.TextChange.NewText">
            <summary>
            The new text.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.TextChange.#ctor(Loretta.CodeAnalysis.Text.TextSpan,System.String)">
            <summary>
            Initializes a new instance of <see cref="T:Loretta.CodeAnalysis.Text.TextChange"/>
            </summary>
            <param name="span">The original span of the changed text.</param>
            <param name="newText">The new text.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.TextChange.ToString">
            <summary>
            Provides a string representation for <see cref="T:Loretta.CodeAnalysis.Text.TextChange"/>.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.TextChange.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.TextChange.Equals(Loretta.CodeAnalysis.Text.TextChange)">
            <inheritdoc/>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.TextChange.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.TextChange.op_Equality(Loretta.CodeAnalysis.Text.TextChange,Loretta.CodeAnalysis.Text.TextChange)">
            <summary>
            Checks whether two text changes are equal.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.TextChange.op_Inequality(Loretta.CodeAnalysis.Text.TextChange,Loretta.CodeAnalysis.Text.TextChange)">
            <summary>
            Checks whether two text changes are not equal.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.TextChange.op_Implicit(Loretta.CodeAnalysis.Text.TextChange)~Loretta.CodeAnalysis.Text.TextChangeRange">
            <summary>
            Converts a <see cref="T:Loretta.CodeAnalysis.Text.TextChange"/> to a <see cref="T:Loretta.CodeAnalysis.Text.TextChangeRange"/>.
            </summary>
            <param name="change"></param>
        </member>
        <member name="P:Loretta.CodeAnalysis.Text.TextChange.NoChanges">
            <summary>
            An empty set of changes.
            </summary>
        </member>
        <member name="T:Loretta.CodeAnalysis.Text.TextChangeEventArgs">
            <summary>
            Represents state for a TextChanged event.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.TextChangeEventArgs.#ctor(Loretta.CodeAnalysis.Text.SourceText,Loretta.CodeAnalysis.Text.SourceText,System.Collections.Generic.IEnumerable{Loretta.CodeAnalysis.Text.TextChangeRange})">
            <summary>
            Initializes an instance of <see cref="T:Loretta.CodeAnalysis.Text.TextChangeEventArgs"/>.
            </summary>
            <param name="oldText">The text before the change.</param>
            <param name="newText">The text after the change.</param>
            <param name="changes">A set of ranges for the change.</param>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.TextChangeEventArgs.#ctor(Loretta.CodeAnalysis.Text.SourceText,Loretta.CodeAnalysis.Text.SourceText,Loretta.CodeAnalysis.Text.TextChangeRange[])">
            <summary>
            Initializes an instance of <see cref="T:Loretta.CodeAnalysis.Text.TextChangeEventArgs"/>.
            </summary>
            <param name="oldText">The text before the change.</param>
            <param name="newText">The text after the change.</param>
            <param name="changes">A set of ranges for the change.</param>
        </member>
        <member name="P:Loretta.CodeAnalysis.Text.TextChangeEventArgs.OldText">
            <summary>
            Gets the text before the change.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.Text.TextChangeEventArgs.NewText">
            <summary>
            Gets the text after the change.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.Text.TextChangeEventArgs.Changes">
            <summary>
            Gets the set of ranges for the change.
            </summary>
        </member>
        <member name="T:Loretta.CodeAnalysis.Text.TextChangeRange">
            <summary>
            Represents the change to a span of text.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.Text.TextChangeRange.Span">
            <summary>
            The span of text before the edit which is being changed
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.Text.TextChangeRange.NewLength">
            <summary>
            Width of the span after the edit.  A 0 here would represent a delete
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.TextChangeRange.#ctor(Loretta.CodeAnalysis.Text.TextSpan,System.Int32)">
            <summary>
            Initializes a new instance of <see cref="T:Loretta.CodeAnalysis.Text.TextChangeRange"/>.
            </summary>
            <param name="span"></param>
            <param name="newLength"></param>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.TextChangeRange.Equals(Loretta.CodeAnalysis.Text.TextChangeRange)">
            <summary>
            Compares current instance of <see cref="T:Loretta.CodeAnalysis.Text.TextChangeRange"/> to another.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.TextChangeRange.Equals(System.Object)">
            <summary>
            Compares current instance of <see cref="T:Loretta.CodeAnalysis.Text.TextChangeRange"/> to another.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.TextChangeRange.GetHashCode">
            <summary>
            Provides hash code for current instance of <see cref="T:Loretta.CodeAnalysis.Text.TextChangeRange"/>.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.TextChangeRange.op_Equality(Loretta.CodeAnalysis.Text.TextChangeRange,Loretta.CodeAnalysis.Text.TextChangeRange)">
            <summary>
            Determines if two instances of <see cref="T:Loretta.CodeAnalysis.Text.TextChangeRange"/> are same.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.TextChangeRange.op_Inequality(Loretta.CodeAnalysis.Text.TextChangeRange,Loretta.CodeAnalysis.Text.TextChangeRange)">
            <summary>
            Determines if two instances of <see cref="T:Loretta.CodeAnalysis.Text.TextChangeRange"/> are different.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.Text.TextChangeRange.NoChanges">
            <summary>
            An empty set of changes.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.TextChangeRange.Collapse(System.Collections.Generic.IEnumerable{Loretta.CodeAnalysis.Text.TextChangeRange})">
            <summary>
            Collapse a set of <see cref="T:Loretta.CodeAnalysis.Text.TextChangeRange"/>s into a single encompassing range.  If
            the set of ranges provided is empty, an empty range is returned.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.TextChangeRange.ToString">
            <summary>
            Converts the text change range to a string.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Loretta.CodeAnalysis.Text.TextLine">
            <summary>
            Information about the character boundaries of a single line of text.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.TextLine.FromSpan(Loretta.CodeAnalysis.Text.SourceText,Loretta.CodeAnalysis.Text.TextSpan)">
            <summary>
            Creates a <see cref="T:Loretta.CodeAnalysis.Text.TextLine"/> instance.
            </summary>
            <param name="text">The source text.</param>
            <param name="span">The span of the line.</param>
            <returns>An instance of <see cref="T:Loretta.CodeAnalysis.Text.TextLine"/>.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">The span does not represent a text line.</exception>
        </member>
        <member name="P:Loretta.CodeAnalysis.Text.TextLine.Text">
            <summary>
            Gets the source text.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.Text.TextLine.LineNumber">
            <summary>
            Gets the zero-based line number.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.Text.TextLine.Start">
            <summary>
            Gets the start position of the line.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.Text.TextLine.End">
            <summary>
            Gets the end position of the line not including the line break.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.Text.TextLine.EndIncludingLineBreak">
            <summary>
            Gets the end position of the line including the line break.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.Text.TextLine.Span">
            <summary>
            Gets the line span not including the line break.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.Text.TextLine.SpanIncludingLineBreak">
            <summary>
            Gets the line span including the line break.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.TextLine.ToString">
            <summary>
            Returns the text for this line.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.TextLine.op_Equality(Loretta.CodeAnalysis.Text.TextLine,Loretta.CodeAnalysis.Text.TextLine)">
            <summary>
            Checks whether two text lines are equal.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.TextLine.op_Inequality(Loretta.CodeAnalysis.Text.TextLine,Loretta.CodeAnalysis.Text.TextLine)">
            <summary>
            Checks whether two text lines are not equal.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.TextLine.Equals(Loretta.CodeAnalysis.Text.TextLine)">
            <inheritdoc/>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.TextLine.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.TextLine.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="T:Loretta.CodeAnalysis.Text.TextLineCollection">
            <summary>
            Abstract base class for <see cref="T:Loretta.CodeAnalysis.Text.TextLine"/> collections.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.Text.TextLineCollection.Count">
            <summary>
            The count of <see cref="T:Loretta.CodeAnalysis.Text.TextLine"/> items in the collection
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.Text.TextLineCollection.Item(System.Int32)">
            <summary>
            Gets the <see cref="T:Loretta.CodeAnalysis.Text.TextLine"/> item at the specified index.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.TextLineCollection.IndexOf(System.Int32)">
            <summary>
            The index of the TextLine that encompasses the character position.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.TextLineCollection.GetLineFromPosition(System.Int32)">
            <summary>
            Gets a <see cref="T:Loretta.CodeAnalysis.Text.TextLine"/> that encompasses the character position.
            </summary>
            <param name="position"></param>
            <returns></returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.TextLineCollection.GetLinePosition(System.Int32)">
            <summary>
            Gets a <see cref="T:Loretta.CodeAnalysis.Text.LinePosition"/> corresponding to a character position.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.TextLineCollection.GetLinePositionSpan(Loretta.CodeAnalysis.Text.TextSpan)">
            <summary>
            Convert a <see cref="T:Loretta.CodeAnalysis.Text.TextSpan"/> to a <see cref="T:Loretta.CodeAnalysis.Text.LinePositionSpan"/>.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.TextLineCollection.GetPosition(Loretta.CodeAnalysis.Text.LinePosition)">
            <summary>
            Convert a <see cref="T:Loretta.CodeAnalysis.Text.LinePosition"/> to a position.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.TextLineCollection.GetTextSpan(Loretta.CodeAnalysis.Text.LinePositionSpan)">
            <summary>
            Convert a <see cref="T:Loretta.CodeAnalysis.Text.LinePositionSpan"/> to <see cref="T:Loretta.CodeAnalysis.Text.TextSpan"/>.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.TextLineCollection.GetEnumerator">
            <summary>
            Returns the enumerator for this text line collection.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Loretta.CodeAnalysis.Text.TextLineCollection.Enumerator">
            <summary>
            An enumerator for <see cref="T:Loretta.CodeAnalysis.Text.TextLineCollection"/>.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.Text.TextLineCollection.Enumerator.Current">
            <inheritdoc cref="P:System.Collections.Generic.IEnumerator`1.Current"/>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.TextLineCollection.Enumerator.MoveNext">
            <inheritdoc cref="M:System.Collections.IEnumerator.MoveNext"/>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.TextLineCollection.Enumerator.Equals(System.Object)">
            <summary>
            Not supported. Do not use.
            </summary>
            <param name="obj"></param>
            <returns></returns>
            <exception cref="T:System.NotSupportedException">
            Always thrown.
            </exception>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.TextLineCollection.Enumerator.GetHashCode">
            <summary>
            Not supported. Do not use.
            </summary>
            <returns></returns>
            <exception cref="T:System.NotSupportedException">
            Always thrown.
            </exception>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.TextLineCollection.Enumerator.op_Equality(Loretta.CodeAnalysis.Text.TextLineCollection.Enumerator,Loretta.CodeAnalysis.Text.TextLineCollection.Enumerator)">
            <summary>
            Not supported. Do not use.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
            <exception cref="T:System.NotSupportedException">
            Always thrown.
            </exception>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.TextLineCollection.Enumerator.op_Inequality(Loretta.CodeAnalysis.Text.TextLineCollection.Enumerator,Loretta.CodeAnalysis.Text.TextLineCollection.Enumerator)">
            <summary>
            Not supported. Do not use.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
            <exception cref="T:System.NotSupportedException">
            Always thrown.
            </exception>
        </member>
        <member name="T:Loretta.CodeAnalysis.Text.TextSpan">
            <summary>
            Immutable abstract representation of a span of text.  For example, in an error diagnostic that reports a
            location, it could come from a parsed string, text from a tool editor buffer, etc.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.TextSpan.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a TextSpan instance beginning with the position Start and having the Length
            specified with <paramref name="length" />.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.Text.TextSpan.Start">
            <summary>
            Start point of the span.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.Text.TextSpan.End">
            <summary>
            End of the span.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.Text.TextSpan.Length">
            <summary>
            Length of the span.
            </summary>
        </member>
        <member name="P:Loretta.CodeAnalysis.Text.TextSpan.IsEmpty">
            <summary>
            Determines whether or not the span is empty.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.TextSpan.Contains(System.Int32)">
            <summary>
            Determines whether the position lies within the span.
            </summary>
            <param name="position">
            The position to check.
            </param>
            <returns>
            <c>true</c> if the position is greater than or equal to Start and strictly less 
            than End, otherwise <c>false</c>.
            </returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.TextSpan.Contains(Loretta.CodeAnalysis.Text.TextSpan)">
            <summary>
            Determines whether <paramref name="span"/> falls completely within this span.
            </summary>
            <param name="span">
            The span to check.
            </param>
            <returns>
            <c>true</c> if the specified span falls completely within this span, otherwise <c>false</c>.
            </returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.TextSpan.OverlapsWith(Loretta.CodeAnalysis.Text.TextSpan)">
            <summary>
            Determines whether <paramref name="span"/> overlaps this span. Two spans are considered to overlap 
            if they have positions in common and neither is empty. Empty spans do not overlap with any 
            other span.
            </summary>
            <param name="span">
            The span to check.
            </param>
            <returns>
            <c>true</c> if the spans overlap, otherwise <c>false</c>.
            </returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.TextSpan.Overlap(Loretta.CodeAnalysis.Text.TextSpan)">
            <summary>
            Returns the overlap with the given span, or null if there is no overlap.
            </summary>
            <param name="span">
            The span to check.
            </param>
            <returns>
            The overlap of the spans, or null if the overlap is empty.
            </returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.TextSpan.IntersectsWith(Loretta.CodeAnalysis.Text.TextSpan)">
            <summary>
            Determines whether <paramref name="span"/> intersects this span. Two spans are considered to 
            intersect if they have positions in common or the end of one span 
            coincides with the start of the other span.
            </summary>
            <param name="span">
            The span to check.
            </param>
            <returns>
            <c>true</c> if the spans intersect, otherwise <c>false</c>.
            </returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.TextSpan.IntersectsWith(System.Int32)">
            <summary>
            Determines whether <paramref name="position"/> intersects this span. 
            A position is considered to intersect if it is between the start and
            end positions (inclusive) of this span.
            </summary>
            <param name="position">
            The position to check.
            </param>
            <returns>
            <c>true</c> if the position intersects, otherwise <c>false</c>.
            </returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.TextSpan.Intersection(Loretta.CodeAnalysis.Text.TextSpan)">
            <summary>
            Returns the intersection with the given span, or null if there is no intersection.
            </summary>
            <param name="span">
            The span to check.
            </param>
            <returns>
            The intersection of the spans, or null if the intersection is empty.
            </returns>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.TextSpan.FromBounds(System.Int32,System.Int32)">
            <summary>
            Creates a new <see cref="T:Loretta.CodeAnalysis.Text.TextSpan"/> from <paramref name="start" /> and <paramref
            name="end"/> positions as opposed to a position and length.
            
            The returned TextSpan contains the range with <paramref name="start"/> inclusive, 
            and <paramref name="end"/> exclusive.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.TextSpan.op_Equality(Loretta.CodeAnalysis.Text.TextSpan,Loretta.CodeAnalysis.Text.TextSpan)">
            <summary>
            Determines if two instances of <see cref="T:Loretta.CodeAnalysis.Text.TextSpan"/> are the same.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.TextSpan.op_Inequality(Loretta.CodeAnalysis.Text.TextSpan,Loretta.CodeAnalysis.Text.TextSpan)">
            <summary>
            Determines if two instances of <see cref="T:Loretta.CodeAnalysis.Text.TextSpan"/> are different.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.TextSpan.Equals(Loretta.CodeAnalysis.Text.TextSpan)">
            <summary>
            Determines if current instance of <see cref="T:Loretta.CodeAnalysis.Text.TextSpan"/> is equal to another.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.TextSpan.Equals(System.Object)">
            <summary>
            Determines if current instance of <see cref="T:Loretta.CodeAnalysis.Text.TextSpan"/> is equal to another.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.TextSpan.GetHashCode">
            <summary>
            Produces a hash code for <see cref="T:Loretta.CodeAnalysis.Text.TextSpan"/>.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.TextSpan.ToString">
            <summary>
            Provides a string representation for <see cref="T:Loretta.CodeAnalysis.Text.TextSpan"/>.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.TextSpan.CompareTo(Loretta.CodeAnalysis.Text.TextSpan)">
            <summary>
            Compares current instance of <see cref="T:Loretta.CodeAnalysis.Text.TextSpan"/> with another.
            </summary>
        </member>
        <member name="T:Loretta.CodeAnalysis.Text.TextUtilities">
            <summary>
            Holder for common Text Utility functions and values
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.TextUtilities.GetStartAndLengthOfLineBreakEndingAt(Loretta.CodeAnalysis.Text.SourceText,System.Int32,System.Int32@,System.Int32@)">
            <summary>
            Return startLineBreak = index-1, lengthLineBreak = 2   if there is a \r\n at index-1
            Return startLineBreak = index,   lengthLineBreak = 1   if there is a 1-char newline at index
            Return startLineBreak = index+1, lengthLineBreak = 0   if there is no newline at index.
            </summary>
        </member>
        <member name="M:Loretta.CodeAnalysis.Text.TextUtilities.IsAnyLineBreakCharacter(System.Char)">
            <summary>
            Determine if the character in question is any line break character
            </summary>
        </member>
        <member name="T:Loretta.CodeAnalysis.TreeDumper">
            <summary>
            This is ONLY used id BoundNode.cs Debug method - Dump()
            </summary>
        </member>
        <member name="T:Loretta.CodeAnalysis.TreeDumperNode">
            <summary>
            This is ONLY used for debugging purpose
            </summary>
        </member>
        <member name="M:Loretta.Utilities.ArrayExtensions.BinarySearchUpperBound(System.Int32[],System.Int32)">
            <summary>
            Search a sorted integer array for the target value in O(log N) time.
            </summary>
            <param name="array">The array of integers which must be sorted in ascending order.</param>
            <param name="value">The target value.</param>
            <returns>An index in the array pointing to the position where <paramref name="value"/> should be
            inserted in order to maintain the sorted order. All values to the right of this position will be
            strictly greater than <paramref name="value"/>. Note that this may return a position off the end
            of the array if all elements are less than or equal to <paramref name="value"/>.</returns>
        </member>
        <member name="M:Loretta.Utilities.LorettaDebug.Assert(System.Boolean)">
            <inheritdoc cref="M:Loretta.Utilities.LorettaDebug.Assert(System.Boolean)"/>
        </member>
        <member name="M:Loretta.Utilities.LorettaDebug.Assert(System.Boolean,System.String)">
            <inheritdoc cref="M:Loretta.Utilities.LorettaDebug.Assert(System.Boolean,System.String)"/>
        </member>
        <member name="M:Loretta.Utilities.EncodingExtensions.GetMaxCharCountOrThrowIfHuge(System.Text.Encoding,System.IO.Stream)">
            <summary>
            Get maximum char count needed to decode the entire stream.
            </summary>
            <exception cref="T:System.IO.IOException">Stream is so big that max char count can't fit in <see cref="T:System.Int32"/>.</exception> 
        </member>
        <member name="M:Loretta.Utilities.EnumerableExtensions.IsEmpty``1(``0[])">
            <remarks>
            This method is necessary to avoid an ambiguity between <see cref="M:Loretta.Utilities.EnumerableExtensions.IsEmpty``1(System.Collections.Generic.IReadOnlyCollection{``0})"/> and <see cref="M:Loretta.Utilities.EnumerableExtensions.IsEmpty``1(System.Collections.Generic.ICollection{``0})"/>.
            </remarks>
        </member>
        <member name="M:Loretta.Utilities.EnumerableExtensions.IsEmpty``1(System.Collections.Generic.List{``0})">
            <remarks>
            This method is necessary to avoid an ambiguity between <see cref="M:Loretta.Utilities.EnumerableExtensions.IsEmpty``1(System.Collections.Generic.IReadOnlyCollection{``0})"/> and <see cref="M:Loretta.Utilities.EnumerableExtensions.IsEmpty``1(System.Collections.Generic.ICollection{``0})"/>.
            </remarks>
        </member>
        <member name="M:Loretta.Utilities.EnumerableExtensions.AsSingleton``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns the only element of specified sequence if it has exactly one, and default(TSource) otherwise.
            Unlike <see cref="M:System.Linq.Enumerable.SingleOrDefault``1(System.Collections.Generic.IEnumerable{``0})"/> doesn't throw if there is more than one element in the sequence.
            </summary>
        </member>
        <member name="T:Loretta.Utilities.Functions`1">
            <summary>
            Cached versions of commonly used delegates.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Loretta.Utilities.Predicates`1">
            <summary>
            Cached versions of commonly used delegates.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Loretta.Utilities.ExceptionUtilities.UnexpectedValue(System.Object)">
            <summary>
            Creates an <see cref="T:System.InvalidOperationException"/> with information about an unexpected value.
            </summary>
            <param name="o">The unexpected value.</param>
            <returns>The <see cref="T:System.InvalidOperationException"/>, which should be thrown by the caller.</returns>
        </member>
        <member name="M:Loretta.Utilities.Hash.Combine(System.Int32,System.Int32)">
            <summary>
            This is how VB Anonymous Types combine hash values for fields.
            </summary>
        </member>
        <member name="M:Loretta.Utilities.Hash.Combine``1(``0,System.Int32)">
            <summary>
            This is how VB Anonymous Types combine hash values for fields.
            PERF: Do not use with enum types because that involves multiple
            unnecessary boxing operations.  Unfortunately, we can't constrain
            T to "non-enum", so we'll use a more restrictive constraint.
            </summary>
        </member>
        <member name="F:Loretta.Utilities.Hash.FnvOffsetBias">
            <summary>
            The offset bias value used in the FNV-1a algorithm
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
        </member>
        <member name="F:Loretta.Utilities.Hash.FnvPrime">
            <summary>
            The generative factor used in the FNV-1a algorithm
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
        </member>
        <member name="M:Loretta.Utilities.Hash.GetFNVHashCode(System.Byte[])">
            <summary>
            Compute the FNV-1a hash of a sequence of bytes
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="data">The sequence of bytes</param>
            <returns>The FNV-1a hash of <paramref name="data"/></returns>
        </member>
        <member name="M:Loretta.Utilities.Hash.GetFNVHashCode(System.ReadOnlySpan{System.Byte},System.Boolean@)">
            <summary>
            Compute the FNV-1a hash of a sequence of bytes and determines if the byte
            sequence is valid ASCII and hence the hash code matches a char sequence
            encoding the same text.
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="data">The sequence of bytes that are likely to be ASCII text.</param>
            <param name="isAscii">True if the sequence contains only characters in the ASCII range.</param>
            <returns>The FNV-1a hash of <paramref name="data"/></returns>
        </member>
        <member name="M:Loretta.Utilities.Hash.GetFNVHashCode(System.Collections.Immutable.ImmutableArray{System.Byte})">
            <summary>
            Compute the FNV-1a hash of a sequence of bytes
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="data">The sequence of bytes</param>
            <returns>The FNV-1a hash of <paramref name="data"/></returns>
        </member>
        <member name="M:Loretta.Utilities.Hash.GetFNVHashCode(System.ReadOnlySpan{System.Char})">
            <summary>
            Compute the hashcode of a sub-string using FNV-1a
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            Note: FNV-1a was developed and tuned for 8-bit sequences. We're using it here
            for 16-bit Unicode chars on the understanding that the majority of chars will
            fit into 8-bits and, therefore, the algorithm will retain its desirable traits
            for generating hash codes.
            </summary>
        </member>
        <member name="M:Loretta.Utilities.Hash.GetFNVHashCode(System.String,System.Int32,System.Int32)">
            <summary>
            Compute the hashcode of a sub-string using FNV-1a
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            Note: FNV-1a was developed and tuned for 8-bit sequences. We're using it here
            for 16-bit Unicode chars on the understanding that the majority of chars will
            fit into 8-bits and, therefore, the algorithm will retain its desirable traits
            for generating hash codes.
            </summary>
            <param name="text">The input string</param>
            <param name="start">The start index of the first character to hash</param>
            <param name="length">The number of characters, beginning with <paramref name="start"/> to hash</param>
            <returns>The FNV-1a hash code of the substring beginning at <paramref name="start"/> and ending after <paramref name="length"/> characters.</returns>
        </member>
        <member name="M:Loretta.Utilities.Hash.GetFNVHashCode(System.String,System.Int32)">
            <summary>
            Compute the hashcode of a sub-string using FNV-1a
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="text">The input string</param>
            <param name="start">The start index of the first character to hash</param>
            <returns>The FNV-1a hash code of the substring beginning at <paramref name="start"/> and ending at the end of the string.</returns>
        </member>
        <member name="M:Loretta.Utilities.Hash.GetFNVHashCode(System.String)">
            <summary>
            Compute the hashcode of a string using FNV-1a
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="text">The input string</param>
            <returns>The FNV-1a hash code of <paramref name="text"/></returns>
        </member>
        <member name="M:Loretta.Utilities.Hash.GetFNVHashCode(System.Text.StringBuilder)">
            <summary>
            Compute the hashcode of a string using FNV-1a
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="text">The input string</param>
            <returns>The FNV-1a hash code of <paramref name="text"/></returns>
        </member>
        <member name="M:Loretta.Utilities.Hash.GetFNVHashCode(System.Char[],System.Int32,System.Int32)">
            <summary>
            Compute the hashcode of a sub string using FNV-1a
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="text">The input string as a char array</param>
            <param name="start">The start index of the first character to hash</param>
            <param name="length">The number of characters, beginning with <paramref name="start"/> to hash</param>
            <returns>The FNV-1a hash code of the substring beginning at <paramref name="start"/> and ending after <paramref name="length"/> characters.</returns>
        </member>
        <member name="M:Loretta.Utilities.Hash.GetFNVHashCode(System.Char)">
            <summary>
            Compute the hashcode of a single character using the FNV-1a algorithm
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            Note: In general, this isn't any more useful than "char.GetHashCode". However,
            it may be needed if you need to generate the same hash code as a string or
            substring with just a single character.
            </summary>
            <param name="ch">The character to hash</param>
            <returns>The FNV-1a hash code of the character.</returns>
        </member>
        <member name="M:Loretta.Utilities.Hash.CombineFNVHash(System.Int32,System.String)">
            <summary>
            Combine a string with an existing FNV-1a hash code
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="hashCode">The accumulated hash code</param>
            <param name="text">The string to combine</param>
            <returns>The result of combining <paramref name="hashCode"/> with <paramref name="text"/> using the FNV-1a algorithm</returns>
        </member>
        <member name="M:Loretta.Utilities.Hash.CombineFNVHash(System.Int32,System.Char)">
            <summary>
            Combine a char with an existing FNV-1a hash code
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="hashCode">The accumulated hash code</param>
            <param name="ch">The new character to combine</param>
            <returns>The result of combining <paramref name="hashCode"/> with <paramref name="ch"/> using the FNV-1a algorithm</returns>
        </member>
        <member name="M:Loretta.Utilities.Hash.GetJenkinsOneAtATimeHashCode(System.ReadOnlySpan{System.Char})">
            <summary>
            Jenkins's one_at_a_time hash is adapted here from a WWW page by Bob Jenkins
            See https://en.wikipedia.org/wiki/Jenkins_hash_function
            </summary>
            <param name="input">The string that will get hashed</param>
            <returns>The hash of <paramref name="input"/></returns>
        </member>
        <member name="M:Loretta.Utilities.LorettaString.IsNullOrEmpty(System.String)">
            <inheritdoc cref="M:System.String.IsNullOrEmpty(System.String)"/>
        </member>
        <member name="M:Loretta.Utilities.LorettaString.IsNullOrWhiteSpace(System.String)">
            <inheritdoc cref="M:System.String.IsNullOrWhiteSpace(System.String)"/>
        </member>
        <member name="T:Loretta.Utilities.PerformanceSensitiveAttribute">
            <summary>
            Indicates that a code element is performance sensitive under a known scenario.
            </summary>
            <remarks>
            <para>When applying this attribute, only explicitly set the values for properties specifically indicated by the
            test/measurement technique described in the associated <see cref="P:Loretta.Utilities.PerformanceSensitiveAttribute.Uri"/>.</para>
            </remarks>
        </member>
        <member name="P:Loretta.Utilities.PerformanceSensitiveAttribute.Uri">
            <summary>
            Gets the location where the original problem is documented, likely with steps to reproduce the issue and/or
            validate performance related to a change in the method.
            </summary>
        </member>
        <member name="P:Loretta.Utilities.PerformanceSensitiveAttribute.Constraint">
            <summary>
            Gets or sets a description of the constraint imposed by the original performance issue.
            </summary>
            <remarks>
            <para>Constraints are normally specified by other specific properties that allow automated validation of the
            constraint. This property supports documenting constraints which cannot be described in terms of other
            constraint properties.</para>
            </remarks>
        </member>
        <member name="P:Loretta.Utilities.PerformanceSensitiveAttribute.AllowCaptures">
            <summary>
            Gets or sets a value indicating whether captures are allowed.
            </summary>
        </member>
        <member name="P:Loretta.Utilities.PerformanceSensitiveAttribute.AllowImplicitBoxing">
            <summary>
            Gets or sets a value indicating whether implicit boxing of value types is allowed.
            </summary>
        </member>
        <member name="P:Loretta.Utilities.PerformanceSensitiveAttribute.AllowGenericEnumeration">
            <summary>
            Gets or sets a value indicating whether enumeration of a generic
            <see cref="T:System.Collections.Generic.IEnumerable`1"/> is allowed.
            </summary>
        </member>
        <member name="P:Loretta.Utilities.PerformanceSensitiveAttribute.AllowLocks">
            <summary>
            Gets or sets a value indicating whether locks are allowed.
            </summary>
        </member>
        <member name="P:Loretta.Utilities.PerformanceSensitiveAttribute.OftenCompletesSynchronously">
            <summary>
            Gets or sets a value indicating whether the asynchronous state machine typically completes synchronously.
            </summary>
            <remarks>
            <para>When <see langword="true"/>, validation of this performance constraint typically involves analyzing
            the method to ensure synchronous completion of the state machine does not require the allocation of a
            <see cref="T:System.Threading.Tasks.Task"/>, either through caching the result or by using
            <see cref="T:System.Threading.Tasks.ValueTask`1"/>.</para>
            </remarks>
        </member>
        <member name="P:Loretta.Utilities.PerformanceSensitiveAttribute.IsParallelEntry">
            <summary>
            Gets or sets a value indicating whether this is an entry point to a parallel algorithm.
            </summary>
            <remarks>
            <para>Parallelization APIs and algorithms, e.g. <c>Parallel.ForEach</c>, may be efficient for parallel entry
            points (few direct calls but large amounts of iterative work), but are problematic when called inside the
            iterations themselves. Performance-sensitive code should avoid the use of heavy parallelization APIs except
            for known entry points to the parallel portion of code.</para>
            </remarks>
        </member>
        <member name="T:Loretta.Utilities.ReferenceEqualityComparer">
            <summary>
            Compares objects based upon their reference identity.
            </summary>
        </member>
        <member name="T:Loretta.Utilities.StringOrdinalComparer">
            <summary>
            Compares string based upon their ordinal equality.
            We use this comparer for string identifiers because it does exactly what we need and nothing more
            The StringComparer.Ordinal as implemented by StringComparer is more complex to support 
            case sensitive and insensitive compares depending on flags.
            It also defers to the default string hash function that might not be the best for our scenarios.
            </summary>
        </member>
        <member name="T:Loretta.Utilities.StringTable">
            <summary>
            This is basically a lossy cache of strings that is searchable by
            strings, string sub ranges, character array ranges or string-builder.
            </summary>
        </member>
        <member name="M:Loretta.Utilities.TextChangeRangeExtensions.Merge(System.Collections.Immutable.ImmutableArray{Loretta.CodeAnalysis.Text.TextChangeRange},System.Collections.Immutable.ImmutableArray{Loretta.CodeAnalysis.Text.TextChangeRange})">
             <summary>
             Merges the new change ranges into the old change ranges, adjusting the new ranges to be with respect to the original text
             (with neither old or new changes applied) instead of with respect to the original text after "old changes" are applied.
            
             This may require splitting, concatenation, etc. of individual change ranges.
             </summary>
             <remarks>
             Both `oldChanges` and `newChanges` must contain non-overlapping spans in ascending order.
             </remarks>
        </member>
        <member name="T:Loretta.Utilities.TextChangeRangeExtensions.UnadjustedNewChange">
            <summary>
            Represents a new change being processed by <see cref="M:Loretta.Utilities.TextChangeRangeExtensions.Merge(System.Collections.Immutable.ImmutableArray{Loretta.CodeAnalysis.Text.TextChangeRange},System.Collections.Immutable.ImmutableArray{Loretta.CodeAnalysis.Text.TextChangeRange})"/>.
            Such a new change must be adjusted before being added to the result list.
            </summary>
            <remarks>
            A value of this type may represent the intermediate state of merging of an old change into an unadjusted new change,
            resulting in a temporary unadjusted new change whose <see cref="P:Loretta.Utilities.TextChangeRangeExtensions.UnadjustedNewChange.SpanStart"/> is negative (not valid) until it is adjusted.
            This tends to happen when we need to merge an old change deletion into a new change near the beginning of the text. (see TextChangeTests.Fuzz_4)
            </remarks>
        </member>
        <member name="T:Loretta.Utilities.IObjectWritable">
            <summary>
            Objects that implement this interface know how to write their contents to an <see cref="T:Loretta.Utilities.ObjectWriter"/>,
            so they can be reconstructed later by an <see cref="T:Loretta.Utilities.ObjectReader"/>.
            </summary>
        </member>
        <member name="P:Loretta.Utilities.IObjectWritable.ShouldReuseInSerialization">
            <summary>
            Returns 'true' when the same instance could be used more than once.
            Instances that return 'false' should not be tracked for the purpose 
            of de-duplication while serializing/deserializing.
            </summary>
        </member>
        <member name="T:Loretta.Utilities.ObjectBinder">
            <summary>
            <see cref="T:Loretta.Utilities.ObjectBinder"/> is a registry that maps between arbitrary <see cref="T:System.Type"/>s and 
            the 'reader' function used to deserialize serialized instances of those types.  Registration
            must happen ahead of time using the <see cref="M:Loretta.Utilities.ObjectBinder.RegisterTypeReader(System.Type,System.Func{Loretta.Utilities.ObjectReader,Loretta.Utilities.IObjectWritable})"/> method.
            </summary>
        </member>
        <member name="F:Loretta.Utilities.ObjectBinder.s_gate">
            <summary>
            Lock for all data in this type.
            </summary>
        </member>
        <member name="F:Loretta.Utilities.ObjectBinder.s_lastSnapshot">
            <summary>
            Last created snapshot of our data.  We hand this out instead of exposing our raw
            data so that <see cref="T:Loretta.Utilities.ObjectReader"/> and <see cref="T:Loretta.Utilities.ObjectWriter"/> do not need to
            take any locks while processing.
            </summary>
        </member>
        <member name="F:Loretta.Utilities.ObjectBinder.s_typeToIndex">
            <summary>
            Map from a <see cref="T:System.Type"/> to the corresponding index in <see cref="F:Loretta.Utilities.ObjectBinder.s_types"/> and
            <see cref="F:Loretta.Utilities.ObjectBinder.s_typeReaders"/>.  <see cref="T:Loretta.Utilities.ObjectWriter"/> will write out the index into
            the stream, and <see cref="T:Loretta.Utilities.ObjectReader"/> will use that index to get the reader used
            for deserialization.
            </summary>
        </member>
        <member name="M:Loretta.Utilities.ObjectBinder.GetSnapshot">
            <summary>
            Gets an immutable copy of the state of this binder.  This copy does not need to be
            locked while it is used.
            </summary>
        </member>
        <member name="T:Loretta.Utilities.ObjectReader">
            <summary>
            An <see cref="T:Loretta.Utilities.ObjectReader"/> that deserializes objects from a byte stream.
            </summary>
        </member>
        <member name="F:Loretta.Utilities.ObjectReader.VersionByte1">
            <summary>
            We start the version at something reasonably random.  That way an older file, with 
            some random start-bytes, has little chance of matching our version.  When incrementing
            this version, just change VersionByte2.
            </summary>
        </member>
        <member name="F:Loretta.Utilities.ObjectReader._objectReferenceMap">
            <summary>
            Map of reference id's to deserialized objects.
            </summary>
        </member>
        <member name="F:Loretta.Utilities.ObjectReader._binderSnapshot">
            <summary>
            Copy of the global binder data that maps from Types to the appropriate reading-function
            for that type.  Types register functions directly with <see cref="T:Loretta.Utilities.ObjectBinder"/>, but 
            that means that <see cref="T:Loretta.Utilities.ObjectBinder"/> is both static and locked.  This gives us 
            local copy we can work with without needing to worry about anyone else mutating.
            </summary>
        </member>
        <member name="M:Loretta.Utilities.ObjectReader.#ctor(System.IO.Stream,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Creates a new instance of a <see cref="T:Loretta.Utilities.ObjectReader"/>.
            </summary>
            <param name="stream">The stream to read objects from.</param>
            <param name="leaveOpen">True to leave the <paramref name="stream"/> open after the <see cref="T:Loretta.Utilities.ObjectWriter"/> is disposed.</param>
            <param name="cancellationToken"></param>
        </member>
        <member name="M:Loretta.Utilities.ObjectReader.TryGetReader(System.IO.Stream,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Attempts to create a <see cref="T:Loretta.Utilities.ObjectReader"/> from the provided <paramref name="stream"/>.
            If the <paramref name="stream"/> does not start with a valid header, then <see langword="null"/> will
            be returned.
            </summary>
        </member>
        <member name="M:Loretta.Utilities.ObjectReader.GetReader(System.IO.Stream,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Creates an <see cref="T:Loretta.Utilities.ObjectReader"/> from the provided <paramref name="stream"/>.
            Unlike <see cref="M:Loretta.Utilities.ObjectReader.TryGetReader(System.IO.Stream,System.Boolean,System.Threading.CancellationToken)"/>, it requires the version
            of the data in the stream to exactly match the current format version.
            Should only be used to read data written by the same version of Roslyn.
            </summary>
        </member>
        <member name="T:Loretta.Utilities.ObjectReader.ReaderReferenceMap`1">
            <summary>
            A reference-id to object map, that can share base data efficiently.
            </summary>
        </member>
        <member name="T:Loretta.Utilities.ObjectWriter">
            <summary>
            An <see cref="T:Loretta.Utilities.ObjectWriter"/> that serializes objects to a byte stream.
            </summary>
        </member>
        <member name="F:Loretta.Utilities.ObjectWriter._objectReferenceMap">
            <summary>
            Map of serialized object's reference ids.  The object-reference-map uses reference equality
            for performance.  While the string-reference-map uses value-equality for greater cache hits 
            and reuse.
            
            These are not readonly because they're structs and we mutate them.
            
            When we write out objects/strings we give each successive, unique, item a monotonically 
            increasing integral ID starting at 0.  I.e. the first object gets ID-0, the next gets 
            ID-1 and so on and so forth.  We do *not* include these IDs with the object when it is
            written out.  We only include the ID if we hit the object *again* while writing.
            
            During reading, the reader knows to give each object it reads the same monotonically 
            increasing integral value.  i.e. the first object it reads is put into an array at position
            0, the next at position 1, and so on.  Then, when the reader reads in an object-reference
            it can just retrieved it directly from that array.
            
            In other words, writing and reading take advantage of the fact that they know they will
            write and read objects in the exact same order.  So they only need the IDs for references
            and not the objects themselves because the ID is inferred from the order the object is
            written or read in.
            </summary>
        </member>
        <member name="F:Loretta.Utilities.ObjectWriter._binderSnapshot">
            <summary>
            Copy of the global binder data that maps from Types to the appropriate reading-function
            for that type.  Types register functions directly with <see cref="T:Loretta.Utilities.ObjectBinder"/>, but 
            that means that <see cref="T:Loretta.Utilities.ObjectBinder"/> is both static and locked.  This gives us 
            local copy we can work with without needing to worry about anyone else mutating.
            </summary>
        </member>
        <member name="M:Loretta.Utilities.ObjectWriter.#ctor(System.IO.Stream,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Creates a new instance of a <see cref="T:Loretta.Utilities.ObjectWriter"/>.
            </summary>
            <param name="stream">The stream to write to.</param>
            <param name="leaveOpen">True to leave the <paramref name="stream"/> open after the <see cref="T:Loretta.Utilities.ObjectWriter"/> is disposed.</param>
            <param name="cancellationToken">Cancellation token.</param>
        </member>
        <member name="T:Loretta.Utilities.ObjectWriter.GuidAccessor">
            <summary>
            Used so we can easily grab the low/high 64bits of a guid for serialization.
            </summary>
        </member>
        <member name="M:Loretta.Utilities.ObjectWriter.WriteValue(System.ReadOnlySpan{System.Byte})">
            <summary>
            Write an array of bytes. The array data is provided as a
            <see cref="T:System.ReadOnlySpan`1">ReadOnlySpan</see>&lt;<see cref="T:System.Byte"/>&gt;, and deserialized to a byte array.
            </summary>
            <param name="span">The array data.</param>
        </member>
        <member name="T:Loretta.Utilities.ObjectWriter.WriterReferenceMap">
            <summary>
            An object reference to reference-id map, that can share base data efficiently.
            </summary>
        </member>
        <member name="F:Loretta.Utilities.ObjectWriter.s_reverseTypeMap">
            <summary>
            Indexed by EncodingKind.
            </summary>
        </member>
        <member name="F:Loretta.Utilities.ObjectWriter.ByteMarkerMask">
            <summary>
            byte marker mask for encoding compressed uint 
            </summary>
        </member>
        <member name="F:Loretta.Utilities.ObjectWriter.Byte1Marker">
            <summary>
            byte marker bits for uint encoded in 1 byte.
            </summary>
        </member>
        <member name="F:Loretta.Utilities.ObjectWriter.Byte2Marker">
            <summary>
            byte marker bits for uint encoded in 2 bytes.
            </summary>
        </member>
        <member name="F:Loretta.Utilities.ObjectWriter.Byte4Marker">
            <summary>
            byte marker bits for uint encoded in 4 bytes.
            </summary>
        </member>
        <member name="F:Loretta.Utilities.ObjectWriter.EncodingKind.Null">
            <summary>
            The null value
            </summary>
        </member>
        <member name="F:Loretta.Utilities.ObjectWriter.EncodingKind.Type">
            <summary>
            A type
            </summary>
        </member>
        <member name="F:Loretta.Utilities.ObjectWriter.EncodingKind.Object">
            <summary>
            An object with member values encoded as variants
            </summary>
        </member>
        <member name="F:Loretta.Utilities.ObjectWriter.EncodingKind.ObjectRef_1Byte">
            <summary>
            An object reference with the id encoded as 1 byte.
            </summary>
        </member>
        <member name="F:Loretta.Utilities.ObjectWriter.EncodingKind.ObjectRef_2Bytes">
            <summary>
            An object reference with the id encode as 2 bytes.
            </summary>
        </member>
        <member name="F:Loretta.Utilities.ObjectWriter.EncodingKind.ObjectRef_4Bytes">
            <summary>
            An object reference with the id encoded as 4 bytes.
            </summary>
        </member>
        <member name="F:Loretta.Utilities.ObjectWriter.EncodingKind.StringUtf8">
            <summary>
            A string encoded as UTF8 (using BinaryWriter.Write(string))
            </summary>
        </member>
        <member name="F:Loretta.Utilities.ObjectWriter.EncodingKind.StringUtf16">
            <summary>
            A string encoded as UTF16 (as array of UInt16 values)
            </summary>
        </member>
        <member name="F:Loretta.Utilities.ObjectWriter.EncodingKind.StringRef_1Byte">
            <summary>
            A reference to a string with the id encoded as 1 byte.
            </summary>
        </member>
        <member name="F:Loretta.Utilities.ObjectWriter.EncodingKind.StringRef_2Bytes">
            <summary>
            A reference to a string with the id encoded as 2 bytes.
            </summary>
        </member>
        <member name="F:Loretta.Utilities.ObjectWriter.EncodingKind.StringRef_4Bytes">
            <summary>
            A reference to a string with the id encoded as 4 bytes.
            </summary>
        </member>
        <member name="F:Loretta.Utilities.ObjectWriter.EncodingKind.Boolean_True">
            <summary>
            The boolean value true.
            </summary>
        </member>
        <member name="F:Loretta.Utilities.ObjectWriter.EncodingKind.Boolean_False">
            <summary>
            The boolean value char.
            </summary>
        </member>
        <member name="F:Loretta.Utilities.ObjectWriter.EncodingKind.Char">
            <summary>
            A character value encoded as 2 bytes.
            </summary>
        </member>
        <member name="F:Loretta.Utilities.ObjectWriter.EncodingKind.Int8">
            <summary>
            An Int8 value encoded as 1 byte.
            </summary>
        </member>
        <member name="F:Loretta.Utilities.ObjectWriter.EncodingKind.Int16">
            <summary>
            An Int16 value encoded as 2 bytes.
            </summary>
        </member>
        <member name="F:Loretta.Utilities.ObjectWriter.EncodingKind.Int32">
            <summary>
            An Int32 value encoded as 4 bytes.
            </summary>
        </member>
        <member name="F:Loretta.Utilities.ObjectWriter.EncodingKind.Int32_1Byte">
            <summary>
            An Int32 value encoded as 1 byte.
            </summary>
        </member>
        <member name="F:Loretta.Utilities.ObjectWriter.EncodingKind.Int32_2Bytes">
            <summary>
            An Int32 value encoded as 2 bytes.
            </summary>
        </member>
        <member name="F:Loretta.Utilities.ObjectWriter.EncodingKind.Int32_0">
            <summary>
            The Int32 value 0
            </summary>
        </member>
        <member name="F:Loretta.Utilities.ObjectWriter.EncodingKind.Int32_1">
            <summary>
            The Int32 value 1
            </summary>
        </member>
        <member name="F:Loretta.Utilities.ObjectWriter.EncodingKind.Int32_2">
            <summary>
            The Int32 value 2
            </summary>
        </member>
        <member name="F:Loretta.Utilities.ObjectWriter.EncodingKind.Int32_3">
            <summary>
            The Int32 value 3
            </summary>
        </member>
        <member name="F:Loretta.Utilities.ObjectWriter.EncodingKind.Int32_4">
            <summary>
            The Int32 value 4
            </summary>
        </member>
        <member name="F:Loretta.Utilities.ObjectWriter.EncodingKind.Int32_5">
            <summary>
            The Int32 value 5
            </summary>
        </member>
        <member name="F:Loretta.Utilities.ObjectWriter.EncodingKind.Int32_6">
            <summary>
            The Int32 value 6
            </summary>
        </member>
        <member name="F:Loretta.Utilities.ObjectWriter.EncodingKind.Int32_7">
            <summary>
            The Int32 value 7
            </summary>
        </member>
        <member name="F:Loretta.Utilities.ObjectWriter.EncodingKind.Int32_8">
            <summary>
            The Int32 value 8
            </summary>
        </member>
        <member name="F:Loretta.Utilities.ObjectWriter.EncodingKind.Int32_9">
            <summary>
            The Int32 value 9
            </summary>
        </member>
        <member name="F:Loretta.Utilities.ObjectWriter.EncodingKind.Int32_10">
            <summary>
            The Int32 value 10
            </summary>
        </member>
        <member name="F:Loretta.Utilities.ObjectWriter.EncodingKind.Int64">
            <summary>
            An Int64 value encoded as 8 bytes
            </summary>
        </member>
        <member name="F:Loretta.Utilities.ObjectWriter.EncodingKind.UInt8">
            <summary>
            A UInt8 value encoded as 1 byte.
            </summary>
        </member>
        <member name="F:Loretta.Utilities.ObjectWriter.EncodingKind.UInt16">
            <summary>
            A UIn16 value encoded as 2 bytes.
            </summary>
        </member>
        <member name="F:Loretta.Utilities.ObjectWriter.EncodingKind.UInt32">
            <summary>
            A UInt32 value encoded as 4 bytes.
            </summary>
        </member>
        <member name="F:Loretta.Utilities.ObjectWriter.EncodingKind.UInt32_1Byte">
            <summary>
            A UInt32 value encoded as 1 byte.
            </summary>
        </member>
        <member name="F:Loretta.Utilities.ObjectWriter.EncodingKind.UInt32_2Bytes">
            <summary>
            A UInt32 value encoded as 2 bytes.
            </summary>
        </member>
        <member name="F:Loretta.Utilities.ObjectWriter.EncodingKind.UInt32_0">
            <summary>
            The UInt32 value 0
            </summary>
        </member>
        <member name="F:Loretta.Utilities.ObjectWriter.EncodingKind.UInt32_1">
            <summary>
            The UInt32 value 1
            </summary>
        </member>
        <member name="F:Loretta.Utilities.ObjectWriter.EncodingKind.UInt32_2">
            <summary>
            The UInt32 value 2
            </summary>
        </member>
        <member name="F:Loretta.Utilities.ObjectWriter.EncodingKind.UInt32_3">
            <summary>
            The UInt32 value 3
            </summary>
        </member>
        <member name="F:Loretta.Utilities.ObjectWriter.EncodingKind.UInt32_4">
            <summary>
            The UInt32 value 4
            </summary>
        </member>
        <member name="F:Loretta.Utilities.ObjectWriter.EncodingKind.UInt32_5">
            <summary>
            The UInt32 value 5
            </summary>
        </member>
        <member name="F:Loretta.Utilities.ObjectWriter.EncodingKind.UInt32_6">
            <summary>
            The UInt32 value 6
            </summary>
        </member>
        <member name="F:Loretta.Utilities.ObjectWriter.EncodingKind.UInt32_7">
            <summary>
            The UInt32 value 7
            </summary>
        </member>
        <member name="F:Loretta.Utilities.ObjectWriter.EncodingKind.UInt32_8">
            <summary>
            The UInt32 value 8
            </summary>
        </member>
        <member name="F:Loretta.Utilities.ObjectWriter.EncodingKind.UInt32_9">
            <summary>
            The UInt32 value 9
            </summary>
        </member>
        <member name="F:Loretta.Utilities.ObjectWriter.EncodingKind.UInt32_10">
            <summary>
            The UInt32 value 10
            </summary>
        </member>
        <member name="F:Loretta.Utilities.ObjectWriter.EncodingKind.UInt64">
            <summary>
            A UInt64 value encoded as 8 bytes.
            </summary>
        </member>
        <member name="F:Loretta.Utilities.ObjectWriter.EncodingKind.Float4">
            <summary>
            A float value encoded as 4 bytes.
            </summary>
        </member>
        <member name="F:Loretta.Utilities.ObjectWriter.EncodingKind.Float8">
            <summary>
            A double value encoded as 8 bytes.
            </summary>
        </member>
        <member name="F:Loretta.Utilities.ObjectWriter.EncodingKind.Decimal">
            <summary>
            A decimal value encoded as 12 bytes.
            </summary>
        </member>
        <member name="F:Loretta.Utilities.ObjectWriter.EncodingKind.DateTime">
            <summary>
            A DateTime value
            </summary>
        </member>
        <member name="F:Loretta.Utilities.ObjectWriter.EncodingKind.Array">
            <summary>
            An array with length encoded as compressed uint
            </summary>
        </member>
        <member name="F:Loretta.Utilities.ObjectWriter.EncodingKind.Array_0">
            <summary>
            An array with zero elements
            </summary>
        </member>
        <member name="F:Loretta.Utilities.ObjectWriter.EncodingKind.Array_1">
            <summary>
            An array with one element
            </summary>
        </member>
        <member name="F:Loretta.Utilities.ObjectWriter.EncodingKind.Array_2">
            <summary>
            An array with 2 elements
            </summary>
        </member>
        <member name="F:Loretta.Utilities.ObjectWriter.EncodingKind.Array_3">
            <summary>
            An array with 3 elements
            </summary>
        </member>
        <member name="F:Loretta.Utilities.ObjectWriter.EncodingKind.BooleanType">
            <summary>
            The boolean type
            </summary>
        </member>
        <member name="F:Loretta.Utilities.ObjectWriter.EncodingKind.StringType">
            <summary>
            The string type
            </summary>
        </member>
        <member name="F:Loretta.Utilities.ObjectWriter.EncodingKind.EncodingName">
            <summary>
            Encoding serialized as <see cref="P:System.Text.Encoding.WebName"/>.
            </summary>
        </member>
        <member name="T:System.Linq.EnumerableExtensions">
            <summary>
            Declare the following extension methods in System.Linq namespace to avoid accidental boxing of ImmutableArray{T} that implements IEnumerable{T}.
            The boxing would occur if the methods were defined in Roslyn.Utilities and the file calling these methods has <c>using Roslyn.Utilities</c>
            but not <c>using System.Linq</c>.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.InternalImplementationOnlyAttribute">
            <summary>
            This is a marker attribute that can be put on an interface to denote that only internal implementations
            of that interface should exist.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.IsExternalInit">
            <summary>
            Reserved to be used by the compiler for tracking metadata.
            This class should not be used by developers in source code.
            </summary>
        </member>
        <member name="T:System.Runtime.Versioning.OSPlatformAttribute">
            <summary>
            Base type for all platform-specific API attributes.
            </summary>
        </member>
        <member name="T:System.Runtime.Versioning.TargetPlatformAttribute">
            <summary>
            Records the platform that the project targeted.
            </summary>
        </member>
        <member name="T:System.Runtime.Versioning.SupportedOSPlatformAttribute">
             <summary>
             Records the operating system (and minimum version) that supports an API. Multiple attributes can be
             applied to indicate support on multiple operating systems.
             </summary>
             <remarks>
             <para>Callers can apply a <see cref="T:System.Runtime.Versioning.SupportedOSPlatformAttribute" />
             or use guards to prevent calls to APIs on unsupported operating systems.</para>
            
             <para>A given platform should only be specified once.</para>
             </remarks>
        </member>
        <member name="T:System.Runtime.Versioning.UnsupportedOSPlatformAttribute">
            <summary>
            Marks APIs that were removed in a given operating system version.
            </summary>
            <remarks>
            Primarily used by OS bindings to indicate APIs that are only available in
            earlier versions.
            </remarks>
        </member>
        <member name="T:System.Index">
            <summary>Represent a type can be used to index a collection either from the start or the end.</summary>
            <remarks>
            Index is used by the C# compiler to support the new index syntax
            <code>
            int[] someArray = new int[5] { 1, 2, 3, 4, 5 } ;
            int lastElement = someArray[^1]; // lastElement = 5
            </code>
            </remarks>
        </member>
        <member name="M:System.Index.#ctor(System.Int32,System.Boolean)">
            <summary>Construct an Index using a value and indicating if the index is from the start or from the end.</summary>
            <param name="value">The index value. it has to be zero or positive number.</param>
            <param name="fromEnd">Indicating if the index is from the start or from the end.</param>
            <remarks>
            If the Index constructed from the end, index value 1 means pointing at the last element and index value 0 means pointing at beyond last element.
            </remarks>
        </member>
        <member name="P:System.Index.Start">
            <summary>Create an Index pointing at first element.</summary>
        </member>
        <member name="P:System.Index.End">
            <summary>Create an Index pointing at beyond last element.</summary>
        </member>
        <member name="M:System.Index.FromStart(System.Int32)">
            <summary>Create an Index from the start at the position indicated by the value.</summary>
            <param name="value">The index value from the start.</param>
        </member>
        <member name="M:System.Index.FromEnd(System.Int32)">
            <summary>Create an Index from the end at the position indicated by the value.</summary>
            <param name="value">The index value from the end.</param>
        </member>
        <member name="P:System.Index.Value">
            <summary>Returns the index value.</summary>
        </member>
        <member name="P:System.Index.IsFromEnd">
            <summary>Indicates whether the index is from the start or the end.</summary>
        </member>
        <member name="M:System.Index.GetOffset(System.Int32)">
            <summary>Calculate the offset from the start using the giving collection length.</summary>
            <param name="length">The length of the collection that the Index will be used with. length has to be a positive value</param>
            <remarks>
            For performance reason, we don't validate the input length parameter and the returned offset value against negative values.
            we don't validate either the returned offset is greater than the input length.
            It is expected Index will be used with collections which always have non negative length/count. If the returned offset is negative and
            then used to index a collection will get out of range exception which will be same affect as the validation.
            </remarks>
        </member>
        <member name="M:System.Index.Equals(System.Object)">
            <summary>Indicates whether the current Index object is equal to another object of the same type.</summary>
            <param name="value">An object to compare with this object</param>
        </member>
        <member name="M:System.Index.Equals(System.Index)">
            <summary>Indicates whether the current Index object is equal to another Index object.</summary>
            <param name="other">An object to compare with this object</param>
        </member>
        <member name="M:System.Index.GetHashCode">
            <summary>Returns the hash code for this instance.</summary>
        </member>
        <member name="M:System.Index.op_Implicit(System.Int32)~System.Index">
            <summary>Converts integer number to an Index.</summary>
        </member>
        <member name="M:System.Index.ToString">
            <summary>Converts the value of the current Index object to its equivalent string representation.</summary>
        </member>
        <member name="T:System.Range">
            <summary>Represent a range has start and end indexes.</summary>
            <remarks>
            Range is used by the C# compiler to support the range syntax.
            <code>
            int[] someArray = new int[5] { 1, 2, 3, 4, 5 };
            int[] subArray1 = someArray[0..2]; // { 1, 2 }
            int[] subArray2 = someArray[1..^0]; // { 2, 3, 4, 5 }
            </code>
            </remarks>
        </member>
        <member name="P:System.Range.Start">
            <summary>Represent the inclusive start index of the Range.</summary>
        </member>
        <member name="P:System.Range.End">
            <summary>Represent the exclusive end index of the Range.</summary>
        </member>
        <member name="M:System.Range.#ctor(System.Index,System.Index)">
            <summary>Construct a Range object using the start and end indexes.</summary>
            <param name="start">Represent the inclusive start index of the range.</param>
            <param name="end">Represent the exclusive end index of the range.</param>
        </member>
        <member name="M:System.Range.Equals(System.Object)">
            <summary>Indicates whether the current Range object is equal to another object of the same type.</summary>
            <param name="value">An object to compare with this object</param>
        </member>
        <member name="M:System.Range.Equals(System.Range)">
            <summary>Indicates whether the current Range object is equal to another Range object.</summary>
            <param name="other">An object to compare with this object</param>
        </member>
        <member name="M:System.Range.GetHashCode">
            <summary>Returns the hash code for this instance.</summary>
        </member>
        <member name="M:System.Range.ToString">
            <summary>Converts the value of the current Range object to its equivalent string representation.</summary>
        </member>
        <member name="M:System.Range.StartAt(System.Index)">
            <summary>Create a Range object starting from start index to the end of the collection.</summary>
        </member>
        <member name="M:System.Range.EndAt(System.Index)">
            <summary>Create a Range object starting from first element in the collection to the end Index.</summary>
        </member>
        <member name="P:System.Range.All">
            <summary>Create a Range object starting from first element to the end.</summary>
        </member>
        <member name="M:System.Range.GetOffsetAndLength(System.Int32)">
            <summary>Calculate the start offset and length of range object using a collection length.</summary>
            <param name="length">The length of the collection that the range will be used with. length has to be a positive value.</param>
            <remarks>
            For performance reason, we don't validate the input length parameter against negative values.
            It is expected Range will be used with collections which always have non negative length/count.
            We validate the range is inside the length scope though.
            </remarks>
        </member>
    </members>
</doc>
