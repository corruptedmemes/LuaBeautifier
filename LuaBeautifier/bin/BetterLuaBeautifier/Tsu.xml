<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Tsu</name>
    </assembly>
    <members>
        <member name="T:Tsu.Buffers.BitVectorHelpers">
            <summary>
            A class with helpers to deal with Spans and Arrays being used as bit vectors.
            </summary>
            <summary>
            A class with helpers to deal with Spans and Arrays being used as bit vectors.
            </summary>
        </member>
        <member name="F:Tsu.Buffers.BitVectorHelpers.ByteShiftAmount">
            <summary>
            The amount we shift by to convert to/from bits in a <see cref="T:System.Byte"/>-backed bit vector.
            </summary>
        </member>
        <member name="F:Tsu.Buffers.BitVectorHelpers.ByteRemainderMask">
            <summary>
            The bitmask we bitwise and with to get the remainder bit count in a <see cref="T:System.Byte"/>-backed bit vector.
            </summary>
        </member>
        <member name="M:Tsu.Buffers.BitVectorHelpers.GetByteVectorIndexAndOffset(System.Int32,System.Int32@)">
            <summary>
            Gets the index and the offset of the provided bit on a <see cref="T:System.Byte"/>-backed bit vector.
            </summary>
            <param name="bitIndex"></param>
            <param name="offset"></param>
            <returns></returns>
        </member>
        <member name="M:Tsu.Buffers.BitVectorHelpers.GetByteVectorBitValue(System.Collections.Generic.IReadOnlyList{System.Byte},System.Int32)">
            <summary>
            Gets the value of a bit in a <see cref="T:System.Byte"/>-backed bit vector.
            </summary>
            <param name="bytes"></param>
            <param name="bitIndex"></param>
            <returns></returns>
        </member>
        <member name="M:Tsu.Buffers.BitVectorHelpers.SetByteVectorBitValue(System.Collections.Generic.IList{System.Byte},System.Int32,System.Boolean)">
            <summary>
            Sets the value of a bit in a <see cref="T:System.Byte"/>-backed bit vector.
            </summary>
            <param name="bytes"></param>
            <param name="bitIndex"></param>
            <param name="value"></param>
        </member>
        <member name="F:Tsu.Buffers.BitVectorHelpers.UInt16ShiftAmount">
            <summary>
            The amount we shift by to convert to/from bits in a <see cref="T:System.UInt16"/>-backed bit vector.
            </summary>
        </member>
        <member name="F:Tsu.Buffers.BitVectorHelpers.UInt16RemainderMask">
            <summary>
            The bitmask we bitwise and with to get the remainder bit count in a <see cref="T:System.UInt16"/>-backed bit vector.
            </summary>
        </member>
        <member name="M:Tsu.Buffers.BitVectorHelpers.GetUInt16VectorIndexAndOffset(System.Int32,System.Int32@)">
            <summary>
            Gets the index and the offset of the provided bit on a <see cref="T:System.UInt16"/>-backed bit vector.
            </summary>
            <param name="bitIndex"></param>
            <param name="offset"></param>
            <returns></returns>
        </member>
        <member name="M:Tsu.Buffers.BitVectorHelpers.GetUInt16VectorBitValue(System.Collections.Generic.IReadOnlyList{System.UInt16},System.Int32)">
            <summary>
            Gets the value of a bit in a <see cref="T:System.UInt16"/>-backed bit vector.
            </summary>
            <param name="uint16s"></param>
            <param name="bitIndex"></param>
            <returns></returns>
        </member>
        <member name="M:Tsu.Buffers.BitVectorHelpers.SetUInt16VectorBitValue(System.Collections.Generic.IList{System.UInt16},System.Int32,System.Boolean)">
            <summary>
            Sets the value of a bit in a <see cref="T:System.UInt16"/>-backed bit vector.
            </summary>
            <param name="uint16s"></param>
            <param name="bitIndex"></param>
            <param name="value"></param>
        </member>
        <member name="F:Tsu.Buffers.BitVectorHelpers.UInt32ShiftAmount">
            <summary>
            The amount we shift by to convert to/from bits in a <see cref="T:System.UInt32"/>-backed bit vector.
            </summary>
        </member>
        <member name="F:Tsu.Buffers.BitVectorHelpers.UInt32RemainderMask">
            <summary>
            The bitmask we bitwise and with to get the remainder bit count in a <see cref="T:System.UInt32"/>-backed bit vector.
            </summary>
        </member>
        <member name="M:Tsu.Buffers.BitVectorHelpers.GetUInt32VectorIndexAndOffset(System.Int32,System.Int32@)">
            <summary>
            Gets the index and the offset of the provided bit on a <see cref="T:System.UInt32"/>-backed bit vector.
            </summary>
            <param name="bitIndex"></param>
            <param name="offset"></param>
            <returns></returns>
        </member>
        <member name="M:Tsu.Buffers.BitVectorHelpers.GetUInt32VectorBitValue(System.Collections.Generic.IReadOnlyList{System.UInt32},System.Int32)">
            <summary>
            Gets the value of a bit in a <see cref="T:System.UInt32"/>-backed bit vector.
            </summary>
            <param name="uint32s"></param>
            <param name="bitIndex"></param>
            <returns></returns>
        </member>
        <member name="M:Tsu.Buffers.BitVectorHelpers.SetUInt32VectorBitValue(System.Collections.Generic.IList{System.UInt32},System.Int32,System.Boolean)">
            <summary>
            Sets the value of a bit in a <see cref="T:System.UInt32"/>-backed bit vector.
            </summary>
            <param name="uint32s"></param>
            <param name="bitIndex"></param>
            <param name="value"></param>
        </member>
        <member name="F:Tsu.Buffers.BitVectorHelpers.UInt64ShiftAmount">
            <summary>
            The amount we shift by to convert to/from bits in a <see cref="T:System.UInt64"/>-backed bit vector.
            </summary>
        </member>
        <member name="F:Tsu.Buffers.BitVectorHelpers.UInt64RemainderMask">
            <summary>
            The bitmask we bitwise and with to get the remainder bit count in a <see cref="T:System.UInt64"/>-backed bit vector.
            </summary>
        </member>
        <member name="M:Tsu.Buffers.BitVectorHelpers.GetUInt64VectorIndexAndOffset(System.Int32,System.Int32@)">
            <summary>
            Gets the index and the offset of the provided bit on a <see cref="T:System.UInt64"/>-backed bit vector.
            </summary>
            <param name="bitIndex"></param>
            <param name="offset"></param>
            <returns></returns>
        </member>
        <member name="M:Tsu.Buffers.BitVectorHelpers.GetUInt64VectorBitValue(System.Collections.Generic.IReadOnlyList{System.UInt64},System.Int32)">
            <summary>
            Gets the value of a bit in a <see cref="T:System.UInt64"/>-backed bit vector.
            </summary>
            <param name="uint64s"></param>
            <param name="bitIndex"></param>
            <returns></returns>
        </member>
        <member name="M:Tsu.Buffers.BitVectorHelpers.SetUInt64VectorBitValue(System.Collections.Generic.IList{System.UInt64},System.Int32,System.Boolean)">
            <summary>
            Sets the value of a bit in a <see cref="T:System.UInt64"/>-backed bit vector.
            </summary>
            <param name="uint64s"></param>
            <param name="bitIndex"></param>
            <param name="value"></param>
        </member>
        <member name="T:Tsu.Buffers.VariableLengthBitVector">
            <summary>
            A variable length bit vector
            </summary>
        </member>
        <member name="F:Tsu.Buffers.VariableLengthBitVector.containers">
            <summary>
            The containers that back this bit vector
            </summary>
        </member>
        <member name="P:Tsu.Buffers.VariableLengthBitVector.Length">
            <summary>
            The length of the inner array of this bit vector
            </summary>
        </member>
        <member name="P:Tsu.Buffers.VariableLengthBitVector.Bits">
            <summary>
            The amount of bits that this bit vector contains
            </summary>
        </member>
        <member name="M:Tsu.Buffers.VariableLengthBitVector.#ctor">
            <summary>
            Initializes this <see cref="T:Tsu.Buffers.VariableLengthBitVector"/>
            </summary>
        </member>
        <member name="M:Tsu.Buffers.VariableLengthBitVector.#ctor(System.Int32)">
            <summary>
            Initializes this vector with the required amount of bits rounded up
            </summary>
            <param name="bits">The amount of bits required</param>
        </member>
        <member name="M:Tsu.Buffers.VariableLengthBitVector.#ctor(Tsu.Buffers.VariableLengthBitVector)">
            <summary>
            Initializes this vector with the bits of another vector
            </summary>
            <param name="bitVector">The bit vector to copy from</param>
        </member>
        <member name="M:Tsu.Buffers.VariableLengthBitVector.EnsureBitContainer(System.Int32)">
            <summary>
            Ensures we have the required amount of containers to be able to access the provided
            <paramref name="index"/>
            </summary>
            <param name="index">The index being accessed</param>
        </member>
        <member name="M:Tsu.Buffers.VariableLengthBitVector.Clear">
            <summary>
            Clears this variable length bit vector
            </summary>
        </member>
        <member name="P:Tsu.Buffers.VariableLengthBitVector.Item(System.Int32)">
            <summary>
            Accesses a bit in this vector.
            </summary>
            <param name="bitIndex">The 0-based bit index</param>
            <returns></returns>
        </member>
        <member name="M:Tsu.Buffers.VariableLengthBitVector.Equals(Tsu.Buffers.VariableLengthBitVector)">
            <inheritdoc/>
        </member>
        <member name="M:Tsu.Buffers.VariableLengthBitVector.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Tsu.Buffers.VariableLengthBitVector.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Tsu.Buffers.VariableLengthBitVector.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Tsu.Buffers.VariableLengthBitVector.op_Equality(Tsu.Buffers.VariableLengthBitVector,Tsu.Buffers.VariableLengthBitVector)">
            <inheritdoc/>
        </member>
        <member name="M:Tsu.Buffers.VariableLengthBitVector.op_Inequality(Tsu.Buffers.VariableLengthBitVector,Tsu.Buffers.VariableLengthBitVector)">
            <inheritdoc/>
        </member>
        <member name="T:Tsu.IO.NullStream">
            <summary>
            This stream simulates piping data to <pre>/dev/null</pre>
            </summary>
        </member>
        <member name="M:Tsu.IO.NullStream.#ctor">
            <summary>
            Does nothing
            </summary>
        </member>
        <member name="P:Tsu.IO.NullStream.CanRead">
            <summary>
            Does nothing
            </summary>
        </member>
        <member name="P:Tsu.IO.NullStream.CanSeek">
            <summary>
            Does nothing
            </summary>
        </member>
        <member name="P:Tsu.IO.NullStream.CanTimeout">
            <summary>
            Does nothing
            </summary>
        </member>
        <member name="P:Tsu.IO.NullStream.CanWrite">
            <summary>
            Does nothing
            </summary>
        </member>
        <member name="P:Tsu.IO.NullStream.Length">
            <summary>
            Does nothing
            </summary>
        </member>
        <member name="P:Tsu.IO.NullStream.Position">
            <summary>
            Does nothing
            </summary>
        </member>
        <member name="M:Tsu.IO.NullStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Does nothing
            </summary>
            <param name="offset"></param>
            <param name="origin"></param>
            <returns></returns>
        </member>
        <member name="M:Tsu.IO.NullStream.SetLength(System.Int64)">
            <summary>
            Does nothing
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Tsu.IO.NullStream.Close">
            <summary>
            Does nothing
            </summary>
        </member>
        <member name="M:Tsu.IO.NullStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Does nothing
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:Tsu.IO.NullStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Does nothing
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:Tsu.IO.NullStream.ReadByte">
            <summary>
            Does nothing
            </summary>
            <returns></returns>
        </member>
        <member name="M:Tsu.IO.NullStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
            <summary>
            Does nothing
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <param name="callback"></param>
            <param name="state"></param>
            <returns></returns>
        </member>
        <member name="M:Tsu.IO.NullStream.EndRead(System.IAsyncResult)">
            <summary>
            Does nothing
            </summary>
            <param name="asyncResult"></param>
            <returns></returns>
        </member>
        <member name="M:Tsu.IO.NullStream.CopyToAsync(System.IO.Stream,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Does nothing
            </summary>
            <param name="destination"></param>
            <param name="bufferSize"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:Tsu.IO.NullStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
            <summary>
            Does nothing
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <param name="callback"></param>
            <param name="state"></param>
            <returns></returns>
        </member>
        <member name="M:Tsu.IO.NullStream.EndWrite(System.IAsyncResult)">
            <summary>
            Does nothing
            </summary>
            <param name="asyncResult"></param>
        </member>
        <member name="M:Tsu.IO.NullStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Does nothing
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="count"></param>
        </member>
        <member name="M:Tsu.IO.NullStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Does nothing
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:Tsu.IO.NullStream.WriteByte(System.Byte)">
            <summary>
            Does nothing
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Tsu.IO.NullStream.Flush">
            <summary>
            Does nothing
            </summary>
        </member>
        <member name="M:Tsu.IO.NullStream.FlushAsync(System.Threading.CancellationToken)">
            <summary>
            Does nothing
            </summary>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:Tsu.IO.NullStream.Equals(System.Object)">
            <summary>
            Defines whether this stream is equal to another object
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Tsu.IO.NullStream.GetHashCode">
            <summary>
            The default hash function
            </summary>
            <returns></returns>
        </member>
        <member name="M:Tsu.IO.NullStream.ToString">
            <summary>
            Prints the string representation of a <see cref="T:Tsu.IO.NullStream" />
            </summary>
            <returns></returns>
        </member>
        <member name="T:Tsu.Net.DownloadClientDownloadProgressChangedArgs">
            <summary>
            The arguments to the progress changed event
            </summary>
        </member>
        <member name="P:Tsu.Net.DownloadClientDownloadProgressChangedArgs.BytesReceived">
            <summary>
            The amount of bytes already downloaded
            </summary>
        </member>
        <member name="P:Tsu.Net.DownloadClientDownloadProgressChangedArgs.TotalBytes">
            <summary>
            The total amount of bytes to be downloaded
            </summary>
        </member>
        <member name="M:Tsu.Net.DownloadClientDownloadProgressChangedArgs.Equals(System.Object)">
            <summary>
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Tsu.Net.DownloadClientDownloadProgressChangedArgs.Equals(Tsu.Net.DownloadClientDownloadProgressChangedArgs)">
            <summary>
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:Tsu.Net.DownloadClientDownloadProgressChangedArgs.GetHashCode">
            <summary>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Tsu.Net.DownloadClientDownloadProgressChangedArgs.op_Equality(Tsu.Net.DownloadClientDownloadProgressChangedArgs,Tsu.Net.DownloadClientDownloadProgressChangedArgs)">
            <summary>
            </summary>
            <param name="args1"></param>
            <param name="args2"></param>
            <returns></returns>
        </member>
        <member name="M:Tsu.Net.DownloadClientDownloadProgressChangedArgs.op_Inequality(Tsu.Net.DownloadClientDownloadProgressChangedArgs,Tsu.Net.DownloadClientDownloadProgressChangedArgs)">
            <summary>
            </summary>
            <param name="args1"></param>
            <param name="args2"></param>
            <returns></returns>
        </member>
        <member name="T:Tsu.Net.DownloadClient">
            <summary>
            An experimental download client meant to be faster than <see cref="T:System.Net.WebClient"/>
            </summary>
        </member>
        <member name="P:Tsu.Net.DownloadClient.UserAgent">
            <summary>
            The user agent to use when downloading the file
            </summary>
        </member>
        <member name="M:Tsu.Net.DownloadClient.#ctor(System.String,System.Int32)">
            <summary>
            Creates a new <see cref="T:Tsu.Net.DownloadClient"/> that will obtain the file from <paramref
            name="url"/> with <paramref name="bufferSize"/> bytes at a time.
            </summary>
            <param name="url">The URL where to download the content from</param>
            <param name="bufferSize">
            The amount of bytes to use in the buffer (values larger than 85000 will end up in the
            large object heap)
            </param>
        </member>
        <member name="M:Tsu.Net.DownloadClient.#ctor(System.Uri,System.Int32)">
            <summary>
            Creates a new <see cref="T:Tsu.Net.DownloadClient"/> that will obtain the file from a <paramref
            name="uri"/> with <paramref name="bufferSize"/> bytes at a time.
            </summary>
            <param name="uri">The source URI</param>
            <param name="bufferSize">The size of the buffer</param>
        </member>
        <member name="E:Tsu.Net.DownloadClient.DownloadProgressChanged">
            <summary>
            Called when progress is made on the download
            </summary>
        </member>
        <member name="P:Tsu.Net.DownloadClient.IsWorking">
            <summary>
            Indicates whether this <see cref="T:Tsu.Net.DownloadClient"/> is downloading
            </summary>
        </member>
        <member name="M:Tsu.Net.DownloadClient.DownloadBytesAsync">
            <summary>
            Download the contents of <see cref="F:Tsu.Net.DownloadClient._url"/> and returns them as an array of bytes
            </summary>
            <returns></returns>
        </member>
        <member name="M:Tsu.Net.DownloadClient.DownloadStringAsync(System.Text.Encoding)">
            <summary>
            Downloads the contents of <see cref="F:Tsu.Net.DownloadClient._url"/> as a String with the possibility to provide
            an encoding to use to decode the bytes
            </summary>
            <param name="encoding">
            The encoding which to use when transforming from bytes to a string (Defaults to Default encoding)
            </param>
            <returns></returns>
        </member>
        <member name="M:Tsu.Net.DownloadClient.DownloadToFileAsync(System.String,System.Int32)">
            <summary>
            Downloads the resource on <see cref="F:Tsu.Net.DownloadClient._url"/> to <paramref name="path"/>
            </summary>
            <param name="path">The path where to save the file to</param>
            <param name="timeout"></param>
            <returns></returns>
        </member>
        <member name="M:Tsu.Net.DownloadClient.DownloadToStreamAsync(System.IO.Stream,System.Int32)">
            <summary>
            Downloads the resource from the provided URL and writes the contents of it as they are read.
            </summary>
            <param name="stream">The stream where to write to</param>
            <param name="timeout"></param>
            <returns></returns>
        </member>
        <member name="M:Tsu.Net.DownloadClient.GetResponseAsync">
            <summary>
            Returns a response from the URL
            </summary>
            <returns></returns>
        </member>
        <member name="T:Tsu.Numerics.Duration">
            <summary>
            An utility class to help manipulate time as ticks
            </summary>
        </member>
        <member name="F:Tsu.Numerics.Duration.TicksPerHour">
            <summary>
            The amount of tikcs in an hour
            </summary>
        </member>
        <member name="F:Tsu.Numerics.Duration.TicksPerMinute">
            <summary>
            The amount of ticks in a minute
            </summary>
        </member>
        <member name="F:Tsu.Numerics.Duration.TicksPerSecond">
            <summary>
            The amount of ticks in a second
            </summary>
        </member>
        <member name="F:Tsu.Numerics.Duration.TicksPerMillisecond">
            <summary>
            The amount of ticks in a millisecond
            </summary>
        </member>
        <member name="F:Tsu.Numerics.Duration.TicksPerMicrosecond">
            <summary>
            The amount of ticks in a microsecond
            </summary>
        </member>
        <member name="F:Tsu.Numerics.Duration.TicksPerNanosecond">
            <summary>
            The amount of ticks in a nanosecond
            </summary>
        </member>
        <member name="M:Tsu.Numerics.Duration.GetFormatPair(System.Int64,System.Double@,System.String@)">
            <summary>
            Scales the provided value down and gets the duration from the ticks.
            </summary>
            <param name="ticks">The tick count.</param>
            <param name="scaledDuration">The scaled down duration.</param>
            <param name="suffix">The suffix.</param>
        </member>
        <member name="M:Tsu.Numerics.Duration.Format(System.Int64,System.String)">
            <summary>
            Formats the amount of ticks provided into a human
            readable format.
            </summary>
            <param name="ticks"></param>
            <param name="format"></param>
            <returns></returns>
        </member>
        <member name="M:Tsu.Numerics.Duration.Format(System.Int64,System.IFormatProvider,System.String)">
            <summary>
            Formats the amount of ticks provided into a human
            readable format.
            </summary>
            <param name="ticks"></param>
            <param name="formatProvider"></param>
            <param name="format"></param>
            <returns></returns>
        </member>
        <member name="T:Tsu.Numerics.FileSize">
            <summary>
            An utility to deal with file sizes
            </summary>
        </member>
        <member name="F:Tsu.Numerics.FileSize._floatParseRegex">
            <summary>
            The regular expression used for parsing floating point file sizes. Accepts 0.0, 0.0B and 0.0KiB
            </summary>
        </member>
        <member name="F:Tsu.Numerics.FileSize._integerParseRegex">
            <summary>
            The regular expression used for parsing integer file sizes. Accepts 0, 0B and 0KiB
            </summary>
        </member>
        <member name="F:Tsu.Numerics.FileSize.KiB">
            <summary>
            A KiB (1024 B) in bytes.
            </summary>
        </member>
        <member name="F:Tsu.Numerics.FileSize.MiB">
            <summary>
            A MiB (1024 KiB) in bytes.
            </summary>
        </member>
        <member name="F:Tsu.Numerics.FileSize.GiB">
            <summary>
            A GiB (1024 MiB) in bytes.
            </summary>
        </member>
        <member name="F:Tsu.Numerics.FileSize.TiB">
            <summary>
            A TiB (1024 GiB) in bytes.
            </summary>
        </member>
        <member name="F:Tsu.Numerics.FileSize.PiB">
            <summary>
            A PiB (1024 TiB) in bytes.
            </summary>
        </member>
        <member name="F:Tsu.Numerics.FileSize.EiB">
            <summary>
            An EiB (1024 PiB) in bytes.
            </summary>
        </member>
        <member name="M:Tsu.Numerics.FileSize.GetFormatPair(System.Int64,System.Double@,System.String@)">
            <summary>
            Receives a file size (in bytes) and returns a tuple containing the scaled file size and
            the suffix to be used on display.
            </summary>
            <param name="size">The size (in bytes) to be formatted.</param>
            <param name="scaledSize">The scaled down size.</param>
            <param name="suffix">The suffix.</param>
        </member>
        <member name="M:Tsu.Numerics.FileSize.GetFormatPair(System.Double,System.Double@,System.String@)">
            <summary>
            <inheritdoc cref="M:Tsu.Numerics.FileSize.GetFormatPair(System.Int64,System.Double@,System.String@)" />
            </summary>
            <param name="size"><inheritdoc cref="M:Tsu.Numerics.FileSize.GetFormatPair(System.Int64,System.Double@,System.String@)" /></param>
            <param name="scaledSize"><inheritdoc cref="M:Tsu.Numerics.FileSize.GetFormatPair(System.Int64,System.Double@,System.String@)" /></param>
            <param name="suffix"><inheritdoc cref="M:Tsu.Numerics.FileSize.GetFormatPair(System.Int64,System.Double@,System.String@)" /></param>
        </member>
        <member name="M:Tsu.Numerics.FileSize.Format(System.Int64)">
            <summary>
            Formats the provided file size in a human readable format (in bibytes).
            </summary>
            <param name="size"><inheritdoc cref="M:Tsu.Numerics.FileSize.GetFormatPair(System.Int64,System.Double@,System.String@)" /></param>
            <returns>A formatted string containing the scaled file size and the size suffix.</returns>
        </member>
        <member name="M:Tsu.Numerics.FileSize.Format(System.Double)">
            <summary>
            <inheritdoc cref="M:Tsu.Numerics.FileSize.Format(System.Int64)" />
            </summary>
            <param name="size"><inheritdoc cref="M:Tsu.Numerics.FileSize.Format(System.Int64)" /></param>
            <returns><inheritdoc cref="M:Tsu.Numerics.FileSize.Format(System.Int64)" /></returns>
        </member>
        <member name="M:Tsu.Numerics.FileSize.Format(System.Int64,System.String)">
            <summary>
            <inheritdoc cref="M:Tsu.Numerics.FileSize.Format(System.Int64)" />
            </summary>
            <param name="size"><inheritdoc cref="M:Tsu.Numerics.FileSize.Format(System.Int64)" /></param>
            <param name="format">
            The format template. Must contain two format placeholders. Default value is: <c>{0:0.##} {1}</c>
            </param>
            <returns><inheritdoc cref="M:Tsu.Numerics.FileSize.Format(System.Int64)" /></returns>
        </member>
        <member name="M:Tsu.Numerics.FileSize.Format(System.Double,System.String)">
            <summary>
            <inheritdoc cref="M:Tsu.Numerics.FileSize.Format(System.Double)" />
            </summary>
            <param name="size"><inheritdoc cref="M:Tsu.Numerics.FileSize.Format(System.Double)" /></param>
            <param name="format"><inheritdoc cref="M:Tsu.Numerics.FileSize.Format(System.Int64,System.String)" /></param>
            <returns><inheritdoc cref="M:Tsu.Numerics.FileSize.Format(System.Double)" /></returns>
        </member>
        <member name="M:Tsu.Numerics.FileSize.Format(System.Int64,System.String,System.IFormatProvider)">
            <summary>
            <inheritdoc cref="M:Tsu.Numerics.FileSize.Format(System.Int64,System.String)" />
            </summary>
            <param name="size"><inheritdoc cref="M:Tsu.Numerics.FileSize.Format(System.Int64,System.String)" /></param>
            <param name="format"><inheritdoc cref="M:Tsu.Numerics.FileSize.Format(System.Int64,System.String)" /></param>
            <param name="provider">
            <inheritdoc cref="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object)" />
            </param>
            <returns><inheritdoc cref="M:Tsu.Numerics.FileSize.Format(System.Int64,System.String)" /></returns>
        </member>
        <member name="M:Tsu.Numerics.FileSize.Format(System.Double,System.String,System.IFormatProvider)">
            <summary>
            <inheritdoc cref="M:Tsu.Numerics.FileSize.Format(System.Double,System.String)" />
            </summary>
            <param name="size"><inheritdoc cref="M:Tsu.Numerics.FileSize.Format(System.Double,System.String)" /></param>
            <param name="format"><inheritdoc cref="M:Tsu.Numerics.FileSize.Format(System.Double,System.String)" /></param>
            <param name="provider">
            <inheritdoc cref="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object)" />
            </param>
            <returns><inheritdoc cref="M:Tsu.Numerics.FileSize.Format(System.Double,System.String)" /></returns>
        </member>
        <member name="M:Tsu.Numerics.FileSize.ParseDouble(System.String)">
            <summary>
            <inheritdoc cref="M:Tsu.Numerics.FileSize.TryParseDouble(System.String,System.Double@)" />
            </summary>
            <param name="input"><inheritdoc cref="M:Tsu.Numerics.FileSize.TryParseDouble(System.String,System.Double@)" /></param>
            <returns>
            <inheritdoc cref="M:Tsu.Numerics.FileSize.TryParseDouble(System.String,System.Double@)" path="/param[@name='bytes']" />
            </returns>
        </member>
        <member name="M:Tsu.Numerics.FileSize.ParseInteger(System.String)">
            <summary>
            <inheritdoc cref="M:Tsu.Numerics.FileSize.TryParseInteger(System.String,System.Int64@)" />
            </summary>
            <param name="input"><inheritdoc cref="M:Tsu.Numerics.FileSize.TryParseInteger(System.String,System.Int64@)" /></param>
            <returns>
            <inheritdoc cref="M:Tsu.Numerics.FileSize.TryParseInteger(System.String,System.Int64@)" path="/param[@name='bytes']" />
            </returns>
        </member>
        <member name="M:Tsu.Numerics.FileSize.TryParseDouble(System.String,System.Double@)">
            <summary>
            Parses a file size in the format <c>(0|.0|0.0) (|B|KiB|MiB|GiB|TiB|PiB|EiB)</c>. Might
            suffer from precision loss.
            </summary>
            <param name="input">The input string to be parsed.</param>
            <param name="bytes">The amount of bytes that the inputted string is equivalent to.</param>
            <returns>Whether the amount of bytes was parsed successfully</returns>
        </member>
        <member name="M:Tsu.Numerics.FileSize.TryParseInteger(System.String,System.Int64@)">
            <summary>
            Parses a file size in the format <c>0 (|B|KiB|MiB|GiB|TiB|PiB|EiB)</c>. Might suffer
            from precision loss although less likely than with the <see cref="T:System.Double" />-accepting counterpart.
            </summary>
            <param name="input">The input string to be parsed.</param>
            <param name="bytes">The amount of bytes that the inputted string is equivalent to.</param>
            <returns>Whether the amount of bytes was parsed successfully.</returns>
        </member>
        <member name="T:Tsu.Numerics.SI">
            <summary>
            A subset of the International System of Units Prefixes that only contains the prefixes that
            are powers of 1000
            </summary>
        </member>
        <member name="F:Tsu.Numerics.SI._floatParseRegex">
            <summary>
            The regular expression used for parsing floating point file sizes. Accepts 0.0, 0.0B and 0.0KiB
            </summary>
        </member>
        <member name="F:Tsu.Numerics.SI.Yotta">
            <summary>
            A yotta (Y)
            </summary>
        </member>
        <member name="F:Tsu.Numerics.SI.Zetta">
            <summary>
            A zetta (Z)
            </summary>
        </member>
        <member name="F:Tsu.Numerics.SI.Exa">
            <summary>
            An exa (E)
            </summary>
        </member>
        <member name="F:Tsu.Numerics.SI.Peta">
            <summary>
            A peta (P)
            </summary>
        </member>
        <member name="F:Tsu.Numerics.SI.Tera">
            <summary>
            A tera (T)
            </summary>
        </member>
        <member name="F:Tsu.Numerics.SI.Giga">
            <summary>
            A giga (G)
            </summary>
        </member>
        <member name="F:Tsu.Numerics.SI.Mega">
            <summary>
            A mega (M)
            </summary>
        </member>
        <member name="F:Tsu.Numerics.SI.Kilo">
            <summary>
            A kilo (k)
            </summary>
        </member>
        <member name="F:Tsu.Numerics.SI.Milli">
            <summary>
            A milli (m)
            </summary>
        </member>
        <member name="F:Tsu.Numerics.SI.Micro">
            <summary>
            A micro (μ)
            </summary>
        </member>
        <member name="F:Tsu.Numerics.SI.Nano">
            <summary>
            A nano (n)
            </summary>
        </member>
        <member name="F:Tsu.Numerics.SI.Pico">
            <summary>
            A pico (p)
            </summary>
        </member>
        <member name="F:Tsu.Numerics.SI.Femto">
            <summary>
            A femto (f)
            </summary>
        </member>
        <member name="F:Tsu.Numerics.SI.Atto">
            <summary>
            An atto (a)
            </summary>
        </member>
        <member name="F:Tsu.Numerics.SI.Zepto">
            <summary>
            A zepto (z)
            </summary>
        </member>
        <member name="F:Tsu.Numerics.SI.Yocto">
            <summary>
            A yocto (y)
            </summary>
        </member>
        <member name="M:Tsu.Numerics.SI.GetFormatPair(System.Double,System.Double@,System.String@)">
            <summary>
            Returns the pair of objects used in suffixing a SI number
            </summary>
            <param name="number">The number to scale down and get the suffix of.</param>
            <param name="scaledNumber">The scaled down number.</param>
            <param name="suffix">The suffix of the scaled down number.</param>
            <returns></returns>
        </member>
        <member name="M:Tsu.Numerics.SI.Format(System.Double)">
            <summary>
            Formats a <paramref name="number" /> with its SI prefix appended to it.
            </summary>
            <param name="number">The number to be formatted.</param>
            <returns>The formatted string with the reduced number and the SI prefix.</returns>
        </member>
        <member name="M:Tsu.Numerics.SI.Format(System.Double,System.String)">
            <summary>
            <inheritdoc cref="M:Tsu.Numerics.SI.Format(System.Double)" /> The default format is <c>{0:0.##} {1}</c>.
            </summary>
            <param name="number"><inheritdoc cref="M:Tsu.Numerics.SI.Format(System.Double)" /></param>
            <param name="format">
            The format string. Must contain two format placeholders. The default value is
            <c>{0:0.##} {1}</c>.
            </param>
            <returns><inheritdoc cref="M:Tsu.Numerics.SI.Format(System.Double)" /></returns>
        </member>
        <member name="M:Tsu.Numerics.SI.Format(System.Double,System.String,System.IFormatProvider)">
            <summary>
            <inheritdoc cref="M:Tsu.Numerics.SI.Format(System.Double,System.String)" />
            </summary>
            <param name="number"><inheritdoc cref="M:Tsu.Numerics.SI.Format(System.Double,System.String)" /></param>
            <param name="format"><inheritdoc cref="M:Tsu.Numerics.SI.Format(System.Double,System.String)" /></param>
            <param name="provider">
            <inheritdoc cref="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object)" />
            </param>
            <returns><inheritdoc cref="M:Tsu.Numerics.SI.Format(System.Double,System.String)" /></returns>
        </member>
        <member name="M:Tsu.Numerics.SI.TryParse(System.String,System.Double@)">
            <summary>
            Parses a SI number in the format <c>(0|.0|0.0)
            (y|z|a|f|p|n|u|μ|m||k|M|G|T|P|E|Z|Y)\w*</c>. Might suffer from precision loss.
            </summary>
            <param name="input">The input string.</param>
            <param name="number">The number that the input string represents.</param>
            <returns>The number that the input string represents.</returns>
        </member>
        <member name="M:Tsu.Numerics.SI.Parse(System.String)">
            <summary>
            <inheritdoc cref="M:Tsu.Numerics.SI.TryParse(System.String,System.Double@)" />
            </summary>
            <param name="input"><inheritdoc cref="M:Tsu.Numerics.SI.TryParse(System.String,System.Double@)" /></param>
            <returns>
            <inheritdoc cref="M:Tsu.Numerics.SI.TryParse(System.String,System.Double@)" path="/param[@name='number']" />
            </returns>
        </member>
        <member name="T:Tsu.Option">
            <summary>
            The class that contains the constructors for an Option.
            </summary>
        </member>
        <member name="M:Tsu.Option.Some``1(``0)">
            <summary>
            Constructs a Some option
            </summary>
            <typeparam name="T"></typeparam>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Tsu.Option.None``1">
            <summary>
            Constructs a None option
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="T:Tsu.Option`1">
            <summary>
            The Option type. It represents an optional value. Create one with <see cref="M:Tsu.Option.None``1"
            /> or <see cref="M:Tsu.Option.Some``1(``0)" />.
            </summary>
            <typeparam name="T">The type this option wraps.</typeparam>
        </member>
        <member name="F:Tsu.Option`1._some">
            <summary>
            The value stored by this option
            </summary>
        </member>
        <member name="P:Tsu.Option`1.IsSome">
            <summary>
            Whether the option contains a value.
            </summary>
        </member>
        <member name="P:Tsu.Option`1.IsNone">
            <summary>
            Whether the option doesn't contain a value.
            </summary>
        </member>
        <member name="P:Tsu.Option`1.Value">
            <summary>
            The value of the option
            </summary>
            <exception cref="T:System.InvalidOperationException">
            Thrown when the option doesn't have a value.
            </exception>
        </member>
        <member name="M:Tsu.Option`1.#ctor(`0)">
            <summary>
            Initializes an Option with a value
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Tsu.Option`1.UnwrapOr(`0)">
            <summary>
            Returns the wrapped value or the provided <paramref name="fallback" />.
            </summary>
            <param name="fallback">The value to be returned if this option doesn't contain a value.</param>
            <returns>The wrapped value or the <paramref name="fallback" />.</returns>
        </member>
        <member name="M:Tsu.Option`1.UnwrapOrElse(System.Func{`0})">
            <summary>
            Returns the wrapped value or the result of the provided delegate.
            </summary>
            <param name="func">The delegate to execute in case the this is a None.</param>
            <returns>The wrapped value or the result of invoking <paramref name="func" />.</returns>
        </member>
        <member name="M:Tsu.Option`1.Map``1(System.Func{`0,``0})">
            <summary>
            Converts an Option of one type to another by using the provided transformation function
            ( <paramref name="func" />). If the current object doesn't have a value, a None for the
            result type is returned instead.
            </summary>
            <typeparam name="TResult"></typeparam>
            <param name="func"></param>
            <returns></returns>
        </member>
        <member name="M:Tsu.Option`1.MapOr``1(``0,System.Func{`0,``0})">
            <summary>
            Converts an Option of one type to another by using the provided transformation function
            ( <paramref name="func" />). If the current object doesn't have a value, a Some with the
            <paramref name="fallback" /> value is returned instead.
            </summary>
            <typeparam name="TResult"></typeparam>
            <param name="fallback"></param>
            <param name="func"></param>
            <returns></returns>
        </member>
        <member name="M:Tsu.Option`1.MapOrElse``1(System.Func{``0},System.Func{`0,``0})">
            <summary>
            Converts an Option of one type to another by using the provided transformation function
            ( <paramref name="func" />). If the current object doesn't have a value, a Some with the
            result of invoking the <paramref name="fallback" /> function is returned instead.
            </summary>
            <typeparam name="TResult"></typeparam>
            <param name="fallback"></param>
            <param name="func"></param>
            <returns></returns>
        </member>
        <member name="M:Tsu.Option`1.And``1(Tsu.Option{``0})">
            <summary>
            Returns none if this option is none otherwise returns <paramref name="other" />
            </summary>
            <typeparam name="TOther">The wrapped type of the other option.</typeparam>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:Tsu.Option`1.AndThen``1(System.Func{`0,Tsu.Option{``0}})">
            <summary>
            Returns None if this Option is None, otherwise returns the result of invoking the
            provided function with the value.
            </summary>
            <typeparam name="TResult"></typeparam>
            <param name="func"></param>
            <returns></returns>
        </member>
        <member name="M:Tsu.Option`1.Filter(System.Func{`0,System.Boolean})">
            <summary>
            Returns None if this option is None or the predicate fails. If it passes then it returns
            this option.
            </summary>
            <param name="filter"></param>
            <returns></returns>
        </member>
        <member name="M:Tsu.Option`1.Or(Tsu.Option{`0})">
            <summary>
            Returns this option if it has a value otherwise it returns <paramref name="other" />.
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:Tsu.Option`1.OrElse(System.Func{Tsu.Option{`0}})">
            <summary>
            Returns this option if it has a value otherwise returns the result of invoking the
            provided <paramref name="func" />.
            </summary>
            <param name="func"></param>
            <returns></returns>
        </member>
        <member name="M:Tsu.Option`1.Xor(Tsu.Option{`0})">
            <summary>
            Return some if either this option or <paramref name="other" /> is Some, otherwise
            returns None.
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:Tsu.Option`1.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Tsu.Option`1.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Tsu.Option`1.Equals(Tsu.Option{`0})">
            <inheritdoc />
        </member>
        <member name="M:Tsu.Option`1.Equals(`0)">
            <summary>
            Indicates whether this object contains a value and that value is equal to another value
            of the same type.
            </summary>
            <param name="other">An object to compare with this object.</param>
            <returns>
            <see langword="true" /> if the current object contains a value and that value is equal
            to the <paramref name="other" /> parameter; otherwise, <see langword="false" />.
            </returns>
        </member>
        <member name="M:Tsu.Option`1.op_Equality(Tsu.Option{`0},Tsu.Option{`0})">
            <summary>
            Checks whether the left Option is equal to the right Option.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns>
            <see langword="true" /> if both options don't have a value or both have a value and the
            value is the same for both; otherwise, <see langword="false" />.
            </returns>
        </member>
        <member name="M:Tsu.Option`1.op_Inequality(Tsu.Option{`0},Tsu.Option{`0})">
            <summary>
            Checks whether the left Option is not equal to the right Option.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns>
            <see langword="false" /> if both options don't have a value or both have a value and the
            value is the same for both; otherwise, <see langword="true" />.
            </returns>
        </member>
        <member name="M:Tsu.Option`1.op_Equality(`0,Tsu.Option{`0})">
            <summary>
            Checks whether the left value is equal to the right Option.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns>
            <see langword="true" /> if the option contains a value and that value is equal to
            <paramref name="left" />; otherwise, <see langword="false" />.
            </returns>
        </member>
        <member name="M:Tsu.Option`1.op_Inequality(`0,Tsu.Option{`0})">
            <summary>
            Checks whether the left value is not equal to the right Option.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns>
            <see langword="false" /> if the option contains a value and that value is equal to
            <paramref name="left" />; otherwise, <see langword="true" />.
            </returns>
        </member>
        <member name="M:Tsu.Option`1.op_Equality(Tsu.Option{`0},`0)">
            <summary>
            Checks whether the left Option is equal to the right Option.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns>
            <see langword="true" /> if the option contains a value and that value is equal to
            <paramref name="right" />; otherwise, <see langword="false" />.
            </returns>
        </member>
        <member name="M:Tsu.Option`1.op_Inequality(Tsu.Option{`0},`0)">
            <summary>
            Checks whether the left Option is not equal to the right Option.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns>
            <see langword="false" /> if the option contains a value and that value is equal to
            <paramref name="right" />; otherwise, <see langword="true" />.
            </returns>
        </member>
        <member name="M:Tsu.Option`1.op_Implicit(`0)~Tsu.Option{`0}">
            <summary>
            Converts a value to a <see cref="M:Tsu.Option.Some``1(``0)" /> option.
            </summary>
            <param name="value">The value to be wrapped.</param>
        </member>
        <member name="T:Tsu.OptionExtensions">
            <summary>
            Extension methods that can't be implemented directly in <see cref="T:Tsu.Option`1" />.
            </summary>
        </member>
        <member name="M:Tsu.OptionExtensions.Flatten``1(Tsu.Option{Tsu.Option{``0}})">
            <summary>
            Flattens a nested <see cref="T:Tsu.Option`1" />.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="self"></param>
            <returns></returns>
        </member>
        <member name="M:Tsu.OptionExtensions.Transpose``2(Tsu.Option{Tsu.Result{``0,``1}})">
            <summary>
            Transposes an Option of a Result into a Result of an Option.
            </summary>
            <remarks>
            The mapping rules are the same as rust:
            <list type="bullet">
            <item>None → Ok(None)</item>
            <item>Some(Ok(x)) → Ok(Some(x))</item>
            <item>Some(Err(x)) → Err(Some(x))</item>
            </list>
            </remarks>
            <typeparam name="TOk"></typeparam>
            <typeparam name="TErr"></typeparam>
            <param name="self"></param>
            <returns></returns>
        </member>
        <member name="T:Tsu.Result">
            <summary>
            The class with the factory methods for the result
            </summary>
        </member>
        <member name="M:Tsu.Result.Ok``2(``0)">
            <summary>
            Creates a successful result
            </summary>
            <typeparam name="TOk"></typeparam>
            <typeparam name="TErr"></typeparam>
            <param name="ok"></param>
            <returns></returns>
        </member>
        <member name="M:Tsu.Result.Err``2(``1)">
            <summary>
            Creates an unsuccessful result
            </summary>
            <typeparam name="TOk"></typeparam>
            <typeparam name="TErr"></typeparam>
            <param name="error"></param>
            <returns></returns>
        </member>
        <member name="T:Tsu.Result`2">
            <summary>
            A result type
            </summary>
            <typeparam name="TOk"></typeparam>
            <typeparam name="TErr"></typeparam>
        </member>
        <member name="P:Tsu.Result`2.IsOk">
            <summary>
            Whether this result is Ok.
            </summary>
        </member>
        <member name="P:Tsu.Result`2.IsErr">
            <summary>
            Whether this result is an Error.
            </summary>
        </member>
        <member name="P:Tsu.Result`2.Ok">
            <summary>
            The result of the operation if it was successful.
            </summary>
        </member>
        <member name="P:Tsu.Result`2.Err">
            <summary>
            The error of the operation if it errored.
            </summary>
        </member>
        <member name="M:Tsu.Result`2.Contains``1(``0)">
            <summary>
            Returns <see langword="true" /> if this is an Ok result and the contained value is equal
            to the provided <paramref name="value" />.
            </summary>
            <typeparam name="TOther"></typeparam>
            <param name="value">
            The value to be compared to the containing value if it's an Ok result.
            </param>
            <returns></returns>
        </member>
        <member name="M:Tsu.Result`2.ContainsErr``1(``0)">
            <summary>
            Returns <see langword="true" /> if this is an Err result and the contained Err value is
            equal to the provided <paramref name="value" />.
            </summary>
            <typeparam name="TOther"></typeparam>
            <param name="value">
            The value to be compared to the containing Err value if it's an Err result.
            </param>
            <returns></returns>
        </member>
        <member name="M:Tsu.Result`2.Map``1(System.Func{`0,``0})">
            <summary>
            Maps a <c>Result&lt; <typeparamref name="TOk" />, <typeparamref name="TErr" />&gt;</c>
            to <c>Result&lt; <typeparamref name="TMappedOk" />, <typeparamref name="TErr" />&gt;</c>
            by invoking the provided <paramref name="op" /> on the wrapped Ok value (if any),
            leaving Err untouched.
            </summary>
            <typeparam name="TMappedOk">
            The type that the contained value (if any) will be mapped to.
            </typeparam>
            <param name="op">The function that maps the result if this Result contains one.</param>
            <returns>A Result with the mapped result if it contains one. Returns Err otherwise.</returns>
        </member>
        <member name="M:Tsu.Result`2.MapOr``1(``0,System.Func{`0,``0})">
            <summary>
            Maps a <c>Result&lt; <typeparamref name="TOk" />, <typeparamref name="TErr" />&gt;</c>
            to <c><typeparamref name="TMappedOk" /></c> by invoking the provided <paramref name="op"
            /> on the wrapped Ok value or returns the provided <paramref name="fallback" /> value if
            the value contained is an Err.
            </summary>
            <typeparam name="TMappedOk"></typeparam>
            <param name="fallback"></param>
            <param name="op"></param>
            <returns></returns>
        </member>
        <member name="M:Tsu.Result`2.MapOrElse``1(System.Func{``0},System.Func{`0,``0})">
            <summary>
            Maps a <c>Result&lt; <typeparamref name="TOk" />, <typeparamref name="TErr" />&gt;</c>
            to <c><typeparamref name="TMappedOk" /></c> by invoking the provided <paramref name="op"
            /> on the wrapped Ok value or returns the result of invoking the <paramref
            name="fallbackFunc" /> function if the value contained is an Err.
            </summary>
            <typeparam name="TMappedOk"></typeparam>
            <param name="fallbackFunc">
            The fallback function to be called if this Result doesn't contain a value.
            </param>
            <param name="op">The function to call with the value contained by this Result (if any).</param>
            <returns></returns>
        </member>
        <member name="M:Tsu.Result`2.MapErr``1(System.Func{`1,``0})">
            <summary>
            Maps a <c>Result&lt; <typeparamref name="TOk" />, <typeparamref name="TErr" />&gt;</c>
            into a <c>Result&lt; <typeparamref name="TOk" />, <typeparamref name="TMappedErr"
            />&gt;</c> by applying the provided <paramref name="op" /> on the error (if any).
            </summary>
            <typeparam name="TMappedErr"></typeparam>
            <param name="op"></param>
            <returns></returns>
        </member>
        <member name="M:Tsu.Result`2.And``1(Tsu.Result{``0,`1})">
            <summary>
            Returns <paramref name="res" /> if this result is Ok ( <see cref="P:Tsu.Result`2.IsOk" />). Otherwise
            returns an Err containing the error in this result.
            </summary>
            <typeparam name="TOtherOk"></typeparam>
            <param name="res">The result to be retured if this is an Ok result.</param>
            <returns></returns>
        </member>
        <member name="M:Tsu.Result`2.AndThen``1(System.Func{`0,Tsu.Result{``0,`1}})">
            <summary>
            Returns the result of invoking <paramref name="op" /> with this ok value if this result
            is Ok. Otherwise returns an Err containing th error in this result.
            </summary>
            <typeparam name="TMappedOk"></typeparam>
            <param name="op">
            The delegate to be invoked with the Ok value of this result if it's an Ok result.
            </param>
            <returns></returns>
        </member>
        <member name="M:Tsu.Result`2.Or``1(Tsu.Result{`0,``0})">
            <summary>
            Returns this result if it's an Ok result. Otherwies returns <paramref name="res" />.
            </summary>
            <typeparam name="TOtherErr"></typeparam>
            <param name="res">The result to be returned if this is an Err result.</param>
            <returns></returns>
        </member>
        <member name="M:Tsu.Result`2.OrThen``1(System.Func{`1,Tsu.Result{`0,``0}})">
            <summary>
            Returns this result if it's an Ok result. Otherwise returns the result of invoking
            <paramref name="op" /> with the Err value of this result if this is an Err result.
            </summary>
            <typeparam name="TMappedErr"></typeparam>
            <param name="op">
            The function to be invoked with the Err value of this result if it's an Err result.
            </param>
            <returns></returns>
        </member>
        <member name="M:Tsu.Result`2.UnwrapOr(`0)">
            <summary>
            Returns the Ok value of this result if it's an Ok result. Otherwise returns the
            <paramref name="fallback" /> result.
            </summary>
            <param name="fallback">The result to be retured if this is an Err result.</param>
            <returns></returns>
        </member>
        <member name="M:Tsu.Result`2.UnwrapOrElse(System.Func{`0})">
            <summary>
            </summary>
            <param name="fallbackFunc"></param>
            <returns></returns>
        </member>
        <member name="M:Tsu.Result`2.Equals(Tsu.Result{`0,`1})">
            <summary>
            Checks whether this result is equal to another.
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:Tsu.Result`2.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Tsu.Result`2.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Tsu.Result`2.op_Equality(Tsu.Result{`0,`1},Tsu.Result{`0,`1})">
            <summary>
            Checks structural equality between two <see cref="T:Tsu.Result`2" /> s.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Tsu.Result`2.op_Inequality(Tsu.Result{`0,`1},Tsu.Result{`0,`1})">
            <summary>
            Checks structural difference between two <see cref="T:Tsu.Result`2" /> s.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Tsu.Result`2.op_Explicit(`0)~Tsu.Result{`0,`1}">
            <summary>
            Converts an <paramref name="ok" /> value to a result.
            </summary>
            <param name="ok"></param>
        </member>
        <member name="M:Tsu.Result`2.op_Explicit(`1)~Tsu.Result{`0,`1}">
            <summary>
            Converts an <paramref name="err" /> value to a result.
            </summary>
            <param name="err"></param>
        </member>
        <member name="T:Tsu.ResultExtensions">
            <summary>
            Extension methods for <see cref="T:Tsu.Result`2" />.
            </summary>
        </member>
        <member name="M:Tsu.ResultExtensions.Transpose``2(Tsu.Result{Tsu.Option{``0},``1})">
            <summary>
            Transposes a Result of an Option into an Option of a Result.
            </summary>
            <remarks>
            The mapping rules are the same as rust:
            <list type="bullet">
            <item>Ok(None) → None</item>
            <item>Ok(Some(x)) → Some(Ok(x))</item>
            <item>Err(x) → Some(Err(x))</item>
            </list>
            </remarks>
            <typeparam name="TOk"></typeparam>
            <typeparam name="TErr"></typeparam>
            <param name="self"></param>
            <returns></returns>
        </member>
        <member name="T:Tsu.Timing.ConsoleTimingLogger">
            <summary>
            A <see cref="T:Tsu.Timing.TimingLogger" /> that outputs to the Console
            </summary>
        </member>
        <member name="M:Tsu.Timing.ConsoleTimingLogger.#ctor">
            <summary>
            Initializes a new console timing logger
            </summary>
        </member>
        <member name="M:Tsu.Timing.ConsoleTimingLogger.WriteInternal(System.String)">
            <summary>
            <inheritdoc />
            </summary>
            <param name="str"></param>
        </member>
        <member name="M:Tsu.Timing.ConsoleTimingLogger.WriteInternal(System.String,System.ConsoleColor)">
            <summary>
            <inheritdoc />
            </summary>
            <param name="str"></param>
            <param name="color"></param>
        </member>
        <member name="M:Tsu.Timing.ConsoleTimingLogger.WriteLineInternal(System.String)">
            <summary>
            <inheritdoc />
            </summary>
            <param name="line"></param>
        </member>
        <member name="M:Tsu.Timing.ConsoleTimingLogger.WriteLineInternal(System.String,System.ConsoleColor)">
            <summary>
            <inheritdoc />
            </summary>
            <param name="line"></param>
            <param name="color"></param>
        </member>
        <member name="M:Tsu.Timing.ConsoleTimingLogger.ReadLine">
            <summary>
            Reads an line of input from the console
            </summary>
            <returns></returns>
        </member>
        <member name="T:Tsu.Timing.MicroProfiler">
            <summary>
            A micro profiler. Basically a tree of Stopwatches with associated names.
            </summary>
        </member>
        <member name="M:Tsu.Timing.MicroProfiler.StartNew(System.String)">
            <summary>
            Instantiates and starts a new <see cref="T:Tsu.Timing.MicroProfiler" />
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="F:Tsu.Timing.MicroProfiler._childProfilers">
            <summary>
            The list of child profilers.
            </summary>
        </member>
        <member name="F:Tsu.Timing.MicroProfiler._stopwatch">
            <summary>
            The stopwatch used for timing of this micro profiler.
            </summary>
        </member>
        <member name="P:Tsu.Timing.MicroProfiler.Name">
            <summary>
            The name associated with this microprofiler
            </summary>
        </member>
        <member name="P:Tsu.Timing.MicroProfiler.ChildProfilers">
            <summary>
            The list of child microprofilers
            </summary>
        </member>
        <member name="P:Tsu.Timing.MicroProfiler.ElapsedMilliseconds">
            <summary>
            The total milliseconds elapsed on this operation
            </summary>
        </member>
        <member name="M:Tsu.Timing.MicroProfiler.#ctor(System.String)">
             <summary>
             Initializes a new MicroProfiler with the given name.
            
             Does NOT start the internal stopwatch.
             </summary>
             <param name="name"></param>
        </member>
        <member name="M:Tsu.Timing.MicroProfiler.StartChild(System.String)">
            <summary>
            Instantiates, starts and adds a new <see cref="T:Tsu.Timing.MicroProfiler" /> with the provided
            <paramref name="name" /> to the <see cref="P:Tsu.Timing.MicroProfiler.ChildProfilers" />.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Tsu.Timing.MicroProfiler.Start">
            <summary>
            Starts the internal stopwatch
            </summary>
        </member>
        <member name="M:Tsu.Timing.MicroProfiler.Restart">
            <summary>
            Restarts the internal stopwatch
            </summary>
        </member>
        <member name="M:Tsu.Timing.MicroProfiler.Stop">
            <summary>
            Stops the internal stopwatch
            </summary>
        </member>
        <member name="M:Tsu.Timing.MicroProfiler.Reset">
            <summary>
            Resets the internal stopwatch
            </summary>
        </member>
        <member name="M:Tsu.Timing.MicroProfiler.WriteTreeString(System.Text.StringBuilder)">
            <summary>
            Writes the tree of timings to the provided <paramref name="builder" />.
            </summary>
            <param name="builder"></param>
        </member>
        <member name="M:Tsu.Timing.MicroProfiler.ToString">
            <summary>
            Outputs the tree of <see cref="T:Tsu.Timing.MicroProfiler" /> s as an ASCII-like tree.
            </summary>
            <remarks>Uses the followign unicode characters: │, ├, ─ and └</remarks>
            <returns></returns>
        </member>
        <member name="M:Tsu.Timing.MicroProfiler.Dispose">
            <inheritdoc/>
        </member>
        <member name="M:Tsu.Timing.MicroProfiler.WriteTreeString(System.Text.StringBuilder,System.String,System.Boolean,System.Boolean)">
            <summary>
            Recursively writes the tree containing all timings to the provided
            <paramref name="builder" />.
            </summary>
            <param name="builder">
            The <see cref="T:System.Text.StringBuilder" /> where all output will be written to.
            </param>
            <param name="indent">The indentation up to this level.</param>
            <param name="isLast">
            Whether this is the last compiler in it's parent node.
            </param>
            <param name="isRoot">Whether this is the root microprofiler.</param>
        </member>
        <member name="T:Tsu.Timing.LogLevel">
            <summary>
            The level of the logged information
            </summary>
        </member>
        <member name="F:Tsu.Timing.LogLevel.None">
            <summary>
            The message does not have a log level
            </summary>
        </member>
        <member name="F:Tsu.Timing.LogLevel.Debug">
            <summary>
            The message is a debug message
            </summary>
        </member>
        <member name="F:Tsu.Timing.LogLevel.Information">
            <summary>
            The message is an information message
            </summary>
        </member>
        <member name="F:Tsu.Timing.LogLevel.Warning">
            <summary>
            The message is a warning message
            </summary>
        </member>
        <member name="F:Tsu.Timing.LogLevel.Error">
            <summary>
            The message is an error message
            </summary>
        </member>
        <member name="T:Tsu.Timing.TimingLogger">
            <summary>
            A logger with embbeded timing information in every line.
            </summary>
        </member>
        <member name="T:Tsu.Timing.TimingLogger.Scope">
            <summary>
            Represents a scope that was entered
            </summary>
        </member>
        <member name="F:Tsu.Timing.TimingLogger.Scope._owner">
            <summary>
            The <see cref="T:Tsu.Timing.TimingLogger"/> that owns this scope
            </summary>
        </member>
        <member name="P:Tsu.Timing.TimingLogger.Scope.Name">
            <summary>
            The user provided name of the scope
            </summary>
        </member>
        <member name="P:Tsu.Timing.TimingLogger.Scope.StartedAt">
            <summary>
            The <see cref="P:Tsu.Timing.TimingLogger.Elapsed"/> at which this scope was entered
            </summary>
        </member>
        <member name="P:Tsu.Timing.TimingLogger.Scope.ShouldPrintElapsedTime">
            <summary>
            Whether the amount of time elapsed on this scope should be printed at the end.
            </summary>
        </member>
        <member name="M:Tsu.Timing.TimingLogger.Scope.#ctor(Tsu.Timing.TimingLogger,System.String,System.TimeSpan,System.Boolean)">
            <summary>
            Initializes a scope
            </summary>
            <param name="owner"></param>
            <param name="name"></param>
            <param name="startedAt"></param>
            <param name="shouldPrintElapsedTime"></param>
        </member>
        <member name="F:Tsu.Timing.TimingLogger.Operation._owner">
            <summary>
            The <see cref="T:Tsu.Timing.TimingLogger"/> that owns this scope
            </summary>
        </member>
        <member name="P:Tsu.Timing.TimingLogger.Operation.Name">
            <summary>
            The user provided name of the scope
            </summary>
        </member>
        <member name="P:Tsu.Timing.TimingLogger.Operation.StartedAt">
            <summary>
            The <see cref="P:Tsu.Timing.TimingLogger.Elapsed"/> at which this scope was entered
            </summary>
        </member>
        <member name="P:Tsu.Timing.TimingLogger.Operation.ShouldPrintElapsedTime">
            <summary>
            Whether the amount of time elapsed on this scope should be printed at the end.
            </summary>
        </member>
        <member name="M:Tsu.Timing.TimingLogger.Operation.#ctor(Tsu.Timing.TimingLogger,System.String,System.TimeSpan,System.Boolean)">
            <summary>
            Initializes a scope
            </summary>
            <param name="owner"></param>
            <param name="name"></param>
            <param name="startedAt"></param>
            <param name="shouldPrintElapsedTime"></param>
        </member>
        <member name="P:Tsu.Timing.TimingLogger.HasLineBeenPrefixed">
            <summary>
            Whether the current line has already been prefixed
            </summary>
        </member>
        <member name="P:Tsu.Timing.TimingLogger.DebugColor">
            <summary>
            Color used for the prefix of <see cref="F:Tsu.Timing.LogLevel.Debug"/> messages
            </summary>
        </member>
        <member name="P:Tsu.Timing.TimingLogger.InformationColor">
            <summary>
            Color used for the prefix of <see cref="F:Tsu.Timing.LogLevel.Information"/> messages
            </summary>
        </member>
        <member name="P:Tsu.Timing.TimingLogger.WarningColor">
            <summary>
            Color used for the prefix of <see cref="F:Tsu.Timing.LogLevel.Warning"/> messages
            </summary>
        </member>
        <member name="P:Tsu.Timing.TimingLogger.ErrorColor">
            <summary>
            Color used for the prefix of <see cref="F:Tsu.Timing.LogLevel.Error"/> messages
            </summary>
        </member>
        <member name="P:Tsu.Timing.TimingLogger.MinimumLogLevel">
            <summary>
            The minimum log level of the messages that should be printed
            </summary>
        </member>
        <member name="P:Tsu.Timing.TimingLogger.PrintLevelPrefixes">
             <summary>
             Whether to pring
             <code>
            [INFO]
             </code>
             ,
             <code>
            [DBUG]
             </code>
             ,
             <code>
            [WARN]
             </code>
             and
             <code>
            [FAIL]
             </code>
             prefixes according to the message's <see cref="T:Tsu.Timing.LogLevel"/>
             </summary>
        </member>
        <member name="P:Tsu.Timing.TimingLogger.Elapsed">
            <summary>
            The amount of time elapsed since this logger started
            </summary>
        </member>
        <member name="M:Tsu.Timing.TimingLogger.#ctor">
            <summary>
            Initializes a TimingLogger
            </summary>
        </member>
        <member name="M:Tsu.Timing.TimingLogger.WriteInternal(System.String)">
            <summary>
            Writes a value to the output
            </summary>
            <param name="str"></param>
        </member>
        <member name="M:Tsu.Timing.TimingLogger.WriteInternal(System.String,System.ConsoleColor)">
            <summary>
            Writes a value to the output with a given color
            </summary>
            <param name="str"></param>
            <param name="color"></param>
        </member>
        <member name="M:Tsu.Timing.TimingLogger.WriteLineInternal(System.String)">
            <summary>
            Writes a value to the output followed by a line break
            </summary>
            <param name="line"></param>
        </member>
        <member name="M:Tsu.Timing.TimingLogger.WriteLineInternal(System.String,System.ConsoleColor)">
            <summary>
            Writes a value to the output followed by a line break with a given color
            </summary>
            <param name="line"></param>
            <param name="color"></param>
        </member>
        <member name="M:Tsu.Timing.TimingLogger.WriteLinePrefix(Tsu.Timing.LogLevel)">
            <summary>
            Writes the elapsed time and the <see cref="T:Tsu.Timing.LogLevel"/> prefix, if enabled through <see cref="P:Tsu.Timing.TimingLogger.PrintLevelPrefixes"/>
            </summary>
            <param name="level"></param>
        </member>
        <member name="M:Tsu.Timing.TimingLogger.ProcessWrite(Tsu.Timing.LogLevel,System.String)">
            <summary>
            Processes a call to write a value to the output
            </summary>
            <param name="level"></param>
            <param name="message"></param>
        </member>
        <member name="M:Tsu.Timing.TimingLogger.ProcessWriteLine(Tsu.Timing.LogLevel,System.String)">
            <summary>
            Processes a WriteLine request with a specified log level and message
            </summary>
            <param name="level"></param>
            <param name="message"></param>
        </member>
        <member name="M:Tsu.Timing.TimingLogger.Write(System.Object)">
            <summary>
            Writes a value to the output
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Tsu.Timing.TimingLogger.Write(System.String)">
            <summary>
            Writes a value to the output
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Tsu.Timing.TimingLogger.Write(System.String,System.Object[])">
            <summary>
            Writes a value to the output
            </summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="M:Tsu.Timing.TimingLogger.WriteLine(System.Object)">
            <summary>
            Writes a value to the output followed by a new line
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Tsu.Timing.TimingLogger.WriteLine(System.String)">
            <summary>
            Writes a value to the output followed by a new line
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Tsu.Timing.TimingLogger.WriteLine(System.String,System.Object[])">
            <summary>
            Writes a value to the output followed by a new line
            </summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="M:Tsu.Timing.TimingLogger.LogMessage(Tsu.Timing.LogLevel,System.String)">
            <summary>
            Logs a message to the output
            </summary>
            <param name="level"></param>
            <param name="message"></param>
        </member>
        <member name="M:Tsu.Timing.TimingLogger.LogMessage(Tsu.Timing.LogLevel,System.String,System.Object[])">
            <summary>
            Logs a message to the output
            </summary>
            <param name="level"></param>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="M:Tsu.Timing.TimingLogger.LogDebug(System.String)">
            <summary>
            Logs a debug message to the output
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:Tsu.Timing.TimingLogger.LogDebug(System.String,System.Object[])">
            <summary>
            Logs a debug message to the output
            </summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="M:Tsu.Timing.TimingLogger.LogInformation(System.String)">
            <summary>
            Logs an information message to the output
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:Tsu.Timing.TimingLogger.LogInformation(System.String,System.Object[])">
            <summary>
            Logs an information message to the output
            </summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="M:Tsu.Timing.TimingLogger.LogWarning(System.String)">
            <summary>
            Logs a warning message to the outout
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:Tsu.Timing.TimingLogger.LogWarning(System.String,System.Object[])">
            <summary>
            Logs a warning message to the outout
            </summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="M:Tsu.Timing.TimingLogger.LogError(System.String)">
            <summary>
            Logs an error message to the output
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:Tsu.Timing.TimingLogger.LogError(System.String,System.Object[])">
            <summary>
            Logs an error message to the output
            </summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="M:Tsu.Timing.TimingLogger.BeginScope(System.String,System.Boolean)">
            <summary>
            Begins a logging scope
            </summary>
            <param name="name"></param>
            <param name="shouldPrintElapsedTime">
            Whether the elapsed time on this scope should be printed at it's disposal
            </param>
            <returns></returns>
        </member>
        <member name="M:Tsu.Timing.TimingLogger.BeginOperation(System.String,System.Boolean)">
            <summary>
            Begins an operation that won't have any logging inside it. For operations that will
            oputput logs, use <see cref="M:Tsu.Timing.TimingLogger.BeginScope(System.String,System.Boolean)"/>.
            </summary>
            <param name="name"></param>
            <param name="shouldPrintElapsedTime"></param>
            <returns></returns>
        </member>
        <member name="T:Tsu.Unit">
            <summary>
            A unit value.
            </summary>
        </member>
        <member name="F:Tsu.Unit.Value">
            <summary>
            The unit type instance.
            </summary>
        </member>
        <member name="M:Tsu.Unit.CompareTo(Tsu.Unit)">
            <inheritdoc/>
        </member>
        <member name="M:Tsu.Unit.CompareTo(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Tsu.Unit.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Tsu.Unit.Equals(Tsu.Unit)">
            <inheritdoc/>
        </member>
        <member name="M:Tsu.Unit.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Tsu.Unit.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Tsu.Unit.op_Equality(Tsu.Unit,Tsu.Unit)">
            <summary>
            Checks if one <see cref="T:Tsu.Unit"/> equals other <see cref="T:Tsu.Unit"/>.
            Always true because <see cref="T:Tsu.Unit"/> can only assume 1 value.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Tsu.Unit.op_Inequality(Tsu.Unit,Tsu.Unit)">
            <summary>
            Checks if one <see cref="T:Tsu.Unit"/> is not equal to other <see cref="T:Tsu.Unit"/>.
            Always false because <see cref="T:Tsu.Unit"/> can only assume 1 value.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Tsu.Unit.op_LessThan(Tsu.Unit,Tsu.Unit)">
            <summary>
            Checks if one <see cref="T:Tsu.Unit"/> is less than other <see cref="T:Tsu.Unit"/>.
            Always false because <see cref="T:Tsu.Unit"/> can only assume 1 value.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Tsu.Unit.op_LessThanOrEqual(Tsu.Unit,Tsu.Unit)">
            <summary>
            Checks if one <see cref="T:Tsu.Unit"/> is less than or equal other <see cref="T:Tsu.Unit"/>.
            Always true because <see cref="T:Tsu.Unit"/> can only assume 1 value.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Tsu.Unit.op_GreaterThan(Tsu.Unit,Tsu.Unit)">
            <summary>
            Checks if one <see cref="T:Tsu.Unit"/> is greater than other <see cref="T:Tsu.Unit"/>.
            Always false because <see cref="T:Tsu.Unit"/> can only assume 1 value.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Tsu.Unit.op_GreaterThanOrEqual(Tsu.Unit,Tsu.Unit)">
            <summary>
            Checks if one <see cref="T:Tsu.Unit"/> is greater than or equal other <see cref="T:Tsu.Unit"/>.
            Always true because <see cref="T:Tsu.Unit"/> can only assume 1 value.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
    </members>
</doc>
